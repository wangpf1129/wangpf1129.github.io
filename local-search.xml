<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>给自己写的docker文档</title>
    <link href="/2022/07/01/73-docker/"/>
    <url>/2022/07/01/73-docker/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker学习笔记"><a href="#Docker学习笔记" class="headerlink" title="Docker学习笔记"></a>Docker学习笔记</h1><h2 id="docker的基本组成"><a href="#docker的基本组成" class="headerlink" title="docker的基本组成"></a>docker的基本组成</h2><blockquote><p>镜像（image）</p></blockquote><ul><li>  docker镜像类似一个模板，可以通过这个模板来创建容器服务。</li><li>  如： node镜像 ===》 run ===》 node001容器（用来提供服务）</li><li>  通过这个node镜像可以创建多个容器，最终服务会运行在容器中。</li></ul><blockquote><p>容器（container）</p></blockquote><ul><li>  docker利用容器技术，独立运行一个或一组应用，通过镜像创建</li><li>  包含 启动、停止、删除等基本命令</li><li>  可以把容器理解为一个简易的 linux系统</li></ul><blockquote><p>仓库（repository）</p></blockquote><ul><li>  存放镜像的地方</li><li>  仓库可分为 公共仓库 和 私有仓库</li><li>  比如 Docker Hub 、 阿里云、腾讯云等等…</li></ul><h2 id="docker-安装"><a href="#docker-安装" class="headerlink" title="docker 安装"></a>docker 安装</h2><p>默认是在linux上演示,以我的阿里云1G2核服务器,<strong>CentOS8</strong>为例。</p><blockquote><p>查看系统内核：</p></blockquote><ul><li>  我的内核版本为 4.18.0</li></ul><pre><code class="hljs autoit">[root<span class="hljs-symbol">@wangpf</span> ~]<span class="hljs-meta"># uname -r</span><span class="hljs-number">4.18</span><span class="hljs-number">.0</span><span class="hljs-number">-193.28</span><span class="hljs-number">.1</span>.el8_2.x86_64</code></pre><blockquote><p>查看系统配置： (注意docker在centos上需要在版本7以上！)</p></blockquote><ul><li>  cat /etc/os-release</li></ul><pre><code class="hljs makefile">[root@wangpf ~]<span class="hljs-comment"># cat /etc/os-release </span>NAME=<span class="hljs-string">&quot;CentOS Linux&quot;</span>VERSION=<span class="hljs-string">&quot;8 (Core)&quot;</span>ID=<span class="hljs-string">&quot;centos&quot;</span>ID_LIKE=<span class="hljs-string">&quot;rhel fedora&quot;</span>VERSION_ID=<span class="hljs-string">&quot;8&quot;</span>PLATFORM_ID=<span class="hljs-string">&quot;platform:el8&quot;</span>PRETTY_NAME=<span class="hljs-string">&quot;CentOS Linux 8 (Core)&quot;</span>ANSI_COLOR=<span class="hljs-string">&quot;0;31&quot;</span>CPE_NAME=<span class="hljs-string">&quot;cpe:/o:centos:centos:8&quot;</span>HOME_URL=<span class="hljs-string">&quot;https://www.centos.org/&quot;</span>BUG_REPORT_URL=<span class="hljs-string">&quot;https://bugs.centos.org/&quot;</span>​CENTOS_MANTISBT_PROJECT=<span class="hljs-string">&quot;CentOS-8&quot;</span>CENTOS_MANTISBT_PROJECT_VERSION=<span class="hljs-string">&quot;8&quot;</span>REDHAT_SUPPORT_PRODUCT=<span class="hljs-string">&quot;centos&quot;</span>REDHAT_SUPPORT_PRODUCT_VERSION=<span class="hljs-string">&quot;8&quot;</span></code></pre><h3 id="安装步骤："><a href="#安装步骤：" class="headerlink" title="安装步骤："></a>安装步骤：</h3><p>官网文档：<a href="https://docs.docker.com/engine/install/centos/">“Install Docker Engine on CentOS”</a></p><h4 id="1-如果有旧版docker，需要先卸载旧的"><a href="#1-如果有旧版docker，需要先卸载旧的" class="headerlink" title="1. 如果有旧版docker，需要先卸载旧的"></a>1. 如果有旧版docker，需要先卸载旧的</h4><pre><code class="hljs livescript">sudo yum remove docker <span class="hljs-string">\</span>                 docker-client <span class="hljs-string">\</span>                 docker-client-latest <span class="hljs-string">\</span>                 docker-common <span class="hljs-string">\</span>                 docker-latest <span class="hljs-string">\</span>                 docker-latest-logrotate <span class="hljs-string">\</span>                 docker-logrotate <span class="hljs-string">\</span>                 docker-engine</code></pre><h4 id="2-下载docker需要的安装包"><a href="#2-下载docker需要的安装包" class="headerlink" title="2. 下载docker需要的安装包"></a>2. 下载docker需要的安装包</h4><pre><code class="hljs cmake">  sudo yum <span class="hljs-keyword">install</span> -y yum-utils</code></pre><h4 id="3-设置镜像仓库"><a href="#3-设置镜像仓库" class="headerlink" title="3. 设置镜像仓库"></a>3. 设置镜像仓库</h4><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 注意这个源是在国外，若没有开代理会很慢。sudo yum-config-manager \   --add-repo \   https:<span class="hljs-regexp">//</span>download.docker.com<span class="hljs-regexp">/linux/</span>centos/docker-ce.repo</code></pre><h4 id="4-更新yum软件包索引"><a href="#4-更新yum软件包索引" class="headerlink" title="4. 更新yum软件包索引"></a>4. 更新yum软件包索引</h4><pre><code class="hljs awk">yum makecache fast​<span class="hljs-regexp">//</span> 注 centos <span class="hljs-number">8</span>以上要去掉fast</code></pre><h4 id="5-安装docker相关设置"><a href="#5-安装docker相关设置" class="headerlink" title="5. 安装docker相关设置"></a>5. 安装docker相关设置</h4><p><code>注： docker-ce 是社区版 docker-ee是企业版</code></p><pre><code class="hljs vim">yum install docker-<span class="hljs-keyword">ce</span> docker-<span class="hljs-keyword">ce</span>-cli containerd.io</code></pre><h4 id="6-启动-docker"><a href="#6-启动-docker" class="headerlink" title="6. 启动 docker"></a>6. 启动 docker</h4><pre><code class="hljs crmsh">systemctl <span class="hljs-literal">start</span> docker<span class="hljs-comment"># 查看当前版本号， 是否启动成功</span>docker <span class="hljs-keyword">version</span><span class="hljs-comment"># 设置开机自启动</span>systemctl enbale docker</code></pre><p>下载 hello-world 测试一下</p><pre><code class="hljs routeros">docker <span class="hljs-built_in">run</span> hello-world</code></pre><p><code>注：没有安装的话，会自动去dockerHub上面找并拉取最新版本</code></p><h4 id="7-查看-hello-world-的镜像"><a href="#7-查看-hello-world-的镜像" class="headerlink" title="7. 查看 hello-world 的镜像"></a>7. 查看 hello-world 的镜像</h4><pre><code class="hljs ebnf"><span class="hljs-attribute">docker images</span></code></pre><pre><code class="hljs crmsh">[root@wangpf ~]<span class="hljs-comment"># docker images</span>REPOSITORY    <span class="hljs-keyword">TAG</span>       <span class="hljs-title">IMAGE</span> ID       CREATED        SIZEhello-world   latest    feb5d9fea6a5   <span class="hljs-number">2</span> months ago   <span class="hljs-number">13.3</span>kB</code></pre><h3 id="卸载docker"><a href="#卸载docker" class="headerlink" title="卸载docker"></a>卸载docker</h3><p>文档链接： <a href="https://docs.docker.com/engine/install/centos/#uninstall-docker-engine">uninstall-docker-engine</a></p><h3 id="配置国内加速"><a href="#配置国内加速" class="headerlink" title="配置国内加速"></a>配置国内加速</h3><blockquote><p>镜像加速源</p></blockquote><table><thead><tr><th>镜像加速器</th><th>镜像加速器地址</th></tr></thead><tbody><tr><td>Docker 中国官方镜像</td><td><a href="https://registry.docker-cn.com/">https://registry.docker-cn.com</a></td></tr><tr><td>DaoCloud 镜像站</td><td><a href="http://f1361db2.m.daocloud.io/">http://f1361db2.m.daocloud.io</a></td></tr><tr><td>Azure 中国镜像</td><td><a href="https://dockerhub.azk8s.cn/">https://dockerhub.azk8s.cn</a></td></tr><tr><td>科大镜像站</td><td><a href="https://docker.mirrors.ustc.edu.cn/">https://docker.mirrors.ustc.edu.cn</a></td></tr><tr><td>阿里云</td><td>https://<your_code>.mirror.aliyuncs.com</td></tr><tr><td>七牛云</td><td><a href="https://reg-mirror.qiniu.com/">https://reg-mirror.qiniu.com</a></td></tr><tr><td>网易云</td><td><a href="https://hub-mirror.c.163.com/">https://hub-mirror.c.163.com</a></td></tr><tr><td>腾讯云</td><td><a href="https://mirror.ccs.tencentyun.com/">https://mirror.ccs.tencentyun.com</a></td></tr></tbody></table><h2 id="docker-基本命令"><a href="#docker-基本命令" class="headerlink" title="docker 基本命令"></a>docker 基本命令</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c8c958f2b4f24befaa3644904b6f577b~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="image.png"></p><h3 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h3><pre><code class="hljs applescript"><span class="hljs-comment"># docker 的版本信息</span>docker <span class="hljs-built_in">version</span> <span class="hljs-comment"># docker 的系统信息，包括镜像和容器的数量</span>docker info<span class="hljs-comment"># 帮助命令</span>docker xxx <span class="hljs-comment">--help</span></code></pre><p>官方文档命令指南：<a href="https://docs.docker.com/engine/reference/commandline/cli/">docker command line</a></p><p>个人还是很喜欢用命令行来帮助自己快速熟知具体命令，主要是因为是快且方便（因为文档是在国外）</p><h3 id="镜像基本命令"><a href="#镜像基本命令" class="headerlink" title="镜像基本命令"></a>镜像基本命令</h3><p>docker images 查看本地主机上的镜像</p><pre><code class="hljs applescript">[root@wangpf ~]<span class="hljs-comment"># docker images</span>REPOSITORY    TAG       IMAGE ID       CREATED        SIZEhello-world   latest    feb5d9fea6a5   <span class="hljs-number">2</span> months ago   <span class="hljs-number">13.3</span>kB<span class="hljs-comment"># 可选项</span>[root@wangpf ~]<span class="hljs-comment"># docker images --help</span>Usage:  docker images [OPTIONS] [REPOSITORY[:TAG]]List imagesOptions:  -a, <span class="hljs-comment">--all             Show all images (default hides intermediate images)</span>      <span class="hljs-comment">--digests         Show digests</span>  -f, <span class="hljs-comment">--filter filter   Filter output based on conditions provided</span>      <span class="hljs-comment">--format string   Pretty-print images using a Go template</span>      <span class="hljs-comment">--no-trunc        Don&#x27;t truncate output</span>  -q, <span class="hljs-comment">--quiet           Only show image IDs</span></code></pre><h4 id="1-搜索镜像"><a href="#1-搜索镜像" class="headerlink" title="1. 搜索镜像"></a>1. 搜索镜像</h4><pre><code class="hljs excel">docker <span class="hljs-built_in">search</span> 镜像名</code></pre><p>比如：<code>docker search node</code></p><pre><code class="hljs crmsh">[root@wangpf ~]<span class="hljs-comment"># docker search node</span>NAME                                   DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED<span class="hljs-keyword">node</span>                                   <span class="hljs-title">Node</span>.js is a JavaScript-based platform for s…   <span class="hljs-number">10852</span>     [OK]mongo-express                          Web-based MongoDB admin interface, written w…   <span class="hljs-number">1092</span>      [OK]nodered/<span class="hljs-keyword">node</span><span class="hljs-title">-red</span>                       Low-code programming for event-driven applic…   <span class="hljs-number">387</span>nodered/<span class="hljs-keyword">node</span><span class="hljs-title">-red-docker</span>                Deprecated - older <span class="hljs-keyword">Node</span><span class="hljs-title">-RED</span> Docker images.      <span class="hljs-number">353</span>                  [OK]prom/<span class="hljs-keyword">node</span><span class="hljs-title">-exporter</span>                                                                     <span class="hljs-number">266</span>                  [OK]selenium/<span class="hljs-keyword">node</span><span class="hljs-title">-chrome</span>                                                                   <span class="hljs-number">228</span>                  [OK]....</code></pre><p>或者去 docker Hub上去找：<a href="https://hub.docker.com/">docker Hub 官网</a></p><h4 id="2-下载镜像"><a href="#2-下载镜像" class="headerlink" title="2. 下载镜像"></a>2. 下载镜像</h4><pre><code class="hljs elixir">docker pull 镜像名   <span class="hljs-comment"># 默认下载最新版本</span>docker pull 镜像名<span class="hljs-symbol">:&lt;version&gt;</span>  <span class="hljs-comment"># 下载指定版本</span></code></pre><p>举例： 下载node</p><pre><code class="hljs makefile">[root@wangpf ~]<span class="hljs-comment"># docker pull node</span>Using default tag: latest<span class="hljs-section">latest: Pulling from library/node</span><span class="hljs-section">5e0b432e8ba9: Pull complete</span><span class="hljs-section">a84cfd68b5ce: Pull complete</span><span class="hljs-section">e8b8f2315954: Pull complete</span><span class="hljs-section">0598fa43a7e7: Pull complete</span><span class="hljs-section">83098237b6d3: Pull complete</span><span class="hljs-section">ddb281e9d102: Pull complete</span><span class="hljs-section">f2395e503032: Pull complete</span><span class="hljs-section">923ae81df72f: Pull complete</span><span class="hljs-section">e398359b21ac: Pull complete</span><span class="hljs-section">Digest: sha256:13621aa823b6b92572d19c08a75f7b1a061633089f37873f8b5bedb5e900e657</span><span class="hljs-section">Status: Downloaded newer image for node:latest</span><span class="hljs-section">docker.io/library/node:latest</span></code></pre><blockquote><p>注： docker pull node === docker pull docker.io/library/node:latest</p></blockquote><p>下载某个具体版本 <code>注意：该版本必须是在dockerHub上存在的版本才行。</code></p><pre><code class="hljs crmsh">[root@wangpf ~]<span class="hljs-comment"># docker pull node:14.18.2-alpine</span><span class="hljs-number">14.18</span>.<span class="hljs-number">2</span>-alpine: Pulling from library/<span class="hljs-keyword">node</span>97518928ae5f:<span class="hljs-title"> Pull</span> complete<span class="hljs-number">23182</span>d7a473a: Pull completec006eebfdd13: Pull completea3c2ac39ae5d: Pull completeDigest: sha256:<span class="hljs-number">7</span>bcf853eeb97a25465cb385b015606c22e926f548cbd117f85b7196df8aa0d29Status: Downloaded newer image for <span class="hljs-keyword">node</span><span class="hljs-title">:14</span>.<span class="hljs-number">18.2</span>-alpinedocker.io/library/<span class="hljs-keyword">node</span><span class="hljs-title">:14</span>.<span class="hljs-number">18.2</span>-alpine</code></pre><h4 id="3-删除镜像"><a href="#3-删除镜像" class="headerlink" title="3. 删除镜像"></a>3. 删除镜像</h4><pre><code class="hljs nginx"><span class="hljs-attribute">docker</span> rmi    <span class="hljs-comment"># 注意 i 代表的是镜像</span></code></pre><p>骚操作：</p><pre><code class="hljs reasonml">docker rmi -f <span class="hljs-constructor">$(<span class="hljs-params">docker</span> <span class="hljs-params">images</span> -<span class="hljs-params">aq</span>)</span>   # 强制删除所有的镜像</code></pre><h3 id="容器基本命令"><a href="#容器基本命令" class="headerlink" title="容器基本命令"></a>容器基本命令</h3><blockquote><p>有了镜像才可以创建容器</p></blockquote><h4 id="1-创建容器并启动"><a href="#1-创建容器并启动" class="headerlink" title="1. 创建容器并启动"></a>1. 创建容器并启动</h4><p>docker run –help 发现有太多参数了，举出常用的几个。</p><pre><code class="hljs applescript">docker <span class="hljs-built_in">run</span> [可选参数] image<span class="hljs-comment"># 参数说明</span><span class="hljs-comment">--name string                    Assign a name to the container (容器名字，用来区分容器)</span>-d, <span class="hljs-comment">--detach                     Run container in background and print container ID（后台方式运行）</span>-<span class="hljs-keyword">it</span> 使用交互方式运行，进入容器内查看-p, <span class="hljs-comment">--publish list               Publish a container&#x27;s port(s) to the host （指定一个容器端口）</span>-P, <span class="hljs-comment">--publish-all                Publish all exposed ports to random ports  (随机指定端口)</span><span class="hljs-comment">--rm                             Automatically remove the container when it exits</span></code></pre><p><strong>测试一下： 比如下载个centos镜像并创建容器并进入容器中</strong></p><pre><code class="hljs applescript">docker pull centosdocker <span class="hljs-built_in">run</span> -<span class="hljs-keyword">it</span> centos /bin/bash</code></pre><pre><code class="hljs tcl">[root@wangpf ~]# docker run -it centos /bin/bash[root@<span class="hljs-number">3</span>bcf93dd0c56 /]# lsbin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  <span class="hljs-keyword">proc</span><span class="hljs-title">  root</span> <span class="hljs-title"> run</span> <span class="hljs-title"> sbin</span> <span class="hljs-title"> srv</span> <span class="hljs-title"> sys</span> <span class="hljs-title"> tmp</span> <span class="hljs-title"> usr</span> <span class="hljs-title"> var</span>[root@3bcf93dd0c56 /]#</code></pre><h4 id="2-列出所有容器"><a href="#2-列出所有容器" class="headerlink" title="2. 列出所有容器"></a>2. 列出所有容器</h4><p>常用参数</p><pre><code class="hljs css"># docker ps  列出当前正在运行的容器-<span class="hljs-selector-tag">a</span>, <span class="hljs-attr">--all</span>             Show <span class="hljs-attribute">all</span> containers (default shows just running)   列出所有运行过的容器-n, <span class="hljs-attr">--last</span> int        Show n last created containers (includes <span class="hljs-attribute">all</span> states) (default -<span class="hljs-number">1</span>)  显示最近创建的容器-<span class="hljs-selector-tag">q</span>, <span class="hljs-attr">--quiet</span>           Only <span class="hljs-attribute">display</span> container IDs  显示容器编号</code></pre><h4 id="3-退出容器"><a href="#3-退出容器" class="headerlink" title="3. 退出容器"></a>3. 退出容器</h4><p>在容器内如何退出？</p><ul><li>  exit 退出并停止运行 (若不是用run命令进入的容器则只会退出)</li><li>  control + p control + q 只退出</li></ul><h4 id="4-启动和停止容器操作"><a href="#4-启动和停止容器操作" class="headerlink" title="4. 启动和停止容器操作"></a>4. 启动和停止容器操作</h4><pre><code class="hljs bash">docker start [container <span class="hljs-built_in">id</span>]     <span class="hljs-comment"># 启动容器  （启动后，用 `docker attach [container id] 可进入该容器`）</span>docker restart [container <span class="hljs-built_in">id</span>]   <span class="hljs-comment"># 重启容器</span>docker stop [container <span class="hljs-built_in">id</span>]      <span class="hljs-comment"># 停止当前正在运行的容器</span>docker <span class="hljs-built_in">kill</span> [container <span class="hljs-built_in">id</span>]      <span class="hljs-comment"># 强制停止当前容器</span></code></pre><h4 id="5-删除容器"><a href="#5-删除容器" class="headerlink" title="5. 删除容器"></a>5. 删除容器</h4><pre><code class="hljs powershell">docker <span class="hljs-built_in">rm</span> [<span class="hljs-type">container</span> <span class="hljs-type">id</span>]       <span class="hljs-comment"># 删除指定容器，（不能删除正在运行的容器，如果要强制删除 rm -f）</span>docker <span class="hljs-built_in">rm</span> <span class="hljs-operator">-f</span> <span class="hljs-variable">$</span>(docker <span class="hljs-built_in">ps</span> <span class="hljs-literal">-aq</span>)     <span class="hljs-comment"># 删除所有容器</span>docker <span class="hljs-built_in">ps</span> <span class="hljs-literal">-a</span> <span class="hljs-literal">-q</span>|xargs docker <span class="hljs-built_in">rm</span>   <span class="hljs-comment"># 删除所有容器</span></code></pre><h3 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a>其他常用命令</h3><h4 id="1-后台启动容器"><a href="#1-后台启动容器" class="headerlink" title="1. 后台启动容器"></a>1. 后台启动容器</h4><pre><code class="hljs routeros">docker <span class="hljs-built_in">run</span> -d centos</code></pre><p>注意有坑：</p><ol start="0"><li> 当你启动 centos时， 用 docker ps 查看发现并没有容器启动 （原因是因为docker发现该容器没有服务，docker自动将其停止了）</li><li> 所以当 容器使用后台运行时，需要有一个前台进程</li></ol><h4 id="2-查看日志"><a href="#2-查看日志" class="headerlink" title="2. 查看日志"></a>2. 查看日志</h4><pre><code class="hljs bash">docker logs -tf --<span class="hljs-built_in">tail</span> string 容器<span class="hljs-built_in">id</span><span class="hljs-comment"># 参数说明</span>-t   <span class="hljs-comment"># 显示时间戳</span>-f   <span class="hljs-comment"># 保留打印窗口,持续打印（即实时显示）</span>--<span class="hljs-built_in">tail</span> string  <span class="hljs-comment"># 记得加参数 ，如 --tail 10 显示最后10行日志</span></code></pre><h4 id="3-查看容器中进程信息"><a href="#3-查看容器中进程信息" class="headerlink" title="3. 查看容器中进程信息"></a>3. 查看容器中进程信息</h4><p><code>docker top 容器id</code></p><pre><code class="hljs inform7"><span class="hljs-comment">[root@wangpf ~]</span># docker top --helpUsage:  docker top <span class="hljs-keyword">CONTAINER</span> <span class="hljs-comment">[ps OPTIONS]</span>Display the running processes <span class="hljs-keyword">of</span> a <span class="hljs-keyword">container</span></code></pre><pre><code class="hljs tap"><span class="hljs-comment"># 测试</span>[root@wangpf ~]<span class="hljs-comment"># docker top b4f5ff60ef4a</span>UID              PID              PPID             C           STIME            TTY              TIME             CMDroot            <span class="hljs-number"> 7596 </span>           <span class="hljs-number"> 7576 </span>           <span class="hljs-number"> 2 </span>          21:39            pts/0            00:00:00         /bin/bash</code></pre><h4 id="4-查看镜像源数据"><a href="#4-查看镜像源数据" class="headerlink" title="4. 查看镜像源数据"></a>4. 查看镜像源数据</h4><p><code>docker inspect 容器id</code></p><pre><code class="hljs autoit"><span class="hljs-meta"># 测试</span>[root<span class="hljs-symbol">@wangpf</span> ~]<span class="hljs-meta"># docker inspect  b4f5ff60ef4a</span>[    &#123;        <span class="hljs-string">&quot;Id&quot;</span>: <span class="hljs-string">&quot;b4f5ff60ef4abf47c47f751bb38433a807c14460b741331e02dfbc31aa767ae3&quot;</span>,        <span class="hljs-string">&quot;Created&quot;</span>: <span class="hljs-string">&quot;2021-12-12T13:07:00.10041237Z&quot;</span>,        <span class="hljs-string">&quot;Path&quot;</span>: <span class="hljs-string">&quot;/bin/bash&quot;</span>,        <span class="hljs-string">&quot;Args&quot;</span>: [],        <span class="hljs-string">&quot;State&quot;</span>: &#123;            <span class="hljs-string">&quot;Status&quot;</span>: <span class="hljs-string">&quot;exited&quot;</span>,            <span class="hljs-string">&quot;Running&quot;</span>: <span class="hljs-literal">false</span>,            <span class="hljs-string">&quot;Paused&quot;</span>: <span class="hljs-literal">false</span>,            <span class="hljs-string">&quot;Restarting&quot;</span>: <span class="hljs-literal">false</span>,            <span class="hljs-string">&quot;OOMKilled&quot;</span>: <span class="hljs-literal">false</span>,            <span class="hljs-string">&quot;Dead&quot;</span>: <span class="hljs-literal">false</span>,            <span class="hljs-string">&quot;Pid&quot;</span>: <span class="hljs-number">0</span>,            <span class="hljs-string">&quot;ExitCode&quot;</span>: <span class="hljs-number">137</span>,            <span class="hljs-string">&quot;Error&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,            <span class="hljs-string">&quot;StartedAt&quot;</span>: <span class="hljs-string">&quot;2021-12-12T13:07:00.684590947Z&quot;</span>,            <span class="hljs-string">&quot;FinishedAt&quot;</span>: <span class="hljs-string">&quot;2021-12-12T13:08:15.423516148Z&quot;</span>        &#125;,        <span class="hljs-string">&quot;Image&quot;</span>: <span class="hljs-string">&quot;sha256:5d0da3dc976460b72c77d94c8a1ad043720b0416bfc16c52c45d4847e53fadb6&quot;</span>,        <span class="hljs-string">&quot;ResolvConfPath&quot;</span>: <span class="hljs-string">&quot;/var/lib/docker/containers/b4f5ff60ef4abf47c47f751bb38433a807c14460b741331e02dfbc31aa767ae3/resolv.conf&quot;</span>,        <span class="hljs-string">&quot;HostnamePath&quot;</span>: <span class="hljs-string">&quot;/var/lib/docker/containers/b4f5ff60ef4abf47c47f751bb38433a807c14460b741331e02dfbc31aa767ae3/hostname&quot;</span>,        <span class="hljs-string">&quot;HostsPath&quot;</span>: <span class="hljs-string">&quot;/var/lib/docker/containers/b4f5ff60ef4abf47c47f751bb38433a807c14460b741331e02dfbc31aa767ae3/hosts&quot;</span>,        <span class="hljs-string">&quot;LogPath&quot;</span>: <span class="hljs-string">&quot;/var/lib/docker/containers/b4f5ff60ef4abf47c47f751bb38433a807c14460b741331e02dfbc31aa767ae3/b4f5ff60ef4abf47c47f751bb38433a807c14460b741331e02dfbc31aa767ae3-json.log&quot;</span>,        <span class="hljs-string">&quot;Name&quot;</span>: <span class="hljs-string">&quot;/amazing_gagarin&quot;</span>,        <span class="hljs-string">&quot;RestartCount&quot;</span>: <span class="hljs-number">0</span>,        <span class="hljs-string">&quot;Driver&quot;</span>: <span class="hljs-string">&quot;overlay2&quot;</span>,        <span class="hljs-string">&quot;Platform&quot;</span>: <span class="hljs-string">&quot;linux&quot;</span>,        <span class="hljs-string">&quot;MountLabel&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,        <span class="hljs-string">&quot;ProcessLabel&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,        <span class="hljs-string">&quot;AppArmorProfile&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,        <span class="hljs-string">&quot;ExecIDs&quot;</span>: <span class="hljs-literal">null</span>,        <span class="hljs-string">&quot;HostConfig&quot;</span>: &#123;            <span class="hljs-string">&quot;Binds&quot;</span>: <span class="hljs-literal">null</span>,            <span class="hljs-string">&quot;ContainerIDFile&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,            <span class="hljs-string">&quot;LogConfig&quot;</span>: &#123;                <span class="hljs-string">&quot;Type&quot;</span>: <span class="hljs-string">&quot;json-file&quot;</span>,                <span class="hljs-string">&quot;Config&quot;</span>: &#123;&#125;            &#125;,            <span class="hljs-string">&quot;NetworkMode&quot;</span>: <span class="hljs-string">&quot;default&quot;</span>,            <span class="hljs-string">&quot;PortBindings&quot;</span>: &#123;&#125;,            <span class="hljs-string">&quot;RestartPolicy&quot;</span>: &#123;                <span class="hljs-string">&quot;Name&quot;</span>: <span class="hljs-string">&quot;no&quot;</span>,                <span class="hljs-string">&quot;MaximumRetryCount&quot;</span>: <span class="hljs-number">0</span>            &#125;,            <span class="hljs-string">&quot;AutoRemove&quot;</span>: <span class="hljs-literal">false</span>,            <span class="hljs-string">&quot;VolumeDriver&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,            <span class="hljs-string">&quot;VolumesFrom&quot;</span>: <span class="hljs-literal">null</span>,            <span class="hljs-string">&quot;CapAdd&quot;</span>: <span class="hljs-literal">null</span>,            <span class="hljs-string">&quot;CapDrop&quot;</span>: <span class="hljs-literal">null</span>,            <span class="hljs-string">&quot;CgroupnsMode&quot;</span>: <span class="hljs-string">&quot;host&quot;</span>,            <span class="hljs-string">&quot;Dns&quot;</span>: [],            <span class="hljs-string">&quot;DnsOptions&quot;</span>: [],            <span class="hljs-string">&quot;DnsSearch&quot;</span>: [],            <span class="hljs-string">&quot;ExtraHosts&quot;</span>: <span class="hljs-literal">null</span>,            <span class="hljs-string">&quot;GroupAdd&quot;</span>: <span class="hljs-literal">null</span>,            <span class="hljs-string">&quot;IpcMode&quot;</span>: <span class="hljs-string">&quot;private&quot;</span>,            <span class="hljs-string">&quot;Cgroup&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,            <span class="hljs-string">&quot;Links&quot;</span>: <span class="hljs-literal">null</span>,            <span class="hljs-string">&quot;OomScoreAdj&quot;</span>: <span class="hljs-number">0</span>,            <span class="hljs-string">&quot;PidMode&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,            <span class="hljs-string">&quot;Privileged&quot;</span>: <span class="hljs-literal">false</span>,            <span class="hljs-string">&quot;PublishAllPorts&quot;</span>: <span class="hljs-literal">false</span>,            <span class="hljs-string">&quot;ReadonlyRootfs&quot;</span>: <span class="hljs-literal">false</span>,            <span class="hljs-string">&quot;SecurityOpt&quot;</span>: <span class="hljs-literal">null</span>,            <span class="hljs-string">&quot;UTSMode&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,            <span class="hljs-string">&quot;UsernsMode&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,            <span class="hljs-string">&quot;ShmSize&quot;</span>: <span class="hljs-number">67108864</span>,            <span class="hljs-string">&quot;Runtime&quot;</span>: <span class="hljs-string">&quot;runc&quot;</span>,            <span class="hljs-string">&quot;ConsoleSize&quot;</span>: [                <span class="hljs-number">0</span>,                <span class="hljs-number">0</span>            ],            <span class="hljs-string">&quot;Isolation&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,            <span class="hljs-string">&quot;CpuShares&quot;</span>: <span class="hljs-number">0</span>,            <span class="hljs-string">&quot;Memory&quot;</span>: <span class="hljs-number">0</span>,            <span class="hljs-string">&quot;NanoCpus&quot;</span>: <span class="hljs-number">0</span>,            <span class="hljs-string">&quot;CgroupParent&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,            <span class="hljs-string">&quot;BlkioWeight&quot;</span>: <span class="hljs-number">0</span>,            <span class="hljs-string">&quot;BlkioWeightDevice&quot;</span>: [],            <span class="hljs-string">&quot;BlkioDeviceReadBps&quot;</span>: <span class="hljs-literal">null</span>,            <span class="hljs-string">&quot;BlkioDeviceWriteBps&quot;</span>: <span class="hljs-literal">null</span>,            <span class="hljs-string">&quot;BlkioDeviceReadIOps&quot;</span>: <span class="hljs-literal">null</span>,            <span class="hljs-string">&quot;BlkioDeviceWriteIOps&quot;</span>: <span class="hljs-literal">null</span>,            <span class="hljs-string">&quot;CpuPeriod&quot;</span>: <span class="hljs-number">0</span>,            <span class="hljs-string">&quot;CpuQuota&quot;</span>: <span class="hljs-number">0</span>,            <span class="hljs-string">&quot;CpuRealtimePeriod&quot;</span>: <span class="hljs-number">0</span>,            <span class="hljs-string">&quot;CpuRealtimeRuntime&quot;</span>: <span class="hljs-number">0</span>,            <span class="hljs-string">&quot;CpusetCpus&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,            <span class="hljs-string">&quot;CpusetMems&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,            <span class="hljs-string">&quot;Devices&quot;</span>: [],            <span class="hljs-string">&quot;DeviceCgroupRules&quot;</span>: <span class="hljs-literal">null</span>,            <span class="hljs-string">&quot;DeviceRequests&quot;</span>: <span class="hljs-literal">null</span>,            <span class="hljs-string">&quot;KernelMemory&quot;</span>: <span class="hljs-number">0</span>,            <span class="hljs-string">&quot;KernelMemoryTCP&quot;</span>: <span class="hljs-number">0</span>,            <span class="hljs-string">&quot;MemoryReservation&quot;</span>: <span class="hljs-number">0</span>,            <span class="hljs-string">&quot;MemorySwap&quot;</span>: <span class="hljs-number">0</span>,            <span class="hljs-string">&quot;MemorySwappiness&quot;</span>: <span class="hljs-literal">null</span>,            <span class="hljs-string">&quot;OomKillDisable&quot;</span>: <span class="hljs-literal">false</span>,            <span class="hljs-string">&quot;PidsLimit&quot;</span>: <span class="hljs-literal">null</span>,            <span class="hljs-string">&quot;Ulimits&quot;</span>: <span class="hljs-literal">null</span>,            <span class="hljs-string">&quot;CpuCount&quot;</span>: <span class="hljs-number">0</span>,            <span class="hljs-string">&quot;CpuPercent&quot;</span>: <span class="hljs-number">0</span>,            <span class="hljs-string">&quot;IOMaximumIOps&quot;</span>: <span class="hljs-number">0</span>,            <span class="hljs-string">&quot;IOMaximumBandwidth&quot;</span>: <span class="hljs-number">0</span>,            <span class="hljs-string">&quot;MaskedPaths&quot;</span>: [                <span class="hljs-string">&quot;/proc/asound&quot;</span>,                <span class="hljs-string">&quot;/proc/acpi&quot;</span>,                <span class="hljs-string">&quot;/proc/kcore&quot;</span>,                <span class="hljs-string">&quot;/proc/keys&quot;</span>,                <span class="hljs-string">&quot;/proc/latency_stats&quot;</span>,                <span class="hljs-string">&quot;/proc/timer_list&quot;</span>,                <span class="hljs-string">&quot;/proc/timer_stats&quot;</span>,                <span class="hljs-string">&quot;/proc/sched_debug&quot;</span>,                <span class="hljs-string">&quot;/proc/scsi&quot;</span>,                <span class="hljs-string">&quot;/sys/firmware&quot;</span>            ],            <span class="hljs-string">&quot;ReadonlyPaths&quot;</span>: [                <span class="hljs-string">&quot;/proc/bus&quot;</span>,                <span class="hljs-string">&quot;/proc/fs&quot;</span>,                <span class="hljs-string">&quot;/proc/irq&quot;</span>,                <span class="hljs-string">&quot;/proc/sys&quot;</span>,                <span class="hljs-string">&quot;/proc/sysrq-trigger&quot;</span>            ]        &#125;,        <span class="hljs-string">&quot;GraphDriver&quot;</span>: &#123;            <span class="hljs-string">&quot;Data&quot;</span>: &#123;                <span class="hljs-string">&quot;LowerDir&quot;</span>: <span class="hljs-string">&quot;/var/lib/docker/overlay2/4498c608a3e6193a4996a1b12695d57df26404240df5401efc246539cdb12bac-init/diff:/var/lib/docker/overlay2/503aefb56de70e6b2b9b20df1dd037818d2f6959f4ab6b7d6d6e80e7fe877e2e/diff&quot;</span>,                <span class="hljs-string">&quot;MergedDir&quot;</span>: <span class="hljs-string">&quot;/var/lib/docker/overlay2/4498c608a3e6193a4996a1b12695d57df26404240df5401efc246539cdb12bac/merged&quot;</span>,                <span class="hljs-string">&quot;UpperDir&quot;</span>: <span class="hljs-string">&quot;/var/lib/docker/overlay2/4498c608a3e6193a4996a1b12695d57df26404240df5401efc246539cdb12bac/diff&quot;</span>,                <span class="hljs-string">&quot;WorkDir&quot;</span>: <span class="hljs-string">&quot;/var/lib/docker/overlay2/4498c608a3e6193a4996a1b12695d57df26404240df5401efc246539cdb12bac/work&quot;</span>            &#125;,            <span class="hljs-string">&quot;Name&quot;</span>: <span class="hljs-string">&quot;overlay2&quot;</span>        &#125;,        <span class="hljs-string">&quot;SizeRw&quot;</span>: <span class="hljs-number">0</span>,        <span class="hljs-string">&quot;SizeRootFs&quot;</span>: <span class="hljs-number">231268856</span>,        <span class="hljs-string">&quot;Mounts&quot;</span>: [],        <span class="hljs-string">&quot;Config&quot;</span>: &#123;            <span class="hljs-string">&quot;Hostname&quot;</span>: <span class="hljs-string">&quot;b4f5ff60ef4a&quot;</span>,            <span class="hljs-string">&quot;Domainname&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,            <span class="hljs-string">&quot;User&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,            <span class="hljs-string">&quot;AttachStdin&quot;</span>: <span class="hljs-literal">true</span>,            <span class="hljs-string">&quot;AttachStdout&quot;</span>: <span class="hljs-literal">true</span>,            <span class="hljs-string">&quot;AttachStderr&quot;</span>: <span class="hljs-literal">true</span>,            <span class="hljs-string">&quot;Tty&quot;</span>: <span class="hljs-literal">true</span>,            <span class="hljs-string">&quot;OpenStdin&quot;</span>: <span class="hljs-literal">true</span>,            <span class="hljs-string">&quot;StdinOnce&quot;</span>: <span class="hljs-literal">true</span>,            <span class="hljs-string">&quot;Env&quot;</span>: [                <span class="hljs-string">&quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;</span>            ],            <span class="hljs-string">&quot;Cmd&quot;</span>: [                <span class="hljs-string">&quot;/bin/bash&quot;</span>            ],            <span class="hljs-string">&quot;Image&quot;</span>: <span class="hljs-string">&quot;centos&quot;</span>,            <span class="hljs-string">&quot;Volumes&quot;</span>: <span class="hljs-literal">null</span>,            <span class="hljs-string">&quot;WorkingDir&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,            <span class="hljs-string">&quot;Entrypoint&quot;</span>: <span class="hljs-literal">null</span>,            <span class="hljs-string">&quot;OnBuild&quot;</span>: <span class="hljs-literal">null</span>,            <span class="hljs-string">&quot;Labels&quot;</span>: &#123;                <span class="hljs-string">&quot;org.label-schema.build-date&quot;</span>: <span class="hljs-string">&quot;20210915&quot;</span>,                <span class="hljs-string">&quot;org.label-schema.license&quot;</span>: <span class="hljs-string">&quot;GPLv2&quot;</span>,                <span class="hljs-string">&quot;org.label-schema.name&quot;</span>: <span class="hljs-string">&quot;CentOS Base Image&quot;</span>,                <span class="hljs-string">&quot;org.label-schema.schema-version&quot;</span>: <span class="hljs-string">&quot;1.0&quot;</span>,                <span class="hljs-string">&quot;org.label-schema.vendor&quot;</span>: <span class="hljs-string">&quot;CentOS&quot;</span>            &#125;        &#125;,        <span class="hljs-string">&quot;NetworkSettings&quot;</span>: &#123;            <span class="hljs-string">&quot;Bridge&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,            <span class="hljs-string">&quot;SandboxID&quot;</span>: <span class="hljs-string">&quot;f9ae31473be3e2c21b44e903369feec8a35eeff1512890051c9cce637d6752fe&quot;</span>,            <span class="hljs-string">&quot;HairpinMode&quot;</span>: <span class="hljs-literal">false</span>,            <span class="hljs-string">&quot;LinkLocalIPv6Address&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,            <span class="hljs-string">&quot;LinkLocalIPv6PrefixLen&quot;</span>: <span class="hljs-number">0</span>,            <span class="hljs-string">&quot;Ports&quot;</span>: &#123;&#125;,            <span class="hljs-string">&quot;SandboxKey&quot;</span>: <span class="hljs-string">&quot;/var/run/docker/netns/f9ae31473be3&quot;</span>,            <span class="hljs-string">&quot;SecondaryIPAddresses&quot;</span>: <span class="hljs-literal">null</span>,            <span class="hljs-string">&quot;SecondaryIPv6Addresses&quot;</span>: <span class="hljs-literal">null</span>,            <span class="hljs-string">&quot;EndpointID&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,            <span class="hljs-string">&quot;Gateway&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,            <span class="hljs-string">&quot;GlobalIPv6Address&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,            <span class="hljs-string">&quot;GlobalIPv6PrefixLen&quot;</span>: <span class="hljs-number">0</span>,            <span class="hljs-string">&quot;IPAddress&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,            <span class="hljs-string">&quot;IPPrefixLen&quot;</span>: <span class="hljs-number">0</span>,            <span class="hljs-string">&quot;IPv6Gateway&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,            <span class="hljs-string">&quot;MacAddress&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,            <span class="hljs-string">&quot;Networks&quot;</span>: &#123;                <span class="hljs-string">&quot;bridge&quot;</span>: &#123;                    <span class="hljs-string">&quot;IPAMConfig&quot;</span>: <span class="hljs-literal">null</span>,                    <span class="hljs-string">&quot;Links&quot;</span>: <span class="hljs-literal">null</span>,                    <span class="hljs-string">&quot;Aliases&quot;</span>: <span class="hljs-literal">null</span>,                    <span class="hljs-string">&quot;NetworkID&quot;</span>: <span class="hljs-string">&quot;cde6e70f65eb81bfcc2d15eeef56a70d9f0ee51b43817c15c200c48aec8bceb4&quot;</span>,                    <span class="hljs-string">&quot;EndpointID&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,                    <span class="hljs-string">&quot;Gateway&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,                    <span class="hljs-string">&quot;IPAddress&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,                    <span class="hljs-string">&quot;IPPrefixLen&quot;</span>: <span class="hljs-number">0</span>,                    <span class="hljs-string">&quot;IPv6Gateway&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,                    <span class="hljs-string">&quot;GlobalIPv6Address&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,                    <span class="hljs-string">&quot;GlobalIPv6PrefixLen&quot;</span>: <span class="hljs-number">0</span>,                    <span class="hljs-string">&quot;MacAddress&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,                    <span class="hljs-string">&quot;DriverOpts&quot;</span>: <span class="hljs-literal">null</span>                &#125;            &#125;        &#125;    &#125;]</code></pre><h4 id="5-进入当前正在运行的容器"><a href="#5-进入当前正在运行的容器" class="headerlink" title="5. 进入当前正在运行的容器"></a>5. 进入当前正在运行的容器</h4><p>通常容器都是使用后台方式运行的，如需要进入容器，修改一些配置可以以下几种方式</p><p><strong>方式一：<code>docker exec -it 容器id</code></strong></p><p><strong>方式二：<code>docker attach 容器id</code></strong></p><p>区别：</p><ul><li>  docker exec 进入容器后会开启一个新的终端，可以在里面操(常用)</li><li>  docker attach 进入容器正在执行的终端，不会启动新的进程</li></ul><h4 id="6-从容器中拷贝文件到本地"><a href="#6-从容器中拷贝文件到本地" class="headerlink" title="6. 从容器中拷贝文件到本地"></a>6. 从容器中拷贝文件到本地</h4><pre><code class="hljs bash">docker <span class="hljs-built_in">cp</span> 容器<span class="hljs-built_in">id</span>:path 本地path</code></pre><pre><code class="hljs awk"><span class="hljs-comment"># 测试</span>[root@wangpf home]<span class="hljs-comment"># docker ps</span>CONTAINER ID   IMAGE     COMMAND       CREATED             STATUS          PORTS     NAMESb4f5ff60ef4a   centos    <span class="hljs-string">&quot;/bin/bash&quot;</span>   About an hour ago   Up <span class="hljs-number">13</span> minutes             amazing_gagarin[root@wangpf home]<span class="hljs-comment"># docker exec -it b4f5ff60ef4a /bin/bash</span>[root@b4f5ff60ef4a <span class="hljs-regexp">/]# touch /</span>home/text.html[root@b4f5ff60ef4a <span class="hljs-regexp">/]# cd /</span>home/[root@b4f5ff60ef4a home]<span class="hljs-comment"># ls</span>text.html[root@b4f5ff60ef4a home]<span class="hljs-comment"># exit</span><span class="hljs-keyword">exit</span>[root@wangpf home]<span class="hljs-comment"># docker cp b4f5ff60ef4a:/home/text.html .</span>[root@wangpf home]<span class="hljs-comment"># ls</span>text.html</code></pre><h2 id="docker-镜像"><a href="#docker-镜像" class="headerlink" title="docker 镜像"></a>docker 镜像</h2><h3 id="commit-镜像"><a href="#commit-镜像" class="headerlink" title="commit 镜像"></a>commit 镜像</h3><blockquote><p>由于从官方下载的一些镜像，有些不满足我们的需求，我们需要在该镜像上添加一些常用功能。这时我们就可以提交一个镜像，以后使用我们提交的这个镜像使得效率大大提高，要不然每次都需要在官方默认的镜像中添加我们常用的功能就很麻烦</p></blockquote><pre><code class="hljs routeros">docker commit 提交容器成功一个镜像<span class="hljs-comment"># 命令和git类似</span>docker commit <span class="hljs-attribute">-m</span>=<span class="hljs-string">&#x27;提交的信息&#x27;</span> <span class="hljs-attribute">-a</span>=<span class="hljs-string">&#x27;作者名&#x27;</span> 容器id 目标镜像名</code></pre><p><strong>实战测试tomcat</strong></p><p>步骤：</p><ol start="0"><li> 启动一个默认的tomcat</li><li> 发现这个默认的tomcat 是没有webapps应用，这是镜像的原因，官方的镜像默认 webapps 下是没有文件的</li><li> 拷贝基本的文件到webapps目录</li><li> 最后我们将操作过的容器通过commit提交为一个镜像，之后我们就使用提交过的镜像即可</li></ol><h2 id="数据卷-volumes"><a href="#数据卷-volumes" class="headerlink" title="数据卷 (volumes)"></a>数据卷 (<strong>volumes</strong>)</h2><p>使用数据集实现容器的持久化和同步操作（容器间也可以实现数据共享）</p><p><a href="https://docs.docker.com/get-started/05_persisting_data/">Docker vloumes 描述</a></p><p><a href="https://docs.docker.com/storage/volumes/">Use volumes | Docker Documentation</a></p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><pre><code class="hljs stata">➜  /wangpf docker volume --<span class="hljs-keyword">help</span> Usage:  docker volume COMMANDManage volumesCommands:  create      Create a volume  <span class="hljs-keyword">inspect</span>     <span class="hljs-keyword">Display</span> detailed information <span class="hljs-keyword">on</span> <span class="hljs-keyword">one</span> or <span class="hljs-keyword">more</span> volumes  <span class="hljs-keyword">ls</span>          <span class="hljs-keyword">List</span> volumes  prune       Remove all unused <span class="hljs-keyword">local</span> volumes  <span class="hljs-keyword">rm</span>          Remove <span class="hljs-keyword">one</span> or <span class="hljs-keyword">more</span> volumes<span class="hljs-keyword">Run</span> &#x27;docker volume COMMAND --<span class="hljs-keyword">help</span>&#x27; <span class="hljs-keyword">for</span> <span class="hljs-keyword">more</span> information <span class="hljs-keyword">on</span> a command.</code></pre><h3 id="使用数据卷"><a href="#使用数据卷" class="headerlink" title="使用数据卷"></a>使用数据卷</h3><blockquote><p>方式一： 直接使用命令来挂载 -v （和 -p 一样， -v 主机目录:容器内目录）</p></blockquote><p><strong>数据同步:</strong></p><pre><code class="hljs awk">docker run -it -v <span class="hljs-regexp">/wangpf/</span>test:<span class="hljs-regexp">/home centos /</span>bin/bash test docker inspect f5df5f         <span class="hljs-string">&quot;Mounts&quot;</span>: [            &#123;                <span class="hljs-string">&quot;Type&quot;</span>: <span class="hljs-string">&quot;bind&quot;</span>,                          <span class="hljs-string">&quot;Source&quot;</span>: <span class="hljs-string">&quot;/wangpf/test&quot;</span>,  <span class="hljs-regexp">//</span> 主机目录                <span class="hljs-string">&quot;Destination&quot;</span>: <span class="hljs-string">&quot;/home&quot;</span>,   <span class="hljs-regexp">//</span>  容器目录                <span class="hljs-string">&quot;Mode&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,                <span class="hljs-string">&quot;RW&quot;</span>: true,                <span class="hljs-string">&quot;Propagation&quot;</span>: <span class="hljs-string">&quot;rprivate&quot;</span>            &#125;        ],        <span class="hljs-comment"># 使用数据卷技术，不管是修改主机还是容器内的目录的文件，相对的一方都会发生改变，实现了同步操作（即双向绑定）</span></code></pre><p>当容器已经和本地映射后，当关掉容器后，即使在本地目录修改文件内容，再次启动容器时，依旧会同步</p><p>" srcset="/img/loading.gif<img src="" alt="image-20211221183213087"></p><p><strong>数据持久化：</strong> 即使把容器给删掉了，本地的文件依旧会有</p><h3 id="具名挂载和匿名挂载"><a href="#具名挂载和匿名挂载" class="headerlink" title="具名挂载和匿名挂载"></a>具名挂载和匿名挂载</h3><h4 id="匿名挂载"><a href="#匿名挂载" class="headerlink" title="匿名挂载"></a>匿名挂载</h4><pre><code class="hljs dockerfile"><span class="hljs-comment"># -v 容器内路径 (以 nginx 举例, 只写容器内的路径，不写容器外的路径)</span>docker <span class="hljs-keyword">run</span><span class="language-bash"> -d -P --name nginx-demo1 -v /etc/nginx nginx </span><span class="hljs-comment"># 匿名挂载时 默认存放位置</span>➜  /wangpf docker <span class="hljs-keyword">volume</span><span class="language-bash"> <span class="hljs-built_in">ls</span>    （c查看所有 volume 情况）</span>DRIVER    <span class="hljs-keyword">VOLUME</span><span class="language-bash"> NAME</span>local     <span class="hljs-number">141</span>cad1da9e2c26a3f2ba4ada3ce1f84ccdbd5d0b9e13b753a4e13a947d5e17b➜  /wangpf docker <span class="hljs-keyword">volume</span><span class="language-bash"> inspect 141cad1da9e2c26a3f2ba4ada3ce1f84ccdbd5d0b9e13b753a4e13a947d5e17b  （查看该卷的详细信息） </span>[    &#123;        <span class="hljs-string">&quot;CreatedAt&quot;</span>: <span class="hljs-string">&quot;2021-12-26T16:50:09+08:00&quot;</span>,        <span class="hljs-string">&quot;Driver&quot;</span>: <span class="hljs-string">&quot;local&quot;</span>,        <span class="hljs-string">&quot;Labels&quot;</span>: null,        <span class="hljs-string">&quot;Mountpoint&quot;</span>: <span class="hljs-string">&quot;/var/lib/docker/volumes/141cad1da9e2c26a3f2ba4ada3ce1f84ccdbd5d0b9e13b753a4e13a947d5e17b/_data&quot;</span>,        <span class="hljs-string">&quot;Name&quot;</span>: <span class="hljs-string">&quot;141cad1da9e2c26a3f2ba4ada3ce1f84ccdbd5d0b9e13b753a4e13a947d5e17b&quot;</span>,        <span class="hljs-string">&quot;Options&quot;</span>: null,        <span class="hljs-string">&quot;Scope&quot;</span>: <span class="hljs-string">&quot;local&quot;</span>    &#125;]<span class="hljs-comment"># 默认存放地址：  &quot;/var/lib/docker/volumes/141cad1da9e2c26a3f2ba4ada3ce1f84ccdbd5d0b9e13b753a4e13a947d5e17b/_data&quot;,</span></code></pre><h4 id="具名挂载"><a href="#具名挂载" class="headerlink" title="具名挂载"></a>具名挂载</h4><pre><code class="hljs bash"><span class="hljs-comment"># -v 名字：容器内名字 （注意 具名时不能用 / ，要不会被认为是绝对路径）</span>➜  /wangpf docker run -d -P --name nginx-demo3 -v juming-nginx:/etc/nginx nginx 9c0f1222328b25c5e58160d08627bca437dca99ee58ae90b53533b72a9e71686➜  /wangpf docker volume <span class="hljs-built_in">ls</span>                                                     DRIVER    VOLUME NAME<span class="hljs-built_in">local</span>     141cad1da9e2c26a3f2ba4ada3ce1f84ccdbd5d0b9e13b753a4e13a947d5e17b<span class="hljs-built_in">local</span>     juming-nginx➜  /wangpf docker volume inspect juming-nginx                                                               [    &#123;        <span class="hljs-string">&quot;CreatedAt&quot;</span>: <span class="hljs-string">&quot;2021-12-26T16:58:49+08:00&quot;</span>,        <span class="hljs-string">&quot;Driver&quot;</span>: <span class="hljs-string">&quot;local&quot;</span>,        <span class="hljs-string">&quot;Labels&quot;</span>: null,        <span class="hljs-string">&quot;Mountpoint&quot;</span>: <span class="hljs-string">&quot;/var/lib/docker/volumes/juming-nginx/_data&quot;</span>,        <span class="hljs-string">&quot;Name&quot;</span>: <span class="hljs-string">&quot;juming-nginx&quot;</span>,        <span class="hljs-string">&quot;Options&quot;</span>: null,        <span class="hljs-string">&quot;Scope&quot;</span>: <span class="hljs-string">&quot;local&quot;</span>    &#125;]<span class="hljs-comment"># 存放地址：  &quot;/var/lib/docker/volumes/juming-nginx/_data&quot;,</span></code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>所有的docker容器内的数据卷，没有指定目的情况下都是默认在 <code>/var/lib/docker/volumes/[匿名随机名/具名名字]/_data&quot;</code> 下的</p><p>我们通过具名可以方便的找到我们的卷，大多数情况使用的是<code>具名挂载</code></p><pre><code class="hljs clean">-v 容器内路径             ## 匿名挂载-v 卷名:容器内路径        ## 具名挂载  （注意: 不要带 / ）-v /宿主机路径:容器内路径  ## 指定路径挂载</code></pre><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><pre><code class="hljs bash">通过 -v 容器内路径:[ro/rw] 来改变读写权限 , 默认为 rw</code></pre><p>如下面俩条命令</p><pre><code class="hljs applescript">docker <span class="hljs-built_in">run</span> -d -P <span class="hljs-comment">--name nginx-demo3 -v juming-nginx:/etc/nginx:ro nginx </span>docker <span class="hljs-built_in">run</span> -d -P <span class="hljs-comment">--name nginx-demo3 -v juming-nginx:/etc/nginx:rw nginx </span></code></pre><p>区别在与 <code>ro</code> 和 <code>rw</code></p><p>顾名思义：</p><ul><li>  <code>ro</code> 即 <code>read only</code> 只读</li><li>  <code>rw</code> 即 <code>read write</code> 可读写</li></ul><h3 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h3><p>先略过</p><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><blockquote><p>dockerfile 用来构建 docker镜像的构建文件 命令参数脚本</p></blockquote><p>构建步骤:</p><ol start="0"><li> 编写 dockerfile 文件</li><li> docker build 构建为一个镜像</li><li> docker run 运行镜像</li><li> docker push 发布镜像 (Docker Hub 、 阿里云镜像仓库等等)</li></ol><h3 id="Dockerfile-构建过程"><a href="#Dockerfile-构建过程" class="headerlink" title="Dockerfile 构建过程"></a>Dockerfile 构建过程</h3><p>基础知识：</p><ol start="0"><li> 每个保留关键字(指令)都必须是大写字母</li><li> 从上到下顺序执行</li><li> <code>#</code> 表示注释</li><li> 每一个指令都创建提交一个新的镜像层，并提交</li></ol><h3 id="Dockerfile-常用命令"><a href="#Dockerfile-常用命令" class="headerlink" title="Dockerfile 常用命令"></a>Dockerfile 常用命令</h3><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/11ab92915bc94e52aac63bf7e2dce357~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="image.png"></p><pre><code class="hljs dockerfile">FORM            <span class="hljs-comment"># 基础镜像，一切从这里开始构建</span><span class="hljs-keyword">MAINTAINER</span>      <span class="hljs-comment"># 描述该镜像是谁写的， 姓名+邮箱 (已弃用)</span><span class="hljs-keyword">LABEL</span><span class="language-bash">           <span class="hljs-comment"># 介绍该镜像</span></span><span class="hljs-keyword">RUN</span><span class="language-bash">             <span class="hljs-comment"># 镜像构建时候需要运行的命令</span></span><span class="hljs-keyword">ADD</span><span class="language-bash">             <span class="hljs-comment"># 步骤 如: 添加tomcat镜像， 添加内容</span></span><span class="hljs-keyword">WORKDIR</span><span class="language-bash">         <span class="hljs-comment"># 镜像的工作目录</span></span><span class="hljs-keyword">VOLUME</span><span class="language-bash">          <span class="hljs-comment"># 挂载的目录</span></span><span class="hljs-keyword">EXPOSE</span>          <span class="hljs-comment"># 暴露端口  类似与 -p</span><span class="hljs-keyword">CMD</span><span class="language-bash">             <span class="hljs-comment"># 指定这个容器启动时候需要运行的命令，</span></span><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash">      <span class="hljs-comment"># 同上， 和上者有区别。会在下文说到</span></span><span class="hljs-keyword">ONBUILD</span>         <span class="hljs-comment"># 当构建一个被继承 dockerfile， 这个时候会运行 ONBUILD 的指令， 触发指令</span><span class="hljs-keyword">COPY</span><span class="language-bash">            <span class="hljs-comment"># 类似ADD ， 将文件拷贝到镜像中</span></span><span class="hljs-keyword">ENV</span>             <span class="hljs-comment"># 设置环境变量  如：设置mysql的用户名密码...</span></code></pre><p>测试：</p><p>创建一个简单的centos加强版， 默认镜像里是没有 vim ifconfig 等命令的</p><pre><code class="hljs dockerfile"><span class="hljs-comment"># 1. 编写 dockerfile 文件</span>➜  dockerfile-demo cat dockerfile-centos-test <span class="hljs-keyword">FROM</span> centos<span class="hljs-keyword">LABEL</span><span class="language-bash"> version=<span class="hljs-string">&quot;1.0&quot;</span></span><span class="hljs-keyword">LABEL</span><span class="language-bash"> description=<span class="hljs-string">&quot;This test demo&quot;</span></span><span class="hljs-keyword">ENV</span> PATH /usr/local<span class="hljs-keyword">WORKDIR</span><span class="language-bash"> <span class="hljs-variable">$PATH</span></span><span class="hljs-keyword">RUN</span><span class="language-bash"> yum -y install vim</span><span class="hljs-keyword">RUN</span><span class="language-bash"> yum -y install net-tools</span><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">3333</span><span class="hljs-keyword">CMD</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-variable">$PATH</span></span><span class="hljs-keyword">CMD</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;-----end-------&#x27;</span></span><span class="hljs-keyword">CMD</span><span class="language-bash"> /bin/bash</span><span class="hljs-comment"># 2 通过这个文件构建镜像</span><span class="hljs-comment"># 命令 docker builf -f dockerfile-centos-test -t centos-test01:1.0 .</span></code></pre><h3 id="CMD-和-ENTRYPOINT-的区别"><a href="#CMD-和-ENTRYPOINT-的区别" class="headerlink" title="CMD 和 ENTRYPOINT 的区别"></a>CMD 和 ENTRYPOINT 的区别</h3><blockquote><p>CMD # 制定这个容器启动的时候运行的命令，只有最后一个会生效，可被替代 ENTRYPOINT # 指定这个容器启动的时候要运行的命令，可以追加命令</p></blockquote><h4 id="测试-CMD"><a href="#测试-CMD" class="headerlink" title="测试 CMD"></a>测试 CMD</h4><pre><code class="hljs tcl"><span class="hljs-comment"># 编写dockerfile文件</span>➜  dockerfile-demo cat dockerfile-cmd-test                FROM centosCMD [<span class="hljs-string">&quot;ls&quot;</span>,<span class="hljs-string">&quot;-a&quot;</span>]<span class="hljs-comment"># 构建写的镜像</span>➜  dockerfile-demo docker build -f dockerfile-cmd-test -t test-cmd .           Sending build context to Docker daemon  <span class="hljs-number">4.096</span>kBStep <span class="hljs-number">1</span>/<span class="hljs-number">2</span> : FROM centos ---&gt; <span class="hljs-number">5</span>d0da3dc9764Step <span class="hljs-number">2</span>/<span class="hljs-number">2</span> : CMD [<span class="hljs-string">&quot;ls&quot;</span>,<span class="hljs-string">&quot;-a&quot;</span>] ---&gt; Running in c90cf1ce0209Removing intermediate container c90cf1ce0209 ---&gt; f5e299a19206Successfully built f5e299a19206Successfully tagged test-cmd:latest<span class="hljs-comment"># 运行刚刚写的镜像生产的容器</span>➜  dockerfile-demo docker run -it f5e299a19206           .   .dockerenv  dev  home  lib64       media  opt   root  sbin  sys  usr..  bin         etc  lib   lost+found  mnt    <span class="hljs-keyword">proc</span><span class="hljs-title">  run</span> <span class="hljs-title">  srv</span> <span class="hljs-title">  tmp</span> <span class="hljs-title"> var</span># 但如果想在后边追加命令就会报错  （-l 想变成<span class="hljs-title"> ls</span> -al 不行！）➜<span class="hljs-title">  dockerfile-demo</span> docker<span class="hljs-title"> run</span> -it<span class="hljs-title"> f5e299a19206</span> -l<span class="hljs-title"></span><span class="hljs-title">docker:</span> Error<span class="hljs-title"> response</span> from<span class="hljs-title"> daemon:</span> OCI<span class="hljs-title"> runtime</span> create<span class="hljs-title"> failed:</span> container_linux.go:380:<span class="hljs-title"> starting</span> container<span class="hljs-title"> process</span> caused:<span class="hljs-title"> exec:</span> &quot;-l&quot;:<span class="hljs-title"> executable</span> file<span class="hljs-title"> not</span> found<span class="hljs-title"> in</span> $PATH:<span class="hljs-title"> unknown.</span>ERRO[0000]<span class="hljs-title"> error</span> waiting<span class="hljs-title"> for</span> container:<span class="hljs-title"> context</span> canceled # 原因在于由于使用的<span class="hljs-title"> CMD</span> <span class="hljs-title">  CMD</span> [&quot;ls&quot;,&quot;-a&quot;] 命令 被替换成了 -l ， 而 -l 不是命令所以报错</code></pre><h4 id="测试-ENTRYPOINT"><a href="#测试-ENTRYPOINT" class="headerlink" title="测试 ENTRYPOINT"></a>测试 ENTRYPOINT</h4><pre><code class="hljs tcl"><span class="hljs-comment"># 编写dockerfile文件</span>➜  dockerfile-demo cat dockerfile-entrypoint-test  FROM centosENTRYPOINT [<span class="hljs-string">&quot;ls&quot;</span>,<span class="hljs-string">&quot;-a&quot;</span>]<span class="hljs-comment"># 构建镜像</span>➜  dockerfile-demo docker build -f dockerfile-entrypoint-test -t entrypoint-test . Sending build context to Docker daemon   <span class="hljs-number">5.12</span>kBStep <span class="hljs-number">1</span>/<span class="hljs-number">2</span> : FROM centos ---&gt; <span class="hljs-number">5</span>d0da3dc9764Step <span class="hljs-number">2</span>/<span class="hljs-number">2</span> : ENTRYPOINT [<span class="hljs-string">&quot;ls&quot;</span>,<span class="hljs-string">&quot;-a&quot;</span>] ---&gt; Running in <span class="hljs-number">3085</span>bdc9deb8Removing intermediate container <span class="hljs-number">3085</span>bdc9deb8 ---&gt; <span class="hljs-number">4</span>b4e041eb4daSuccessfully built <span class="hljs-number">4</span>b4e041eb4daSuccessfully tagged entrypoint-test:latest<span class="hljs-comment"># 运行容器</span>➜  dockerfile-demo docker run -it <span class="hljs-number">4</span>b4e041eb4da                                      .   .dockerenv  dev  home  lib64       media  opt   root  sbin  sys  usr..  bin         etc  lib   lost+found  mnt    <span class="hljs-keyword">proc</span><span class="hljs-title">  run</span> <span class="hljs-title">  srv</span> <span class="hljs-title">  tmp</span> <span class="hljs-title"> var</span># 追加命令➜<span class="hljs-title">  dockerfile-demo</span> docker<span class="hljs-title"> run</span> -it 4b4e041eb4da -l<span class="hljs-title"></span><span class="hljs-title">total</span> 56<span class="hljs-title"></span><span class="hljs-title">drwxr-xr-x</span>   1<span class="hljs-title"> root</span> root 4096<span class="hljs-title"> Dec</span> 28 10:39 .<span class="hljs-title"></span><span class="hljs-title">drwxr-xr-x</span>   1<span class="hljs-title"> root</span> root 4096<span class="hljs-title"> Dec</span> 28 10:39 ..-rwxr-xr-x   1<span class="hljs-title"> root</span> root    0<span class="hljs-title"> Dec</span> 28 10:39 .dockerenv<span class="hljs-title"></span><span class="hljs-title">lrwxrwxrwx</span>   1<span class="hljs-title"> root</span> root    7<span class="hljs-title"> Nov</span>  3  2020<span class="hljs-title"> bin</span> -&gt;<span class="hljs-title"> usr/bin</span>drwxr-xr-x   5<span class="hljs-title"> root</span> root  360<span class="hljs-title"> Dec</span> 28 10:39<span class="hljs-title"> dev</span>drwxr-xr-x   1<span class="hljs-title"> root</span> root 4096<span class="hljs-title"> Dec</span> 28 10:39<span class="hljs-title"> etc</span>drwxr-xr-x   2<span class="hljs-title"> root</span> root 4096<span class="hljs-title"> Nov</span>  3  2020<span class="hljs-title"> home</span>lrwxrwxrwx   1<span class="hljs-title"> root</span> root    7<span class="hljs-title"> Nov</span>  3  2020<span class="hljs-title"> lib</span> -&gt;<span class="hljs-title"> usr/lib</span>lrwxrwxrwx   1<span class="hljs-title"> root</span> root    9<span class="hljs-title"> Nov</span>  3  2020<span class="hljs-title"> lib64</span> -&gt;<span class="hljs-title"> usr/lib64</span>drwx------   2<span class="hljs-title"> root</span> root 4096<span class="hljs-title"> Sep</span> 15 14:17<span class="hljs-title"> lost+found</span>drwxr-xr-x   2<span class="hljs-title"> root</span> root 4096<span class="hljs-title"> Nov</span>  3  2020<span class="hljs-title"> media</span>drwxr-xr-x   2<span class="hljs-title"> root</span> root 4096<span class="hljs-title"> Nov</span>  3  2020<span class="hljs-title"> mnt</span>drwxr-xr-x   2<span class="hljs-title"> root</span> root 4096<span class="hljs-title"> Nov</span>  3  2020<span class="hljs-title"> opt</span>dr-xr-xr-x 131<span class="hljs-title"> root</span> root    0<span class="hljs-title"> Dec</span> 28 10:39<span class="hljs-title"> proc</span>dr-xr-x---   2<span class="hljs-title"> root</span> root 4096<span class="hljs-title"> Sep</span> 15 14:17<span class="hljs-title"> root</span>drwxr-xr-x  11<span class="hljs-title"> root</span> root 4096<span class="hljs-title"> Sep</span> 15 14:17<span class="hljs-title"> run</span>lrwxrwxrwx   1<span class="hljs-title"> root</span> root    8<span class="hljs-title"> Nov</span>  3  2020<span class="hljs-title"> sbin</span> -&gt;<span class="hljs-title"> usr/sbin</span>drwxr-xr-x   2<span class="hljs-title"> root</span> root 4096<span class="hljs-title"> Nov</span>  3  2020<span class="hljs-title"> srv</span>dr-xr-xr-x  13<span class="hljs-title"> root</span> root    0<span class="hljs-title"> Dec</span> 28 10:39<span class="hljs-title"> sys</span>drwxrwxrwt   7<span class="hljs-title"> root</span> root 4096<span class="hljs-title"> Sep</span> 15 14:17<span class="hljs-title"> tmp</span>drwxr-xr-x  12<span class="hljs-title"> root</span> root 4096<span class="hljs-title"> Sep</span> 15 14:17<span class="hljs-title"> usr</span>drwxr-xr-x  20<span class="hljs-title"> root</span> root 4096<span class="hljs-title"> Sep</span> 15 14:17<span class="hljs-title"> var</span># 发现<span class="hljs-title"> entrypoint</span> 是可以追加命令的</code></pre><h2 id="Docker-网络"><a href="#Docker-网络" class="headerlink" title="Docker 网络"></a>Docker 网络</h2><pre><code class="hljs pf">➜  /wangpf ip addr    <span class="hljs-number">1</span>: lo: <span class="hljs-variable">&lt;LOOPBACK,UP,LOWER_UP&gt;</span> mtu <span class="hljs-number">65536</span> qdisc noqueue <span class="hljs-keyword">state</span> UNKNOWN <span class="hljs-keyword">group</span> <span class="hljs-keyword">default</span> qlen <span class="hljs-number">1000</span>    link/loopback <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> brd <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>    <span class="hljs-keyword">inet</span> <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>/<span class="hljs-number">8</span> scope host lo       valid_lft forever preferred_lft forever    <span class="hljs-keyword">inet6</span> ::<span class="hljs-number">1</span>/<span class="hljs-number">128</span> scope host        valid_lft forever preferred_lft forever<span class="hljs-number">2</span>: eth0: <span class="hljs-variable">&lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt;</span> mtu <span class="hljs-number">1500</span> qdisc mq <span class="hljs-keyword">state</span> UP <span class="hljs-keyword">group</span> <span class="hljs-keyword">default</span> qlen <span class="hljs-number">1000</span>    link/ether <span class="hljs-number">52</span>:<span class="hljs-number">54</span>:<span class="hljs-number">00</span>:cb:<span class="hljs-number">06</span>:fb brd ff:ff:ff:ff:ff:ff    <span class="hljs-keyword">inet</span> <span class="hljs-number">10.0</span>.<span class="hljs-number">24.9</span>/<span class="hljs-number">22</span> brd <span class="hljs-number">10.0</span>.<span class="hljs-number">27.255</span> scope <span class="hljs-keyword">global</span> eth0       valid_lft forever preferred_lft forever    <span class="hljs-keyword">inet6</span> fe80::<span class="hljs-number">5054</span>:ff:fecb:<span class="hljs-number">6</span>fb/<span class="hljs-number">64</span> scope link        valid_lft forever preferred_lft forever<span class="hljs-number">3</span>: docker0: <span class="hljs-variable">&lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt;</span> mtu <span class="hljs-number">1500</span> qdisc noqueue <span class="hljs-keyword">state</span> DOWN <span class="hljs-keyword">group</span> <span class="hljs-keyword">default</span>     link/ether <span class="hljs-number">02</span>:<span class="hljs-number">42</span>:<span class="hljs-number">9</span>d:ae:<span class="hljs-number">9</span>f:aa brd ff:ff:ff:ff:ff:ff    <span class="hljs-keyword">inet</span> <span class="hljs-number">172.17</span>.<span class="hljs-number">0.1</span>/<span class="hljs-number">16</span> brd <span class="hljs-number">172.17</span>.<span class="hljs-number">255.255</span> scope <span class="hljs-keyword">global</span> docker0       valid_lft forever preferred_lft forever    <span class="hljs-keyword">inet6</span> fe80::<span class="hljs-number">42</span>:<span class="hljs-number">9</span>dff:feae:<span class="hljs-number">9</span>faa/<span class="hljs-number">64</span> scope link        valid_lft forever preferred_lft forever</code></pre><p>lo: 本机回环地址</p><p>eth0: 服务器内网地址</p><p>docker0: docker内地址</p><h3 id="docker-是如何处理容器网络访问的？"><a href="#docker-是如何处理容器网络访问的？" class="headerlink" title="docker 是如何处理容器网络访问的？"></a>docker 是如何处理容器网络访问的？</h3><pre><code class="hljs pf"><span class="hljs-comment"># 查看容器内部网络地址 ip addr</span><span class="hljs-comment"># 如果找不到 ip 这个命令 需要进入容器内部 执行 apt-get update &amp;&amp; apt-get install -y iproute2</span>➜  /wangpf docker exec -it tomcat01 ip addr  <span class="hljs-number">1</span>: lo: <span class="hljs-variable">&lt;LOOPBACK,UP,LOWER_UP&gt;</span> mtu <span class="hljs-number">65536</span> qdisc noqueue <span class="hljs-keyword">state</span> UNKNOWN <span class="hljs-keyword">group</span> <span class="hljs-keyword">default</span> qlen <span class="hljs-number">1000</span>    link/loopback <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> brd <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>    <span class="hljs-keyword">inet</span> <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>/<span class="hljs-number">8</span> scope host lo       valid_lft forever preferred_lft forever<span class="hljs-number">82</span>: eth0@if83: <span class="hljs-variable">&lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt;</span> mtu <span class="hljs-number">1500</span> qdisc noqueue <span class="hljs-keyword">state</span> UP <span class="hljs-keyword">group</span> <span class="hljs-keyword">default</span>     link/ether <span class="hljs-number">02</span>:<span class="hljs-number">42</span>:ac:<span class="hljs-number">11</span>:<span class="hljs-number">00</span>:<span class="hljs-number">03</span> brd ff:ff:ff:ff:ff:ff link-netnsid <span class="hljs-number">0</span>    <span class="hljs-keyword">inet</span> <span class="hljs-number">172.17</span>.<span class="hljs-number">0.3</span>/<span class="hljs-number">16</span> brd <span class="hljs-number">172.17</span>.<span class="hljs-number">255.255</span> scope <span class="hljs-keyword">global</span> eth0       valid_lft forever preferred_lft forever        <span class="hljs-comment"># 这时会发现有个  eth0@if83 的ip地址， 是docker给容器配的</span></code></pre><p>思考： 宿主机（linux）是否可以 ping 同 docker容器内部的ip</p><pre><code class="hljs routeros">Q: 是可以的➜  /wangpf<span class="hljs-built_in"> ping </span>172.17.0.3<span class="hljs-built_in"></span><span class="hljs-built_in">PING </span>172.17.0.3 (172.17.0.3) 56(84) bytes of data.64 bytes <span class="hljs-keyword">from</span> 172.17.0.3: <span class="hljs-attribute">icmp_seq</span>=1 <span class="hljs-attribute">ttl</span>=64 <span class="hljs-attribute">time</span>=0.047 ms64 bytes <span class="hljs-keyword">from</span> 172.17.0.3: <span class="hljs-attribute">icmp_seq</span>=2 <span class="hljs-attribute">ttl</span>=64 <span class="hljs-attribute">time</span>=0.055 ms64 bytes <span class="hljs-keyword">from</span> 172.17.0.3: <span class="hljs-attribute">icmp_seq</span>=3 <span class="hljs-attribute">ttl</span>=64 <span class="hljs-attribute">time</span>=0.048 ms^C--- 172.17.0.3<span class="hljs-built_in"> ping </span>statistics ---3 packets transmitted, 3 received, 0% packet loss, time 1999msrtt min/avg/max/mdev = 0.047/0.050/0.055/0.003 ms</code></pre><p>我们每启动一个docker容器，docker就会给docker容器分配一个ip，我们只要装了 docker，就会有一个网卡：docker0</p><p>docker网络是用的 桥接模式， 使用技术是 <strong>veth-pair</strong> 技术</p><p>再次测试 ip addr</p><pre><code class="hljs pf">➜  /wangpf ip addr <span class="hljs-number">1</span>: lo: <span class="hljs-variable">&lt;LOOPBACK,UP,LOWER_UP&gt;</span> mtu <span class="hljs-number">65536</span> qdisc noqueue <span class="hljs-keyword">state</span> UNKNOWN <span class="hljs-keyword">group</span> <span class="hljs-keyword">default</span> qlen <span class="hljs-number">1000</span>    link/loopback <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> brd <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>    <span class="hljs-keyword">inet</span> <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>/<span class="hljs-number">8</span> scope host lo       valid_lft forever preferred_lft forever    <span class="hljs-keyword">inet6</span> ::<span class="hljs-number">1</span>/<span class="hljs-number">128</span> scope host        valid_lft forever preferred_lft forever<span class="hljs-number">2</span>: eth0: <span class="hljs-variable">&lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt;</span> mtu <span class="hljs-number">1500</span> qdisc mq <span class="hljs-keyword">state</span> UP <span class="hljs-keyword">group</span> <span class="hljs-keyword">default</span> qlen <span class="hljs-number">1000</span>    link/ether <span class="hljs-number">52</span>:<span class="hljs-number">54</span>:<span class="hljs-number">00</span>:cb:<span class="hljs-number">06</span>:fb brd ff:ff:ff:ff:ff:ff    <span class="hljs-keyword">inet</span> <span class="hljs-number">10.0</span>.<span class="hljs-number">24.9</span>/<span class="hljs-number">22</span> brd <span class="hljs-number">10.0</span>.<span class="hljs-number">27.255</span> scope <span class="hljs-keyword">global</span> eth0       valid_lft forever preferred_lft forever    <span class="hljs-keyword">inet6</span> fe80::<span class="hljs-number">5054</span>:ff:fecb:<span class="hljs-number">6</span>fb/<span class="hljs-number">64</span> scope link        valid_lft forever preferred_lft forever<span class="hljs-number">3</span>: docker0: <span class="hljs-variable">&lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt;</span> mtu <span class="hljs-number">1500</span> qdisc noqueue <span class="hljs-keyword">state</span> UP <span class="hljs-keyword">group</span> <span class="hljs-keyword">default</span>     link/ether <span class="hljs-number">02</span>:<span class="hljs-number">42</span>:<span class="hljs-number">9</span>d:ae:<span class="hljs-number">9</span>f:aa brd ff:ff:ff:ff:ff:ff    <span class="hljs-keyword">inet</span> <span class="hljs-number">172.17</span>.<span class="hljs-number">0.1</span>/<span class="hljs-number">16</span> brd <span class="hljs-number">172.17</span>.<span class="hljs-number">255.255</span> scope <span class="hljs-keyword">global</span> docker0       valid_lft forever preferred_lft forever    <span class="hljs-keyword">inet6</span> fe80::<span class="hljs-number">42</span>:<span class="hljs-number">9</span>dff:feae:<span class="hljs-number">9</span>faa/<span class="hljs-number">64</span> scope link        valid_lft forever preferred_lft forever<span class="hljs-number">75</span>: veth72b0f32@if74: <span class="hljs-variable">&lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt;</span> mtu <span class="hljs-number">1500</span> qdisc noqueue master docker0 <span class="hljs-keyword">state</span> UP <span class="hljs-keyword">group</span> <span class="hljs-keyword">default</span>     link/ether <span class="hljs-number">26</span>:ca:<span class="hljs-number">1</span>f:<span class="hljs-number">86</span>:<span class="hljs-number">15</span>:f0 brd ff:ff:ff:ff:ff:ff link-netnsid <span class="hljs-number">0</span>    <span class="hljs-keyword">inet6</span> fe80::<span class="hljs-number">24</span>ca:<span class="hljs-number">1</span>fff:fe86:<span class="hljs-number">15</span>f0/<span class="hljs-number">64</span> scope link        valid_lft forever preferred_lft forever<span class="hljs-number">83</span>: veth1597a88@if82: <span class="hljs-variable">&lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt;</span> mtu <span class="hljs-number">1500</span> qdisc noqueue master docker0 <span class="hljs-keyword">state</span> UP <span class="hljs-keyword">group</span> <span class="hljs-keyword">default</span>     link/ether <span class="hljs-number">3</span>e:<span class="hljs-number">51</span>:<span class="hljs-number">59</span>:a8:<span class="hljs-number">18</span>:<span class="hljs-number">14</span> brd ff:ff:ff:ff:ff:ff link-netnsid <span class="hljs-number">1</span>    <span class="hljs-keyword">inet6</span> fe80::<span class="hljs-number">3</span>c51:<span class="hljs-number">59</span>ff:fea8:<span class="hljs-number">1814</span>/<span class="hljs-number">64</span> scope link        valid_lft forever preferred_lft forever</code></pre><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>发现: 83: veth1597a88@if82 竟然和 内部容器ip地址：82: eth0@if83 是有联系的，</p><p>每产生一个容器，就会生产一对，</p><p>这其实就是 <strong>veth-pair</strong> 技术 ，即 一对的虚拟设备即可，它们都是成对出现的，一端连接着协议，一端彼此相连</p><p>正因为这个特性， <strong>veth-pair</strong> 充当一个桥梁，连接各种虚拟网络设备</p><h3 id="容器互联"><a href="#容器互联" class="headerlink" title="容器互联"></a>容器互联</h3><pre><code class="hljs sql">➜  <span class="hljs-operator">/</span>wangpf docker network ls        NETWORK ID     NAME      DRIVER    <span class="hljs-keyword">SCOPE</span><span class="hljs-number">6</span>fc08493ee6d   bridge    bridge    <span class="hljs-keyword">local</span>d60b6ea897f9   host      host      <span class="hljs-keyword">local</span>d35f61e167a9   <span class="hljs-keyword">none</span>      <span class="hljs-keyword">null</span>      <span class="hljs-keyword">local</span></code></pre><p>网络模式：</p><ul><li>  bridge : docker默认桥接网络</li><li>  host : 主机网络，可以使用宿主机的网络栈，共享宿主机网络</li><li>  none : 不配置网络</li></ul><p>测试：</p><pre><code class="hljs css"># 直接启动的命令，默认是自带 <span class="hljs-attr">--net</span> bridge 这个就是docker0docker run -d -<span class="hljs-selector-tag">P</span> <span class="hljs-attr">--name</span> tomcat01 tomcat等价于docker run -d -<span class="hljs-selector-tag">P</span> <span class="hljs-attr">--name</span> tomcat01 <span class="hljs-attr">--net</span> bridge tomcat</code></pre><h4 id="自定义网络"><a href="#自定义网络" class="headerlink" title="自定义网络"></a>自定义网络</h4><pre><code class="hljs 1c"><span class="hljs-meta"># --dirver bridge (默认就是这个)</span><span class="hljs-meta"># --subnet 192.168.0.0/24  (子网掩码)</span><span class="hljs-meta"># --gateway 192.168.0.1  （网关）</span></code></pre><p>测试</p><pre><code class="hljs pgsql">➜  /wangpf docker network <span class="hljs-keyword">create</span> <span class="hljs-comment">--driver bridge --subnet 192.168.0.0/24 --gateway 192.168.0.1  mynet </span>cbf69e5ae412b8636e29f060c9a00ad769851a2d37e1036a344e50d17128ed82➜  /wangpf docker network ls                                                                          NETWORK ID     <span class="hljs-type">NAME</span>      DRIVER    SCOPE<span class="hljs-number">6</span>fc08493ee6d   bridge    bridge    <span class="hljs-keyword">local</span>d60b6ea897f9   host      host      <span class="hljs-keyword">local</span>cbf69e5ae412   mynet     bridge    <span class="hljs-keyword">local</span>d35f61e167a9   <span class="hljs-keyword">none</span>      <span class="hljs-keyword">null</span>      <span class="hljs-keyword">local</span>➜  /wangpf docker network inspect mynet[    &#123;        &quot;Name&quot;: &quot;mynet&quot;,        &quot;Id&quot;: &quot;cbf69e5ae412b8636e29f060c9a00ad769851a2d37e1036a344e50d17128ed82&quot;,        &quot;Created&quot;: &quot;2021-12-29T16:18:51.071995435+08:00&quot;,        &quot;Scope&quot;: &quot;local&quot;,        &quot;Driver&quot;: &quot;bridge&quot;,        &quot;EnableIPv6&quot;: <span class="hljs-keyword">false</span>,        &quot;IPAM&quot;: &#123;            &quot;Driver&quot;: &quot;default&quot;,            &quot;Options&quot;: &#123;&#125;,            &quot;Config&quot;: [           // 注意这里！！                &#123;                    &quot;Subnet&quot;: &quot;192.168.0.0/24&quot;,                    &quot;Gateway&quot;: &quot;192.168.0.1&quot;                &#125;            ]        &#125;,        &quot;Internal&quot;: <span class="hljs-keyword">false</span>,        &quot;Attachable&quot;: <span class="hljs-keyword">false</span>,        &quot;Ingress&quot;: <span class="hljs-keyword">false</span>,        &quot;ConfigFrom&quot;: &#123;            &quot;Network&quot;: &quot;&quot;        &#125;,        &quot;ConfigOnly&quot;: <span class="hljs-keyword">false</span>,        &quot;Containers&quot;: &#123;&#125;,        &quot;Options&quot;: &#123;&#125;,        &quot;Labels&quot;: &#123;&#125;    &#125;]</code></pre><pre><code class="hljs jboss-cli"><span class="hljs-comment"># 连接网络</span>➜  <span class="hljs-string">/wangpf</span> docker run -d -P <span class="hljs-params">--name</span> tomca-nett01 <span class="hljs-params">--net</span> mynet tomcat<span class="hljs-function">:9.0</span>3d690e942aa7ab13c0b41f020a5f834b807ce28e591d83a893f3ca3cecec2b09➜  <span class="hljs-string">/wangpf</span> docker run -d -P <span class="hljs-params">--name</span> tomca-nett02 <span class="hljs-params">--net</span> mynet tomcat<span class="hljs-function">:9.0</span>51ac52f3a129808d0210310f8607f3712332202c13c8bce63808af36e526552a<span class="hljs-comment"># 再次查看 mynet 详细信息</span>➜  <span class="hljs-string">/wangpf</span> docker network inspect mynet                               [    &#123;        <span class="hljs-string">&quot;Name&quot;</span>: <span class="hljs-string">&quot;mynet&quot;</span>,        <span class="hljs-string">&quot;Id&quot;</span>: <span class="hljs-string">&quot;cbf69e5ae412b8636e29f060c9a00ad769851a2d37e1036a344e50d17128ed82&quot;</span>,        <span class="hljs-string">&quot;Created&quot;</span>: <span class="hljs-string">&quot;2021-12-29T16:18:51.071995435+08:00&quot;</span>,        <span class="hljs-string">&quot;Scope&quot;</span>: <span class="hljs-string">&quot;local&quot;</span>,        <span class="hljs-string">&quot;Driver&quot;</span>: <span class="hljs-string">&quot;bridge&quot;</span>,        <span class="hljs-string">&quot;EnableIPv6&quot;</span>: <span class="hljs-literal">false</span>,        <span class="hljs-string">&quot;IPAM&quot;</span>: &#123;            <span class="hljs-string">&quot;Driver&quot;</span>: <span class="hljs-string">&quot;default&quot;</span>,            <span class="hljs-string">&quot;Options&quot;</span>: &#123;&#125;,            <span class="hljs-string">&quot;Config&quot;</span>: [                &#123;                    <span class="hljs-string">&quot;Subnet&quot;</span>: <span class="hljs-string">&quot;192.168.0.0/24&quot;</span>,                    <span class="hljs-string">&quot;Gateway&quot;</span>: <span class="hljs-string">&quot;192.168.0.1&quot;</span>                &#125;            ]        &#125;,        <span class="hljs-string">&quot;Internal&quot;</span>: <span class="hljs-literal">false</span>,        <span class="hljs-string">&quot;Attachable&quot;</span>: <span class="hljs-literal">false</span>,        <span class="hljs-string">&quot;Ingress&quot;</span>: <span class="hljs-literal">false</span>,        <span class="hljs-string">&quot;ConfigFrom&quot;</span>: &#123;            <span class="hljs-string">&quot;Network&quot;</span>: <span class="hljs-string">&quot;&quot;</span>        &#125;,        <span class="hljs-string">&quot;ConfigOnly&quot;</span>: <span class="hljs-literal">false</span>,        <span class="hljs-string">&quot;Containers&quot;</span>: &#123;    <span class="hljs-string">//</span> 刚刚俩个连接的容器 ！！            <span class="hljs-string">&quot;3d690e942aa7ab13c0b41f020a5f834b807ce28e591d83a893f3ca3cecec2b09&quot;</span>: &#123;                <span class="hljs-string">&quot;Name&quot;</span>: <span class="hljs-string">&quot;tomca-nett01&quot;</span>,                <span class="hljs-string">&quot;EndpointID&quot;</span>: <span class="hljs-string">&quot;f9cf82205338298aee158eeb43e8ddc56959254fe8040ab88dcb17f403a35a13&quot;</span>,                <span class="hljs-string">&quot;MacAddress&quot;</span>: <span class="hljs-string">&quot;02:42:c0:a8:00:02&quot;</span>,                <span class="hljs-string">&quot;IPv4Address&quot;</span>: <span class="hljs-string">&quot;192.168.0.2/24&quot;</span>,                <span class="hljs-string">&quot;IPv6Address&quot;</span>: <span class="hljs-string">&quot;&quot;</span>            &#125;,            <span class="hljs-string">&quot;51ac52f3a129808d0210310f8607f3712332202c13c8bce63808af36e526552a&quot;</span>: &#123;                <span class="hljs-string">&quot;Name&quot;</span>: <span class="hljs-string">&quot;tomca-nett02&quot;</span>,                <span class="hljs-string">&quot;EndpointID&quot;</span>: <span class="hljs-string">&quot;d34235570f8c2ea3ca9814d61d21c3be7bf9c70071f3161ed897bdf346b5611d&quot;</span>,                <span class="hljs-string">&quot;MacAddress&quot;</span>: <span class="hljs-string">&quot;02:42:c0:a8:00:03&quot;</span>,                <span class="hljs-string">&quot;IPv4Address&quot;</span>: <span class="hljs-string">&quot;192.168.0.3/24&quot;</span>,                <span class="hljs-string">&quot;IPv6Address&quot;</span>: <span class="hljs-string">&quot;&quot;</span>            &#125;        &#125;,        <span class="hljs-string">&quot;Options&quot;</span>: &#123;&#125;,        <span class="hljs-string">&quot;Labels&quot;</span>: &#123;&#125;    &#125;]</code></pre><p>为什么使用自定义网络的原因:</p><ol start="0"><li> 主要是因为 docker0 的方式（无法直接通过容器名来连接， 当然配置 –link 也可以，不过这个不推荐了），</li><li> 自定义容器可以将俩个容器都放在一个局域网内，使得这个俩个容器，使用容器名就可以通信了</li></ol><p>测试</p><pre><code class="hljs routeros"><span class="hljs-comment"># 用容器  tomcat-net01 是可以 ping 通  tomcat-net02 的！</span>root@44d12fd7d79f:/usr/local/tomcat#<span class="hljs-built_in"> ping </span>tomcat-net02<span class="hljs-built_in"></span><span class="hljs-built_in">PING </span>tomcat-net02 (192.168.0.3) 56(84) bytes of data.64 bytes <span class="hljs-keyword">from</span> tomcat-net02.mynet (192.168.0.3): <span class="hljs-attribute">icmp_seq</span>=1 <span class="hljs-attribute">ttl</span>=64 <span class="hljs-attribute">time</span>=0.045 ms64 bytes <span class="hljs-keyword">from</span> tomcat-net02.mynet (192.168.0.3): <span class="hljs-attribute">icmp_seq</span>=2 <span class="hljs-attribute">ttl</span>=64 <span class="hljs-attribute">time</span>=0.059 ms^C--- tomcat-net02<span class="hljs-built_in"> ping </span>statistics ---2 packets transmitted, 2 received, 0% packet loss, time 1000msrtt min/avg/max/mdev = 0.045/0.052/0.059/0.007 ms</code></pre><h4 id="网络连通"><a href="#网络连通" class="headerlink" title="网络连通"></a>网络连通</h4><blockquote><p>docker network connect</p></blockquote><p>测试</p><pre><code class="hljs routeros"><span class="hljs-comment">#  以 docker0 网卡 起个容器</span>docker <span class="hljs-built_in">run</span> -d -P --name tomcat01 tomcat:9.0<span class="hljs-comment"># 这时肯定是 ping 不通 mynet 网卡上的容器的</span>docker exec -it tomcat01<span class="hljs-built_in"> ping </span>tomcat-net01ping: tomcat-net01: Name <span class="hljs-keyword">or</span><span class="hljs-built_in"> service </span><span class="hljs-keyword">not</span> known<span class="hljs-comment"># 使用 docker network connect</span>➜  /wangpf docker<span class="hljs-built_in"> network </span>connect mynet tomcat01➜  /wangpf docker<span class="hljs-built_in"> network </span>inspect mynet                  <span class="hljs-string">&quot;Containers&quot;</span>: &#123;            <span class="hljs-string">&quot;44d12fd7d79f61e3b1da1cbd491d880bb5a69ff18d7da0008031381796c34087&quot;</span>: &#123;                <span class="hljs-string">&quot;Name&quot;</span>: <span class="hljs-string">&quot;tomcat-net01&quot;</span>,                <span class="hljs-string">&quot;EndpointID&quot;</span>: <span class="hljs-string">&quot;2770cd7186061615abbceb79846b196ad01f8e7bfb3e2c0d7855d38f05f17206&quot;</span>,                <span class="hljs-string">&quot;MacAddress&quot;</span>: <span class="hljs-string">&quot;02:42:c0:a8:00:02&quot;</span>,                <span class="hljs-string">&quot;IPv4Address&quot;</span>: <span class="hljs-string">&quot;192.168.0.2/24&quot;</span>,                <span class="hljs-string">&quot;IPv6Address&quot;</span>: <span class="hljs-string">&quot;&quot;</span>            &#125;,            <span class="hljs-string">&quot;a750eb7d5a21afd1f2662a2be3e846f224c731939bc2b3995ca578ca79cfc78a&quot;</span>: &#123;                <span class="hljs-string">&quot;Name&quot;</span>: <span class="hljs-string">&quot;tomcat-net02&quot;</span>,                <span class="hljs-string">&quot;EndpointID&quot;</span>: <span class="hljs-string">&quot;a4f26995539029c65a5df222c8590765b262d635c9375d1b348836b36b8b10f9&quot;</span>,                <span class="hljs-string">&quot;MacAddress&quot;</span>: <span class="hljs-string">&quot;02:42:c0:a8:00:03&quot;</span>,                <span class="hljs-string">&quot;IPv4Address&quot;</span>: <span class="hljs-string">&quot;192.168.0.3/24&quot;</span>,                <span class="hljs-string">&quot;IPv6Address&quot;</span>: <span class="hljs-string">&quot;&quot;</span>            &#125;,            <span class="hljs-string">&quot;a92d70533b64f56f879e66b7d9080a963cf9427e61c016a7e4856bae645c6e87&quot;</span>: &#123;                <span class="hljs-string">&quot;Name&quot;</span>: <span class="hljs-string">&quot;tomcat01&quot;</span>,                <span class="hljs-string">&quot;EndpointID&quot;</span>: <span class="hljs-string">&quot;4c6a4a54a0d3ac85ed8854ef4bd47ca700270b75ce0e0a41aad396389bd2744c&quot;</span>,                <span class="hljs-string">&quot;MacAddress&quot;</span>: <span class="hljs-string">&quot;02:42:c0:a8:00:04&quot;</span>,                <span class="hljs-string">&quot;IPv4Address&quot;</span>: <span class="hljs-string">&quot;192.168.0.4/24&quot;</span>,                <span class="hljs-string">&quot;IPv6Address&quot;</span>: <span class="hljs-string">&quot;&quot;</span>            &#125;        &#125;,        <span class="hljs-comment"># 发现 tomcat01 容器 已经存放在了 mynet下了， 即 一个容器俩个ip地址</span><span class="hljs-comment"># 成化打通！！</span>➜  /wangpf docker exec -it tomcat01<span class="hljs-built_in"> ping </span>tomcat-net01<span class="hljs-built_in"></span><span class="hljs-built_in">PING </span>tomcat-net01 (192.168.0.2) 56(84) bytes of data.64 bytes <span class="hljs-keyword">from</span> tomcat-net01.mynet (192.168.0.2): <span class="hljs-attribute">icmp_seq</span>=1 <span class="hljs-attribute">ttl</span>=64 <span class="hljs-attribute">time</span>=0.064 ms64 bytes <span class="hljs-keyword">from</span> tomcat-net01.mynet (192.168.0.2): <span class="hljs-attribute">icmp_seq</span>=2 <span class="hljs-attribute">ttl</span>=64 <span class="hljs-attribute">time</span>=0.051 ms64 bytes <span class="hljs-keyword">from</span> tomcat-net01.mynet (192.168.0.2): <span class="hljs-attribute">icmp_seq</span>=3 <span class="hljs-attribute">ttl</span>=64 <span class="hljs-attribute">time</span>=0.056 ms</code></pre><h2 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker compose"></a>docker compose</h2><p>官方文档：<a href="https://docs.docker.com/compose/">compose</a></p><blockquote><p>Compose is a tool for defining and running multi-container Docker applications. With Compose, you use a YAML file to configure your application’s services. Then, with a single command, you create and start all the services from your configuration. To learn more about all the features of Compose, see <a href="https://docs.docker.com/compose/#features">the list of features</a>.</p><p>Compose works in all environments: production, staging, development, testing, as well as CI workflows. You can learn more about each case in <a href="https://docs.docker.com/compose/#common-use-cases">Common Use Cases</a>.</p><p>Using Compose is basically a three-step process:</p><ol start="0"><li> Define your app’s environment with a <code>Dockerfile</code> so it can be reproduced anywhere.</li><li> Define the services that make up your app in <code>docker-compose.yml</code> so they can be run together in an isolated environment.</li><li> Run <code>docker compose up</code> and the <a href="https://docs.docker.com/compose/cli-command/">Docker compose command</a> starts and runs your entire app. You can alternatively run <code>docker-compose up</code> using the docker-compose binary.</li></ol></blockquote><p>注意： <code>compose</code> 是docker 的开源项目，需要去安装的！</p><h3 id="安装-compose"><a href="#安装-compose" class="headerlink" title="安装 compose"></a>安装 compose</h3><p>官方文档：<a href="https://docs.docker.com/compose/install/">compose install</a></p><pre><code class="hljs 1c"><span class="hljs-meta"># 第一步 使用github actions 把打包后的代码公共自动化来传到 docker hub 上</span><span class="hljs-meta"># 第二步 在actions 中 登录服务器，并从 docker hub 把镜像拉下来并运行</span></code></pre><p>未完…</p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>捉摸不清的“this”</title>
    <link href="/2021/11/09/72-this/"/>
    <url>/2021/11/09/72-this/</url>
    
    <content type="html"><![CDATA[<h2 id="“独特”的-this"><a href="#“独特”的-this" class="headerlink" title="“独特”的 this"></a>“独特”的 this</h2><h3 id="为什么需要-this？"><a href="#为什么需要-this？" class="headerlink" title="为什么需要 this？"></a>为什么需要 this？</h3><p>在常见的编程语言中，几乎都有 this 这个关键字（Objective-C 中使用的是 self），但是 JavaScript 中的 this 和常见的面向对象语 言中的 this 不太一样</p><ul><li>常见面向对象的编程语言中，比如 Java、C++、Swift、Dart 等等一系列语言中，this 通常只会出现在类的方法中</li><li>也就是你需要有一个类，类中的方法（特别是实例方法）中，this 代表的是当前调用对象</li><li>但是 JavaScript 中的 this 更加灵活，无论是它出现的位置还是它代表的含义</li></ul><h3 id="this-到底指向什么？"><a href="#this-到底指向什么？" class="headerlink" title="this 到底指向什么？"></a>this 到底指向什么？</h3><blockquote><p>我们都知道，如果在浏览器环境下，this 在全局指向的是 window 如果在 node 环境下，this 在全局指向的是 { } （空对象）</p></blockquote><p>定义一个函数，我采用三种不同的方式在浏览器上对它调用，它将会产生了三种不同的结果：</p><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)&#125;<span class="hljs-title function_">foo</span>() <span class="hljs-comment">// 指向 window</span><span class="hljs-keyword">var</span> obj = &#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;wpf&#x27;</span>,  <span class="hljs-attr">foo</span>: foo,&#125;obj.<span class="hljs-title function_">foo</span>() <span class="hljs-comment">// 指向 obj</span>foo.<span class="hljs-title function_">apply</span>(<span class="hljs-string">&#x27;abc&#x27;</span>) <span class="hljs-comment">// 指向 &#x27;abc&#x27;</span></code></pre><p>结果如图：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0b6f736fe10f4b2db1440388057491b2~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="this.png"></p><p>第一个就是 window 调用了 foo 函数 foo() 可转换为 <strong>window.foo()</strong> , 所以 this 指向 window</p><p>第二个是 obj 调用了 foo 函数， <strong>obj.foo()</strong> 所以 this 指向 obj</p><p>第三个是 用 apply 将 this 指向了 ‘abc’， 这个就很明确了， 是显式绑定 ，明显 this 指向的就是 ‘abc’</p><p>根据上述分析，由此可以得出结论：</p><ol><li> this 的指向，跟函数所处的位置是没有关系的</li><li> 跟函数的调用方式有关系</li></ol><p><strong>即： 当为隐式绑定时，谁调用了 foo 这个函数，那么 this 就指向谁。（排除箭头函数）</strong></p><p>又比如这个较为刁钻的题：</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj = &#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;wpf&#x27;</span>,  <span class="hljs-attr">foo</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)  &#125;,&#125;<span class="hljs-keyword">var</span> bar = obj.<span class="hljs-property">foo</span><span class="hljs-title function_">bar</span>()</code></pre><p>请问 bar 调用后， this 指向哪里呢？</p><p><strong>首先要记住 谁调用了该函数，那么该函数内的 this 就指向谁（排除箭头函数）</strong></p><p>那么 bar 是谁调用的呢？ 当然是 <strong>window</strong> 呀， 因为 bar 是在全局定义的嘛。</p><h3 id="细说-this-绑定规则"><a href="#细说-this-绑定规则" class="headerlink" title="细说 this 绑定规则"></a>细说 this 绑定规则</h3><h4 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h4><p>什么情况下使用默认绑定呢？独立函数调用。</p><p>独立的函数调用我们可以理解成函数没有被绑定到某个对象上进行调用</p><p>我们通过几个案例来看一下，常见的默认绑定</p><pre><code class="hljs js"><span class="hljs-comment">// 案例一</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)&#125;<span class="hljs-title function_">foo</span>()</code></pre><pre><code class="hljs js"><span class="hljs-comment">// 案例二</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-title function_">foo</span>()&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">baz</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-title function_">bar</span>()&#125;<span class="hljs-title function_">baz</span>()</code></pre><pre><code class="hljs js"><span class="hljs-comment">// 案例三</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">Fn</span>) &#123;  <span class="hljs-title class_">Fn</span>()&#125;<span class="hljs-keyword">var</span> obj = &#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;tao&#x27;</span>,  <span class="hljs-attr">bar</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)  &#125;,&#125;<span class="hljs-title function_">foo</span>(obj.<span class="hljs-property">bar</span>)</code></pre><pre><code class="hljs js"><span class="hljs-comment">// 案例四</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)  &#125;&#125;<span class="hljs-keyword">var</span> fn = <span class="hljs-title function_">foo</span>()<span class="hljs-title function_">fn</span>()</code></pre><p>这上面所有的案例 this 的打印结果都是 window，</p><p>也可根据 函数的调用方式来判断， 由于都是定义在全局的方法，即 window.xxx() ， 所以可以理解为 window 调用的，即 this 都指向了 window</p><h4 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h4><p>另外一种比较常见的调用方式是通过某个对象进行调用的</p><p>也就是它的调用位置中，是通过某个对象发起的函数调用</p><p>obj 对象会被 js 引擎绑定到 fn 函数中的 this 里面</p><p>我们通过几个案例来看一下，常见的隐式绑定</p><pre><code class="hljs js"><span class="hljs-comment">// 案例一</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)&#125;<span class="hljs-keyword">var</span> obj = &#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;tao&#x27;</span>,  <span class="hljs-attr">foo</span>: foo,&#125;obj.<span class="hljs-title function_">foo</span>() <span class="hljs-comment">// obj</span></code></pre><pre><code class="hljs js"><span class="hljs-comment">// 案例二</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)&#125;<span class="hljs-keyword">var</span> bar = &#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;bar&#x27;</span>,  <span class="hljs-attr">foo</span>: foo,&#125;<span class="hljs-keyword">var</span> bar = bar.<span class="hljs-property">foo</span><span class="hljs-title function_">bar</span>() <span class="hljs-comment">// window</span></code></pre><p>案例一： 因为是 obj 调用的 ，所以 this 指向 obj</p><p>案例二：因为 bar 是定义在全局的， 所以 bar() 相当于 window.bar() ，所以 this 指向 window</p><h4 id="显式绑定"><a href="#显式绑定" class="headerlink" title="显式绑定"></a>显式绑定</h4><p>显式绑定其实就是用到了 JavaScript 函数原型链上的 call 、 apply 、 bind 方法</p><p>这三个方法的具体用法就不细说了，可以去看 mdn</p><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">num1, num2</span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num1 + num2, <span class="hljs-variable language_">this</span>)&#125;foo.<span class="hljs-title function_">apply</span>(<span class="hljs-string">&#x27;aaa&#x27;</span>) <span class="hljs-comment">// 指向 &#x27;aaa&#x27;</span>foo.<span class="hljs-title function_">call</span>(<span class="hljs-string">&#x27;aaa&#x27;</span>) <span class="hljs-comment">// 指向 &#x27;aaa&#x27;</span><span class="hljs-keyword">var</span> fn = foo.<span class="hljs-title function_">bind</span>(<span class="hljs-string">&#x27;aaa&#x27;</span>)<span class="hljs-title function_">fn</span>() <span class="hljs-comment">// 指向 &#x27;aaa&#x27;</span></code></pre><h3 id="规则优先级"><a href="#规则优先级" class="headerlink" title="规则优先级"></a>规则优先级</h3><p>学习了以上四条规则，接下来开发中我们只需要去查找函数的调用应用了哪条规则即可，但是如果一个函数调用位置应用了多条规则，优先级谁更高呢？</p><p>默认规则的优先级最低（毫无疑问，默认规则的优先级是最低的，因为存在其他规则时，就会通过其他规则的方式来绑定 this）</p><p><strong>显式绑定优先级高于隐式绑定</strong></p><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)&#125;<span class="hljs-keyword">var</span> obj = &#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;wpf&#x27;</span>,  <span class="hljs-attr">foo</span>: foo.<span class="hljs-title function_">bind</span>(<span class="hljs-string">&#x27;aaa&#x27;</span>),&#125;obj.<span class="hljs-title function_">foo</span>() <span class="hljs-comment">// 指向 &quot;aaa&quot;</span></code></pre><p><strong>new 绑定优先级高于隐式绑定</strong></p><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)&#125;<span class="hljs-keyword">var</span> obj = &#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;wpf&#x27;</span>,  <span class="hljs-attr">foo</span>: foo,&#125;<span class="hljs-keyword">var</span> o = <span class="hljs-keyword">new</span> obj.<span class="hljs-title function_">foo</span>() <span class="hljs-comment">//  指向 foo</span></code></pre><p><strong>new 绑定优先级高于 bind</strong></p><ul><li>new 绑定和 call、apply 是不允许同时使用的，所以不存在谁的优先级更高</li><li>new 绑定可以和 bind 一起使用，new 绑定优先级更高</li></ul><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)&#125;<span class="hljs-keyword">var</span> bar = foo.<span class="hljs-title function_">bind</span>(<span class="hljs-string">&#x27;aaa&#x27;</span>)<span class="hljs-keyword">var</span> baz = <span class="hljs-keyword">new</span> <span class="hljs-title function_">bar</span>()<span class="hljs-title function_">baz</span>() <span class="hljs-comment">// 指向 foo</span></code></pre><p><strong>总结</strong></p><p>new 绑定 &gt; 显式绑定(bind/call/apply) &gt; 隐式绑定 &gt; 默认绑定</p><h3 id="关于-this-和箭头函数"><a href="#关于-this-和箭头函数" class="headerlink" title="关于 this 和箭头函数"></a>关于 this 和箭头函数</h3><p>箭头函数是不绑定 this 的， 而是根据外层作用域来决定 this，这里就不细说了。</p><h3 id="经典面试题"><a href="#经典面试题" class="headerlink" title="经典面试题"></a>经典面试题</h3><p><strong>Q1:</strong></p><pre><code class="hljs js"><span class="hljs-comment">// 案例一</span><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;window&#x27;</span><span class="hljs-keyword">var</span> person = &#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;person&#x27;</span>,  <span class="hljs-attr">sayName</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)  &#125;,&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">sayName</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">var</span> sss = person.<span class="hljs-property">sayName</span>  <span class="hljs-title function_">sss</span>()  person.<span class="hljs-title function_">sayName</span>()  person.<span class="hljs-title function_">sayName</span>()  ;(b = person.<span class="hljs-property">sayName</span>)()&#125;<span class="hljs-title function_">sayName</span>()</code></pre><p><strong>A1:</strong></p><p>window 、 person 、 persopn 、 window</p><p><strong>Q2:</strong></p><pre><code class="hljs JS"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;window&#x27;</span><span class="hljs-keyword">var</span> person1 = &#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;person1&#x27;</span>,  <span class="hljs-attr">foo1</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)  &#125;,  <span class="hljs-attr">foo2</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>),  <span class="hljs-attr">foo3</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)    &#125;  &#125;,  <span class="hljs-attr">foo4</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)    &#125;  &#125;&#125;<span class="hljs-keyword">var</span> person2 = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;person2&#x27;</span> &#125;person1.<span class="hljs-title function_">foo1</span>();person1.<span class="hljs-property">foo1</span>.<span class="hljs-title function_">call</span>(person2);person1.<span class="hljs-title function_">foo2</span>();person1.<span class="hljs-property">foo2</span>.<span class="hljs-title function_">call</span>(person2);person1.<span class="hljs-title function_">foo3</span>()();person1.<span class="hljs-property">foo3</span>.<span class="hljs-title function_">call</span>(person2)();person1.<span class="hljs-title function_">foo3</span>().<span class="hljs-title function_">call</span>(person2);person1.<span class="hljs-title function_">foo4</span>()();person1.<span class="hljs-property">foo4</span>.<span class="hljs-title function_">call</span>(person2)();person1.<span class="hljs-title function_">foo4</span>().<span class="hljs-title function_">call</span>(person2);</code></pre><p><strong>A2:</strong></p><pre><code class="hljs js">person1.<span class="hljs-title function_">foo1</span>() <span class="hljs-comment">// person1  隐式绑定</span>person1.<span class="hljs-property">foo1</span>.<span class="hljs-title function_">call</span>(person2) <span class="hljs-comment">//  person2 显式绑定</span>person1.<span class="hljs-title function_">foo2</span>() <span class="hljs-comment">//  window  foo2 是个箭头函数,this指向上层作用域即全局</span>person1.<span class="hljs-property">foo2</span>.<span class="hljs-title function_">call</span>(person2) <span class="hljs-comment">// window   箭头函数不适用于显式绑定</span>person1.<span class="hljs-title function_">foo3</span>()() <span class="hljs-comment">// window   调用位置在全局作用域下，</span>person1.<span class="hljs-property">foo3</span>.<span class="hljs-title function_">call</span>(person2)() <span class="hljs-comment">// window  返回的函数依然是在全局下调用的</span>person1.<span class="hljs-title function_">foo3</span>().<span class="hljs-title function_">call</span>(person2) <span class="hljs-comment">//  person2   显式绑定</span>person1.<span class="hljs-title function_">foo4</span>()() <span class="hljs-comment">//person1  箭头函数， this指向上层作用域即 person1对象</span>person1.<span class="hljs-property">foo4</span>.<span class="hljs-title function_">call</span>(person2)() <span class="hljs-comment">// person2 显式绑定后，返回的箭头函数指向上层作用域即 person2对象</span>person1.<span class="hljs-title function_">foo4</span>().<span class="hljs-title function_">call</span>(person2) <span class="hljs-comment">// person1  箭头函数只看上层作用域即 person1对象</span></code></pre><p><strong>Q3:</strong></p><pre><code class="hljs js"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;window&#x27;</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name  ;(<span class="hljs-variable language_">this</span>.<span class="hljs-property">foo1</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)  &#125;),    (<span class="hljs-variable language_">this</span>.<span class="hljs-property">foo2</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)),    (<span class="hljs-variable language_">this</span>.<span class="hljs-property">foo3</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)      &#125;    &#125;),    (<span class="hljs-variable language_">this</span>.<span class="hljs-property">foo4</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)      &#125;    &#125;)&#125;<span class="hljs-keyword">var</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;person1&#x27;</span>)<span class="hljs-keyword">var</span> person2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;person2&#x27;</span>)person1.<span class="hljs-title function_">foo1</span>()person1.<span class="hljs-property">foo1</span>.<span class="hljs-title function_">call</span>(person2)person1.<span class="hljs-title function_">foo2</span>()person1.<span class="hljs-property">foo2</span>.<span class="hljs-title function_">call</span>(person2)person1.<span class="hljs-title function_">foo3</span>()()person1.<span class="hljs-property">foo3</span>.<span class="hljs-title function_">call</span>(person2)()person1.<span class="hljs-title function_">foo3</span>().<span class="hljs-title function_">call</span>(person2)person1.<span class="hljs-title function_">foo4</span>()()person1.<span class="hljs-property">foo4</span>.<span class="hljs-title function_">call</span>(person2)()person1.<span class="hljs-title function_">foo4</span>().<span class="hljs-title function_">call</span>(person2)</code></pre><p><strong>A2:</strong></p><pre><code class="hljs JS">person1.<span class="hljs-title function_">foo1</span>() <span class="hljs-comment">// peron1  隐式绑定</span>person1.<span class="hljs-property">foo1</span>.<span class="hljs-title function_">call</span>(person2) <span class="hljs-comment">// person2  显式绑定</span>person1.<span class="hljs-title function_">foo2</span>() <span class="hljs-comment">// person1  箭头函数找上一层</span>person1.<span class="hljs-property">foo2</span>.<span class="hljs-title function_">call</span>(person2) <span class="hljs-comment">// person1 箭头函数找上一层</span>person1.<span class="hljs-title function_">foo3</span>()() <span class="hljs-comment">// window 调用位置是全局直接调用</span>person1.<span class="hljs-property">foo3</span>.<span class="hljs-title function_">call</span>(person2)() <span class="hljs-comment">// window  调用位置是全局直接调用</span>person1.<span class="hljs-title function_">foo3</span>().<span class="hljs-title function_">call</span>(person2) <span class="hljs-comment">// person2   显式绑定</span>person1.<span class="hljs-title function_">foo4</span>()() <span class="hljs-comment">// person1 箭头函数找上一层</span>person1.<span class="hljs-property">foo4</span>.<span class="hljs-title function_">call</span>(person2)() <span class="hljs-comment">// person2  调用时，找到了上层绑定的person2</span>person1.<span class="hljs-title function_">foo4</span>().<span class="hljs-title function_">call</span>(person2) <span class="hljs-comment">// person1 箭头函数找上一层</span></code></pre><p><strong>Q3:</strong></p><pre><code class="hljs JS"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;window&#x27;</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name  <span class="hljs-variable language_">this</span>.<span class="hljs-property">obj</span> = &#123;    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;obj&#x27;</span>,    <span class="hljs-attr">foo1</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)      &#125;    &#125;,    <span class="hljs-attr">foo2</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)      &#125;    &#125;,  &#125;&#125;<span class="hljs-keyword">var</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;person1&#x27;</span>)<span class="hljs-keyword">var</span> person2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;person2&#x27;</span>)person1.<span class="hljs-property">obj</span>.<span class="hljs-title function_">foo1</span>()() <span class="hljs-comment">//  window</span>person1.<span class="hljs-property">obj</span>.<span class="hljs-property">foo1</span>.<span class="hljs-title function_">call</span>(person2)() <span class="hljs-comment">// window</span>person1.<span class="hljs-property">obj</span>.<span class="hljs-title function_">foo1</span>().<span class="hljs-title function_">call</span>(person2) <span class="hljs-comment">// person2</span>person1.<span class="hljs-property">obj</span>.<span class="hljs-title function_">foo2</span>()() <span class="hljs-comment">// obj</span>person1.<span class="hljs-property">obj</span>.<span class="hljs-property">foo2</span>.<span class="hljs-title function_">call</span>(person2)() <span class="hljs-comment">// person2</span>person1.<span class="hljs-property">obj</span>.<span class="hljs-title function_">foo2</span>().<span class="hljs-title function_">call</span>(person2) <span class="hljs-comment">// obj</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>JavaScript高级</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript高级</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>让人疑惑的闭包</title>
    <link href="/2021/11/05/71-%E9%97%AD%E5%8C%85/"/>
    <url>/2021/11/05/71-%E9%97%AD%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h2 id="让人迷惑的闭包"><a href="#让人迷惑的闭包" class="headerlink" title="让人迷惑的闭包"></a>让人迷惑的闭包</h2><blockquote><p>闭包是 JavaScript 中一个非常容易让人迷惑的知识点：</p></blockquote><blockquote><p>在 《你不知道的 JavaScript（上卷）》中有一段作者关于闭包的启示:</p></blockquote><blockquote><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c14d6ff8e7dc4d0bba4a70952f548f3c~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="不知道的JavaScript.png"></p></blockquote><p>闭包确实是 JavaScript 中一个很难理解的知识点，接下来我们就对其一步步来进行剖析，看看它到底有什么神奇之<br>处。</p><h3 id="函数是一等公民"><a href="#函数是一等公民" class="headerlink" title="函数是一等公民"></a>函数是一等公民</h3><p>在 JavaScript 中，函数是非常重要的，并且是一等公民：</p><ul><li>那么就意味着函数的使用是非常灵活的；</li><li>函数可以作为另外一个函数的参数，也可以作为另外一个函数的返回值来使用；</li></ul><p>你可以使用内置的高阶函数，甚至可以自己编写高阶函数</p><h3 id="闭包的定义"><a href="#闭包的定义" class="headerlink" title="闭包的定义"></a>闭包的定义</h3><p>这里先来看一下闭包的定义，分成两个：在计算机科学中 和 在 JavaScript 中。</p><p>在计算机科学中对闭包的定义（<a href="https://zh.wikipedia.org/wiki/%E9%97%AD%E5%8C%85_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)">维基百科</a>）：</p><ul><li>闭包（英语：Closure），又称 <strong>词法闭包</strong>（Lexical Closure）或 <strong>函数闭包</strong>（function closures）</li><li>是在支持 <strong>头等函数</strong> 的编程语言中，实现词法绑定的一种技术</li><li>闭包在实现上是一个结构体，它存储了一个函数和一个关联的环境（相当于一个符号查找表）</li><li>闭包跟函数最大的区别在于，当捕捉闭包的时候，它的 <strong>自由变量</strong> 会在捕捉时被确定，这样即使脱离了捕捉时的上下文，它也能照常运行</li></ul><p>闭包的概念出现于 60 年代，最早实现闭包的程序是 Scheme，那么我们就可以理解为什么 JavaScript 中有闭包</p><p>因为 JavaScript 中有大量的设计是来源于 Scheme 的</p><p>我们再来看一下 MDN 对 JavaScript 闭包的解释：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures">MDN 闭包</a></p><ul><li>一个函数和对其周围状态（lexical environment，<strong>词法环境</strong>）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）</li><li>也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域</li><li>在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来</li></ul><p>那么我的理解和总结：</p><ul><li>一个普通的函数 function，如果它可以访问外层作用域的自由变量，那么这个函数就是一个闭包</li><li>从广义的角度来说：JavaScript 中的函数都是闭包</li><li>从狭义的角度来说：JavaScript 中一个函数，如果访问了外层作用域的变量，那么它是一个闭包</li></ul><blockquote><p>光看定义可能会很懵，后面我会通过内存的角度来解析闭包</p></blockquote><h3 id="闭包的访问过程"><a href="#闭包的访问过程" class="headerlink" title="闭包的访问过程"></a>闭包的访问过程</h3><pre><code class="hljs js"><span class="hljs-number">1</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-number">2</span> <span class="hljs-keyword">var</span> username = <span class="hljs-string">&#x27;wpf&#x27;</span>;<span class="hljs-number">3</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-number">4</span>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(username);<span class="hljs-number">5</span> &#125;<span class="hljs-number">6</span>   <span class="hljs-keyword">return</span> bar;<span class="hljs-number">7</span> &#125;<span class="hljs-number">8</span> <span class="hljs-keyword">var</span> fn = <span class="hljs-title function_">foo</span>();<span class="hljs-number">9</span> <span class="hljs-title function_">fn</span>();</code></pre><p>例如上述代码， <strong>函数 bar</strong> 和它外部的<strong>自由变量 username</strong> ，这俩部分组合起来就是一个闭包。</p><p>从内存角度分析：</p><ol><li> 此时 GO（global object） 中 变量 fn 目前为 undefined</li><li> 当代码执行到 第 8 行后， foo 函数被调用了，之后就会被销毁， 然后 变量 fn 指向 bar 函数</li><li> 当执行第 9 行时，bar 函数被调用， 但之后不会被销毁，因为 bar 函数还引用这一个外部变量 username</li><li> 此时导致闭包的形成</li></ol><h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><p>我们经常听说 闭包是有内存泄漏的</p><ul><li>在上面的案例中， 如果 bar 函数 只用了一次，后续如果我们不再使用 bar 函数了，那么该函数对象应该要被销毁掉</li><li>但是目前因为在全局作用域下 fn 变量 对 bar 函数有引用，而 bar 函数还引用这外部变量，导致内存无法被释放</li><li>因为后续我们不会用到它了，久而久之就可能造成内存泄漏</li></ul><p>如何解决内存泄漏这个问题呢？</p><p>很简单，将 <code>fn = null </code> ，fn 变量引用 bar 函数的 ”链“ 就会被断开， 这样根据 垃圾回收算法，就会把 bar 函数回收掉，即销毁掉。</p><h3 id="AO-不使用的属性"><a href="#AO-不使用的属性" class="headerlink" title="AO 不使用的属性"></a>AO 不使用的属性</h3><p>我们再来研究一个问题： 当 AO 对象不会被销毁时，里面的所有属性是否都不会被释放？</p><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">var</span> username = <span class="hljs-string">&#x27;wpf&#x27;</span>  <span class="hljs-keyword">var</span> age = <span class="hljs-number">18</span>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">debugger</span>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(username)  &#125;&#125;<span class="hljs-keyword">var</span> fn = <span class="hljs-title function_">foo</span>()<span class="hljs-title function_">fn</span>()</code></pre><p>上面这段代码中 变量 age 属于闭包父作用域里面的变量， 我们知道形式闭包之后， 变量 username 一定不会被销毁 那么 变量 age 是否会被销毁呢？</p><p>我打了个断点，可以在浏览器上看下结果：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dd9285c966c74061a264369af784f8ce~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="闭包.png"></p><p>发现 变量 age 是被销毁了的</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript高级</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript高级</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内存管理</title>
    <link href="/2021/11/04/70-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <url>/2021/11/04/70-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="JavaScript-内存管理"><a href="#JavaScript-内存管理" class="headerlink" title="JavaScript 内存管理"></a>JavaScript 内存管理</h2><blockquote><p>很喜欢一句话： 当你理解了内存，很多东西你都会理解</p></blockquote><h3 id="认识内存管理"><a href="#认识内存管理" class="headerlink" title="认识内存管理"></a>认识内存管理</h3><p>不管什么样的编程语言，在代码的执行过程中都是需要给它分配内存的，不同的是某些编程语言需要我们自己手动的管理内存，某些编程语言会可以自动帮助我们管理内存：</p><p>不管以什么样的方式来管理内存，内存的管理都会有如下的生命周期：</p><ol><li>分配申请你需要的内存（申请）；</li><li>使用分配的内存（存放一些东西，比如对象等）；</li><li>不需要使用时，对其进行释放；</li></ol><p>不同的编程语言对于第一步和第三步会有不同的实现：</p><ul><li>手动管理内存：比如 C、C++，包括早期的 OC，都是需要手动来管理内存的申请和释放的（malloc 和 free 函 数）；</li><li>自动管理内存：比如 Java、JavaScript、Python、Swift、Dart 等，它们有自动帮助我们管理内存；</li></ul><h3 id="JavaScript-的内存管理"><a href="#JavaScript-的内存管理" class="headerlink" title="JavaScript 的内存管理"></a>JavaScript 的内存管理</h3><p>JavaScript 会在定义变量时为我们分配内存。</p><p>但是内存分配方式是一样的吗？</p><ul><li>JavaScript 对于<strong>基本数据类型</strong>内存的分配会在执行时， 直接在栈空间进行分配；</li><li>JavaScript 对于<strong>复杂数据类型</strong>内存的分配会在堆内存 中开辟一块空间，并且将这块空间的指针返 回值变量<code>引用</code>；</li></ul><p>按照细分的话可以划分几大类，主要是这两大类</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2bb3bc0d363e4d06be643e7d3b9106c2~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="js内存结构.png"></p><h3 id="JavaScript-的垃圾回收"><a href="#JavaScript-的垃圾回收" class="headerlink" title="JavaScript 的垃圾回收"></a>JavaScript 的垃圾回收</h3><p>因为内存的大小是有限的，所以当内存不再需要的时候，我们需要对其进行释放，以便腾出更多的内存空间。</p><p>在手动管理内存的语言中，我们需要通过一些方式自己来释放不再需要的内存，比如 free 函数：</p><ul><li>但是这种管理的方式其实<strong>非常的低效</strong>，影响我们编写逻辑的代码的效率；</li><li>并且这种方式<strong>对开发者的要求也很高</strong>，并且一不小心就会产生内存泄露；</li></ul><p>所以大部分现代的编程语言都是有自己的垃圾回收机制：</p><ul><li>垃圾回收的英文是 <strong>Garbage Collection</strong>，简称 <strong>GC</strong>；</li><li>对于<strong>那些不再使用的对象</strong>，我们都称之为是<strong>垃圾</strong>，它需要被<strong>回收</strong>，以释放更多的内存空间；</li><li>而我们的语言运行环境，比如 Java 的运行环境 JVM，JavaScript 的运行环境 JavaScript 引擎都会内置 <strong>垃圾回收器</strong>；</li><li>垃圾回收器我们也会简称为 <strong>GC</strong>，所以在很多地方你看到 <strong>GC</strong> 其实指的是垃圾回收器；</li></ul><p>但是这里又出现了另外一个很关键的问题：GC 怎么知道哪些对象是不再使用的呢？</p><p>这里就要用到 GC 的算法了</p><h3 id="常见的-GC-算法"><a href="#常见的-GC-算法" class="headerlink" title="常见的 GC 算法"></a>常见的 GC 算法</h3><h4 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h4><p>当一个对象有一个引用指向它时，默认是 0，那么这个对象的引用就+1，当一个对象的引用为 0 时，这个对象就可以被销毁掉</p><p><strong>但是</strong>这个算法有一个很大的弊端就是会产生<strong>循环引用</strong>，这样就不会被清除了，导致内存泄漏</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/809ce776c2334af3a11df1c29b996cc6~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="引用计数.png"></p><h3 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h3><p>这个算法是设置一个根对象（root object），垃圾回收器会定期从这个根开始，找所有从根开始有引用到的对象，对 于哪些没有引用到的对象，就认为是不可用的对象</p><p>这个算法可以很好的解决循环引用的问题</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8eb09b8fcf964932886efea45814b364~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="标记清除.png"></p><p>JS 引擎比较<strong>广泛的采用</strong>的就是标记清除算法，当然类似于 V8 引擎为了进行更好的优化，它在算法的实现细节上也会结合 一些其他的算法。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript高级</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript高级</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript执行过程</title>
    <link href="/2021/11/04/69-JavaScript%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/"/>
    <url>/2021/11/04/69-JavaScript%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="JavaScript-执行过程"><a href="#JavaScript-执行过程" class="headerlink" title="JavaScript 执行过程"></a>JavaScript 执行过程</h2><p>假设有以下一段代码：</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> username = <span class="hljs-string">&#x27;wpf&#x27;</span><span class="hljs-keyword">var</span> num1 = <span class="hljs-number">1</span><span class="hljs-keyword">var</span> num2 = <span class="hljs-number">2</span><span class="hljs-keyword">var</span> sum = num1 + num2</code></pre><p>接下来，我们要以 js 引擎和内存的角度来去分析 JavaScript 的执行过程</p><h3 id="setp1-初始化全局对象"><a href="#setp1-初始化全局对象" class="headerlink" title="setp1:初始化全局对象"></a>setp1:初始化全局对象</h3><p>首先，我们先认识一下 全局对象： <code>Global Object</code></p><p>JavaScript 引擎在执行代码之前，会在堆内存中创建一个全局对象：<code>Global Object</code> 简称 <strong>GO</strong></p><ul><li>该对象 <strong>所有的作用域</strong> 都可以访问</li><li>该对象中包含有 <strong>Date、Array、String、Number、setTimerout</strong> 类和函数等</li><li>其中还有一个 <strong>window</strong> ， 而他是指向的是自己，也就是 <strong>GO</strong> （所以你打印 <code>console.log(window.window.window)</code>是会发现依然是自己）</li></ul><h3 id="step2-执行上下文栈-（调用栈）"><a href="#step2-执行上下文栈-（调用栈）" class="headerlink" title="step2: 执行上下文栈 （调用栈）"></a>step2: 执行上下文栈 （调用栈）</h3><p>JavaScript 引擎内部有一个<strong>执行上下文栈（Execution Context Stack</strong>，简称 ECS），它是用于执行代码的调用栈。</p><p>而它执行的就是 全局的代码块</p><ul><li>全局的代码块为了执行会构建一个 <strong>Global Execution Context</strong> （GEC 全局执行上下文）</li><li>GEC 会 被放入到 ECS 中执行</li></ul><p>GEC 被放入到 ECS 中包含俩部分内容：</p><ol><li>代码执行前，在 <strong>parse</strong> 转成 <strong>AST</strong> 的过程中， 会将 <strong>全局定义的变量、函数</strong>等加入到 <strong>GO</strong> 中，但是并<strong>不会赋值</strong><ul><li>这个过程也称之为 <strong>变量的作用域提示</strong> <code>hoisting</code>（ 是不是很熟悉~）</li></ul></li><li>在代码执行中，对变量赋值，或者执行其他的函数</li></ol><h4 id="图解分析："><a href="#图解分析：" class="headerlink" title="图解分析："></a>图解分析：</h4><h5 id="1-GEC-全局执行上下文中有一个-variable-object-简称-VO（变量对象），这个-VO-指向的其实就是全局对象-GO，之后编译完毕就会开始执行全局代码了"><a href="#1-GEC-全局执行上下文中有一个-variable-object-简称-VO（变量对象），这个-VO-指向的其实就是全局对象-GO，之后编译完毕就会开始执行全局代码了" class="headerlink" title="1. GEC 全局执行上下文中有一个 variable object 简称 VO（变量对象），这个 VO 指向的其实就是全局对象 GO，之后编译完毕就会开始执行全局代码了"></a>1. GEC 全局执行上下文中有一个 <strong>variable object 简称 VO（变量对象）</strong>，这个 VO 指向的其实就是全局对象 GO，之后编译完毕就会开始执行全局代码了</h5><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/202663526a994d7d984038708a4f02ee~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="image.png"></p><h5 id="2-GEC-开始执行代码"><a href="#2-GEC-开始执行代码" class="headerlink" title="2. GEC 开始执行代码"></a>2. GEC 开始执行代码</h5><pre><code class="hljs JS"><span class="hljs-keyword">var</span> username = <span class="hljs-string">&#x27;wpf&#x27;</span><span class="hljs-keyword">var</span> num1 = <span class="hljs-number">1</span><span class="hljs-keyword">var</span> num2 = <span class="hljs-number">2</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sum)<span class="hljs-keyword">var</span> sum = num1 + num2</code></pre><p>我们都知道 第四行代码 sum 是 undefined ， 也知道因为是作用域提升， 那么为什么会提升呢？ 接下俩就看看这段代码是如何执行的</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4cd32cd5b30745da9649e7efdefbeeb6~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="image.png"></p><p>那接下来真正开始执行了</p><p>代码是从上到下一行一行开始执行的，<strong>开始： username 从 undefined =&gt; ‘wpf’，num1 从 undefined =&gt; 1，num2 从 undefined =&gt; 2，打印 sum 变量，GO 中有 sum 是 undefined，所以打印出来的 sum 是 undefined，然后 result 被赋值为： 1+2 = 3</strong></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/187a4ea1ec2c4c19b35e0c9b81cef0e1~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="image.png"></p><p><strong>Q1: 如果遇到函数怎么办呢？</strong></p><p>在执行的过程中执行到一个函数时，就会根据函数体创建一个<strong>函数执行上下文（Functional Execution Context，</strong><br><strong>简称 FEC）</strong>，并且压入到 EC Stack 中。</p><p>FEC 中包含三部分内容：</p><ol><li>在解析函数成为 AST 树结构时，会创建一个 Activation Object（AO ）：AO 中包含形参、arguments、函数定义和指向函数对象、定义的变量；</li><li>作用域链：由 VO（在函数中就是 AO 对象）和父级 VO 组成，查找时会一层层查找；</li><li>this 绑定的值：关于这个知识点，后续我再专门写一篇；</li></ol><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/43de3bc656504186bb053746ac443dd6~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="image.png"></p><p>当我们创建了一个函数的时候，堆内存中就会创建一个函数对象来存储，函数对象中存储着很多东西，这里我就选两个比较重要的</p><ul><li>一个叫做 parent scope（父级作用域）</li><li>一个是函数的执行体</li></ul><p>执行函数前也会有一个解析：VO 指向的是一个叫做 AO 的活跃对象，那么真正执行函数前会在堆内存就会创建一个叫做当前函数的 AO 对象，然后会解析函数内的代码，</p><p>用以下代码为例：</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> bar = <span class="hljs-number">111</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">var</span> bar = <span class="hljs-number">123</span>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(age)&#125;<span class="hljs-title function_">foo</span>()</code></pre><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f8f7f3b50b0147ad9b1bd53f49e6403b~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="image.png"></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/92b2ab08e87d4e7e9b4098ef6ac94ad5~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="image.png"></p><p>当执行函数的时候遇到对变量进行操作的时候，这个时候函数 VO 中会有一个作用域链：当前 VO+parent scope 父级作用域进行查找，如果父级作用域也没有找到，就会一层一层往上找，直到在全局 GO 中还没有找到就会报错</p><p>当函数执行完毕之后，函数执行上下文 FEC 会弹出栈，也就是销毁了，那么函数的 VO 指向的 AO 这条线是不是也应该没有了</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e05dbc262d204d1491c4f6a44a1bbe93~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="image.png"></p><h3 id="经典面试题"><a href="#经典面试题" class="headerlink" title="经典面试题"></a>经典面试题</h3><blockquote><p>有句话说得好： 了解真相才能获得真正的自由</p></blockquote><p><strong>Q1:</strong></p><pre><code class="hljs js"><span class="hljs-keyword">var</span> n = <span class="hljs-number">100</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;  n = <span class="hljs-number">200</span>&#125;<span class="hljs-title function_">foo</span>()<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(n)</code></pre><p><strong>A1:</strong> 200</p><p><strong>Q2:</strong></p><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(n)  <span class="hljs-keyword">var</span> n = <span class="hljs-number">200</span>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(n)&#125;<span class="hljs-keyword">var</span> n = <span class="hljs-number">100</span><span class="hljs-title function_">foo</span>()</code></pre><p><strong>A2:</strong> undefined 200</p><p><strong>Q3:</strong></p><pre><code class="hljs js"><span class="hljs-keyword">var</span> n = <span class="hljs-number">100</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo1</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(n) <span class="hljs-comment">// 100</span>&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">foo2</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">var</span> n = <span class="hljs-number">200</span>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(n) <span class="hljs-comment">// 200</span>  <span class="hljs-title function_">foo1</span>()&#125;<span class="hljs-title function_">foo2</span>()<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(n) <span class="hljs-comment">// 100</span></code></pre><p><strong>A3:</strong> 200 100 100</p><p><strong>Q4:</strong></p><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">100</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)  <span class="hljs-keyword">return</span>  <span class="hljs-keyword">var</span> a = <span class="hljs-number">100</span>&#125;<span class="hljs-title function_">foo</span>()</code></pre><p><strong>A4:</strong> undefined</p><p><strong>Q5:</strong></p><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">var</span> a = (b = <span class="hljs-number">100</span>) <span class="hljs-comment">//  ==&gt;  var a =100; b =100</span>&#125;<span class="hljs-title function_">foo</span>()<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b)</code></pre><p><strong>A5:</strong> 报错 （如果把 console.log(a) 注释掉 那么 会打印 100）</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript高级</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript高级</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器运行原理</title>
    <link href="/2021/11/04/68-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/"/>
    <url>/2021/11/04/68-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="认识浏览器工作原理"><a href="#认识浏览器工作原理" class="headerlink" title="认识浏览器工作原理"></a>认识浏览器工作原理</h2><p><strong>先考虑一个常见的问题：页面输入 url 到页面渲染，发生了什么？</strong></p><ul><li>比如我输入一个 baidu.com 然后敲下回车</li><li>浏览器会通过 DNS 服务器，将 url 解析为 IP 地址</li><li>会通过 IP 地址，找到相应的服务器，建立 TCP 连接，（就是三次握手），向服务器发送 http 请求</li><li>服务器接收请求，返回 http 报文、浏览器接收后，得到 html 代码</li><li><strong>浏览器解析 html 代码</strong>，并请求 html 代码中的资源 （比如遇到 link 标签，浏览器就会去服务器上下载对应的 css 文件，遇到 script 标签就会去服务器上下载对应的 js 文件）</li><li>渲染页面给用户</li><li>服务器断开 TCP 连接 （四次挥手）</li></ul><p>而其中 <strong>浏览器解析 html 代码</strong> 就是通过浏览器内核来进行解析的</p><h3 id="浏览器解析-html-代码的过程"><a href="#浏览器解析-html-代码的过程" class="headerlink" title="浏览器解析 html 代码的过程"></a>浏览器解析 html 代码的过程</h3><p>图解：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5bd55a4f288495b88245fa9ef4dbbb0~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="浏览器解析html代码的过程.png"></p><h3 id="浏览器的内核"><a href="#浏览器的内核" class="headerlink" title="浏览器的内核"></a>浏览器的内核</h3><blockquote><p>浏览器内核指的是浏览器的排版引擎</p><p>排版引擎（layout engine），也称为浏览器引擎（browser engine）、页面渲染引擎（rendering engine）<br>或样版引擎。</p></blockquote><p>不同的浏览器有不同的内核：</p><ul><li><strong>Gecko</strong>：早期被 Netscape 和 Mozilla Firefox 浏览器浏览器使用</li><li><strong>pTrident</strong>：微软开发，被<code>IE4~IE11</code>浏览器使用，但是 Edge 浏览器已经转向 Blink</li><li><strong>pWebkit</strong>：苹果基于<code>KHTML</code>开发、开源的，用于<code>Safari，Google Chrome</code>之前也在使用</li><li><strong>pBlink</strong>：是<code>Webkit</code>的一个分支，Google 开发，目前应用于 Google Chrome、Edge、Opera 等</li></ul><h3 id="浏览器渲染过程"><a href="#浏览器渲染过程" class="headerlink" title="浏览器渲染过程"></a>浏览器渲染过程</h3><p>图解：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b0a2dec88c0641b9b380d8861b789ac7~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="浏览器渲染过程.png"></p><p>分析：</p><ol><li>首先 HTML（很多很多的标签）， 把很多的标签转换成对应的 <code>HTML Parser</code> , 然后形成 DOM 树</li><li>style 样式标签会转换成 <code>CSS Parse</code> 然后形成 style 规则</li><li>之后，DOM 树和 style 规则 会结合一起形成 <code> Render Tree</code> 渲染树，<ol><li>这时会有 layout （布局）， 作用就是： 当浏览器发生变化时会展示不同的效果</li></ol></li><li>最后生成 <code> Render Tree</code> 渲染树会进行绘制，将其展示在浏览器上</li></ol><p>疑问：</p><p>Q1: JavaScript 代码在哪里执行呢？</p><p>A1: 在形成 DOM 树时， 有时候我们会对 DOM 进行操作，这时候就会遇到 JavaScript 代码</p><p>Q2: 谁来执行 JavaScript 代码？</p><p>A2: 因为 CPU 不认识 JavaScript ，所以是用过 JavaScript 引擎来执行的</p><h2 id="认识-JavaScript-引擎"><a href="#认识-JavaScript-引擎" class="headerlink" title="认识 JavaScript 引擎"></a>认识 JavaScript 引擎</h2><p>为什么需要 JavaScript 引擎</p><ul><li>高级的编程语言都是需要转成最终的机器指令来执行的；</li><li>事实上我们编写的 JavaScript 无论你交给浏览器或者 Node 执行，最后都是需要被 CPU 执行的；</li><li>但是 CPU 只认识自己的指令集，实际上是机器语言，才能被 CPU 所执行；</li><li>所以我们需要 JavaScript 引擎帮助我们将 JavaScript 代码翻译成 CPU 指令来执行；</li></ul><h3 id="常见的-JavaScript-引擎"><a href="#常见的-JavaScript-引擎" class="headerlink" title="常见的 JavaScript 引擎"></a>常见的 JavaScript 引擎</h3><ul><li><code>SpiderMonkey</code>：第一款 JavaScript 引擎，由 Brendan Eich 开发（也就是 JavaScript 作者）；</li><li><code>Chakra</code>：微软开发，用于 IE 浏览器；</li><li><code>JavaScriptCore</code>：WebKit 中的 JavaScript 引擎，Apple 公司开发；</li><li><code>V8</code>：Google 开发的强大 JavaScript 引擎，也帮助 Chrome 从众多浏览器中脱颖而出；</li></ul><h3 id="V8-引擎"><a href="#V8-引擎" class="headerlink" title="V8 引擎"></a>V8 引擎</h3><p>我们来看一下官方对 V8 引擎的定义：</p><ul><li>V8 是用 <code>C ++</code>编写的 <code>Google</code> 开源高性能 JavaScript 和 WebAssembly 引擎，它用于 Chrome 和 Node.js 等。</li><li>它实现 ECMAScript 和 WebAssembly，并在 Windows 7 或更高版本，macOS 10.12+和使用 x64，IA-32， ARM 或 MIPS 处理器的 Linux 系统上运行。</li><li>V8 可以独立运行，也可以嵌入到任何 C ++应用程序中。</li></ul><h4 id="V8-引擎架构"><a href="#V8-引擎架构" class="headerlink" title="V8 引擎架构"></a>V8 引擎架构</h4><p>V8 引擎本身的源码<strong>非常复杂</strong>，大概有超过 100w 行 C++代码，通过了解它的架构，我们可以知道它是如何对 JavaScript 执行的：</p><p><code>Parse</code>模块会将 JavaScript 代码转换成 AST（抽象语法树），这是因为解释器并不直接认识 JavaScript 代码；</p><ul><li>如果函数没有被调用，那么是不会被转换成 AST 的；</li><li>Parse 的 V8 官方文档：<a href="https://v8.dev/blog/scanner">https://v8.dev/blog/scanner</a></li></ul><p><code>Ignition</code> 是一个解释器，会将 AST 转换成 ByteCode（字节码）</p><ul><li>同时会收集 TurboFan 优化所需要的信息（比如函数参数的类型信息，有了类型才能进行真实的运算）；</li><li>如果函数只调用一次，Ignition 会执行解释执行 ByteCode；</li><li>Ignition 的 V8 官方文档：<a href="https://v8.dev/blog/ignition-interpreter">https://v8.dev/blog/ignition-interpreter</a></li></ul><p><code>TurboFan</code> 是一个编译器，可以将字节码编译为 CPU 可以直接执行的机器码；</p><ul><li>如果一个函数被多次调用，那么就会被标记为热点函数，那么就会经过 TurboFan 转换成优化的机器码，提高代码的执行性能；</li><li>但是，机器码实际上也会被还原为 ByteCode，这是因为如果后续执行函数的过程中，类型发生了变化（比如 sum 函数原来执行的是 number 类型，后来执行变成了 string 类型），之前优化的机器码并不能正确的处理运算，就会逆向的转换成字节码(反向优化)；</li><li>TurboFan 的 V8 官方文档：<a href="https://v8.dev/blog/turbofan-jit">https://v8.dev/blog/turbofan-jit</a></li></ul><h4 id="V8-执行细节"><a href="#V8-执行细节" class="headerlink" title="V8 执行细节"></a>V8 执行细节</h4><p>那么我们的 JavaScript 源码是如何被解析（Parse 过程）的呢？</p><p>Blink 将源码交给 V8 引擎，Stream 获取到源码并且进行编码转换；</p><p>Scanner 会进行词法分析（lexical analysis），词法分析会将代码转换成 tokens；</p><p>接下来 tokens 会被转换成 AST 树，经过 Parser 和 PreParser：</p><ul><li>Parser 就是直接将 tokens 转成 AST 树架构；</li><li>PreParser 称之为预解析，为什么需要预解析呢？<ul><li>这是因为并不是所有的 JavaScript 代码，在一开始时就会被执行。那么对所有的 JavaScript 代码进行解析，必然会 影响网页的运行效率；</li><li>所以 V8 引擎就实现了 Lazy Parsing（延迟解析）的方案，它的作用是将不必要的函数进行预解析，也就是只解析暂时需要的内容，而对函数的全量解析是在函数被调用时才会进行；</li><li>比如我们在一个函数 outer 内部定义了另外一个函数 inner，那么 inner 函数就会进行预解析；</li></ul></li><li>生成 AST 树后，会被 Ignition 转成字节码（bytecode），之后的过程就是代码的执行过程（后续会详细分析）。</li></ul>]]></content>
    
    
    <categories>
      
      <category>JavaScript高级</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript高级</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何正确的在vue3中使用vuex的辅助函数</title>
    <link href="/2021/08/23/67-Vue3%E4%B8%AD%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0%E7%9A%84%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8/"/>
    <url>/2021/08/23/67-Vue3%E4%B8%AD%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0%E7%9A%84%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在实际开发中，我们经常会用到 <code>vuex</code> 来对数据进行管理，随着数据越来越多，我们逐渐开始使用一些语法糖来帮助我们快速开发。 即 vuex 中的 <code>mapState、mapGetters、mapMutations、mapActions </code>等辅助函数是我们经常使用到的。</p><h2 id="辅助函数的使用"><a href="#辅助函数的使用" class="headerlink" title="辅助函数的使用"></a>辅助函数的使用</h2><p>在vue2中我们可以通过 options API 在 computed 中来使用 mapState，</p><pre><code class="hljs js"><span class="hljs-attr">computed</span>: <span class="hljs-title function_">mapsState</span>([<span class="hljs-string">&#x27;name&#x27;</span>,<span class="hljs-string">&#x27;age&#x27;</span>])</code></pre><p>在 vue3 中主要是使用 setup 来进行操作时，一般来使用vuex中数据是这样操作的，通过 useStore 这个钩子来得到</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; useStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span><span class="hljs-keyword">import</span> &#123; computed &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">const</span> store = <span class="hljs-title function_">useStore</span>()  <span class="hljs-keyword">const</span> name = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> store.<span class="hljs-property">state</span>.<span class="hljs-property">name</span>)  <span class="hljs-keyword">const</span> age = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> store.<span class="hljs-property">state</span>.<span class="hljs-property">age</span>)  <span class="hljs-keyword">return</span> &#123;    name, age  &#125;&#125;,</code></pre><p>这样的不足是如果数据多了，那么写起来就尤为麻烦，所以我们想到了辅助函数 mapState 来解决。<br>但是呢，vuex 官方并没有例子来说明如何在setup中去使用辅助函数 mapState。 所以我就尝试着以vue2的形式来写：</p><pre><code class="hljs js"><span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">const</span> stateStore = <span class="hljs-title function_">mapState</span>([<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>])  <span class="hljs-keyword">return</span> &#123;    ...stateStore  &#125;&#125;,</code></pre><p>但显示到浏览器的结果却发现是这样子的：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/295e4ad6a59948a3a74474e75e530434~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="mapState.png"></p><p>为什么会返回出函数呢？</p><h2 id="为什么在setup中使用mapState会返回函数？"><a href="#为什么在setup中使用mapState会返回函数？" class="headerlink" title="为什么在setup中使用mapState会返回函数？"></a>为什么在setup中使用mapState会返回函数？</h2><p>我试着去看了一下 mapState 的源码，发现是通过 <code>this.$store</code> 来拿到 store 的值的</p><p>然而在 setup 中是取不到 <strong>this</strong> 的</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6a6e8171d8ad44698dc5b07e282a69d7~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="mapState源码.png"></p><p>其他的辅助函数（mapGetters、mapMutations、mapActions） 同样都是这样类似的处理的。<br>所以通过上面的源码，我们知道：辅助函数就是会返回一个对象，而 key 是字符串， val就是<strong>函数</strong>，<br>类似于：</p><pre><code class="hljs js"><span class="hljs-attr">computed</span>:&#123;    ...<span class="hljs-title function_">mapState</span>([<span class="hljs-string">&#x27;name&#x27;</span>,<span class="hljs-string">&#x27;age&#x27;</span>])&#125;<span class="hljs-comment">// 转换为了：</span>&#123;     <span class="hljs-attr">name</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125;,    <span class="hljs-attr">age</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125;&#125;</code></pre><p>所以就明白了为什么在上述的代码中为什么会返回一个函数了。</p><h2 id="封装一个-useState-函数"><a href="#封装一个-useState-函数" class="headerlink" title="封装一个 useState 函数"></a>封装一个 useState 函数</h2><p>明白了其原理后，我们就知道了在 computed 中可以使用mapState， <strong>是因为 computed 本身就是一个函数，它会接收一个函数作为参数。</strong> 我们也知道了辅助函数是 被解析成了一个对象，对象中的属性值是函数。</p><p><strong>那么我们是不是可以试着把这俩个结合起来去封装一个hooks来使用了？</strong></p><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; useStore, mapState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span><span class="hljs-keyword">import</span> &#123; computed &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><span class="hljs-keyword">const</span> useState = <span class="hljs-keyword">function</span>(<span class="hljs-params">mapper</span>) &#123;    <span class="hljs-comment">// mapper： Array | Object</span>    <span class="hljs-keyword">const</span> store = <span class="hljs-title function_">useStore</span>()        <span class="hljs-comment">//使用辅助函数解析成一个对象</span>    <span class="hljs-keyword">const</span> storeStateFns = <span class="hljs-title function_">mapState</span>(mapper)    <span class="hljs-keyword">const</span> storeState = &#123;&#125;        <span class="hljs-comment">//通过Object.keys拿到对象的所有key值，遍历，取出对应的value值，也就是函数</span>    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(storeStateFns).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;        <span class="hljs-comment">// 这我们知道辅助函数的内部是通过this.$store来实现的</span>        <span class="hljs-comment">// setup中没有this， 所以通过bind来改变this的指向</span>        <span class="hljs-keyword">const</span> fn = storeStateFns[item].<span class="hljs-title function_">bind</span>(&#123;$store, store&#125;)        <span class="hljs-comment">//拿到函数，作为计算属性的参数，最后在留在一个对象中</span>        storeState[item] = <span class="hljs-title function_">computed</span>(fn)    &#125;)        <span class="hljs-comment">// storeState是一个对象， key是字符串， value值是ref对象</span>    <span class="hljs-keyword">return</span> storeState&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> useState</code></pre><p>然后在组件中就这样使用：</p><pre><code class="hljs js"><span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">const</span> stateStore = <span class="hljs-title function_">useState</span>([<span class="hljs-string">&#x27;name&#x27;</span>,<span class="hljs-string">&#x27;age&#x27;</span>]) <span class="hljs-comment">// 使用对象的形式也行</span>    <span class="hljs-keyword">return</span> &#123;        ...stateStore    &#125;&#125;</code></pre><p>这样就可以在setup中使用辅助函数啦，又可以少些代码了多开心哈~</p><h2 id="封装一个-useMapper-函数"><a href="#封装一个-useMapper-函数" class="headerlink" title="封装一个 useMapper 函数"></a>封装一个 useMapper 函数</h2><p>同样的， 不止是 mapState， <strong>mapGetters</strong> 也是根据相同的思路来进行封装的，所以就稍加改造。如下：</p><pre><code class="hljs js"><span class="hljs-comment">// hooks/useMapper.js</span><span class="hljs-keyword">import</span> &#123; computed &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><span class="hljs-keyword">import</span> &#123; mapGetters, mapState, useStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span><span class="hljs-keyword">const</span> <span class="hljs-title function_">useMapper</span> = (<span class="hljs-params">mapper, mapFn</span>) =&gt; &#123;  <span class="hljs-keyword">const</span> store = <span class="hljs-title function_">useStore</span>()  <span class="hljs-keyword">const</span> storeStateFns = <span class="hljs-title function_">mapFn</span>(mapper)  <span class="hljs-keyword">const</span> storeState = &#123;&#125;  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(storeStateFns).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">keyFn</span>) =&gt;</span> &#123;    <span class="hljs-keyword">const</span> fn = storeStateFns[keyFn].<span class="hljs-title function_">bind</span>(&#123; <span class="hljs-attr">$store</span>: store &#125;)    storeState[keyFn] = <span class="hljs-title function_">computed</span>(fn)  &#125;)  <span class="hljs-keyword">return</span> storeState&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">useState</span> = (<span class="hljs-params"> mapper</span>) =&gt; &#123;  <span class="hljs-keyword">return</span> <span class="hljs-title function_">useMapper</span>(mapper, mapState)&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">useGetters</span> = (<span class="hljs-params">mapper</span>) =&gt; &#123;  <span class="hljs-keyword">return</span> <span class="hljs-title function_">useMapper</span>(mapper, mapGetters)&#125;</code></pre><p>然后就这样的使用：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/56efe7485c0a4d16af5adf371e6ec72b~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="示例.png"></p><p><strong>关于 mapMutations、mapActions 是不用进行封装的，原因可以自己想想</strong></p><p>其实哈，使用mutaiton和actions中本来就是去调用方法的，所以直接就是跟辅助函数的属性值挂钩。</p><h2 id="模块化情况下的考虑"><a href="#模块化情况下的考虑" class="headerlink" title="模块化情况下的考虑"></a>模块化情况下的考虑</h2><p>刚刚封装的 useMapper 是没有考虑到模块化的， 在开发时，随着数据的种类越来越多，使用 modules 是不可避免的，所以我们需要对刚刚的 useMapper 进行一下 模块化边缘的处理</p><p>如下：<br>我们需要借助vuex提供的<strong>createNamespacedHelpers</strong>函数来得到模块中的属性</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; computed &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><span class="hljs-keyword">import</span> &#123; mapGetters, mapState, useStore, createNamespacedHelpers &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span><span class="hljs-keyword">const</span> <span class="hljs-title function_">useMapper</span> = (<span class="hljs-params">mapper, mapFn</span>) =&gt; &#123;  <span class="hljs-keyword">const</span> store = <span class="hljs-title function_">useStore</span>()  <span class="hljs-keyword">const</span> storeStateFns = <span class="hljs-title function_">mapFn</span>(mapper)  <span class="hljs-keyword">const</span> storeState = &#123;&#125;  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(storeStateFns).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">keyFn</span>) =&gt;</span> &#123;    <span class="hljs-keyword">const</span> fn = storeStateFns[keyFn].<span class="hljs-title function_">bind</span>(&#123; <span class="hljs-attr">$store</span>: store &#125;)    storeState[keyFn] = <span class="hljs-title function_">computed</span>(fn)  &#125;)  <span class="hljs-keyword">return</span> storeState&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">useState</span> = (<span class="hljs-params">moduleName, mapper</span>) =&gt; &#123;  <span class="hljs-keyword">let</span> mapperFn = mapState  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> moduleName === <span class="hljs-string">&#x27;string&#x27;</span> &amp;&amp; moduleName.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) &#123;    mapperFn = <span class="hljs-title function_">createNamespacedHelpers</span>(moduleName).<span class="hljs-property">mapState</span>  &#125; <span class="hljs-keyword">else</span> &#123;    mapper = moduleName  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-title function_">useMapper</span>(mapper, mapperFn)&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">useGetters</span> = (<span class="hljs-params">moduleName, mapper</span>) =&gt; &#123;  <span class="hljs-keyword">let</span> mapperFn = mapGetters  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> moduleName === <span class="hljs-string">&#x27;string&#x27;</span> &amp;&amp; moduleName.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) &#123;    mapperFn = <span class="hljs-title function_">createNamespacedHelpers</span>(moduleName).<span class="hljs-property">mapGetters</span>  &#125; <span class="hljs-keyword">else</span> &#123;    mapper = moduleName  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-title function_">useMapper</span>(mapper, mapperFn)&#125;</code></pre><p>使用：</p><pre><code class="hljs js"><span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>)&#123;  <span class="hljs-keyword">const</span> storeState = <span class="hljs-title function_">useState</span>([<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-string">&#x27;six&#x27;</span>])  <span class="hljs-keyword">const</span> storeGetters = <span class="hljs-title function_">useGetters</span>([<span class="hljs-string">&#x27;counter&#x27;</span>])  <span class="hljs-keyword">const</span> homeState = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;home&#x27;</span>, [<span class="hljs-string">&#x27;homeCounter&#x27;</span>])  <span class="hljs-keyword">return</span> &#123;    ...storeState,    ...storeGetters,    ...homeState  &#125;&#125;</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在vue2中习惯了使用辅助函数，但是在vuex文档中没有找到在vue3内如何使用辅助函数，然后一直去使用 computed 来去包裹 store 来获取值，随着数据的增多，使用起来也很麻烦，所以就封装了这样一个函数来提高开发效率。</p>]]></content>
    
    
    <categories>
      
      <category>Vue.js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实现一个简洁版的Mini-Vue</title>
    <link href="/2021/08/13/66-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAmini-vue/"/>
    <url>/2021/08/13/66-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAmini-vue/</url>
    
    <content type="html"><![CDATA[<p>实现一个简洁版 Mini-Vue</p><h2 id="Vue-三大核心系统"><a href="#Vue-三大核心系统" class="headerlink" title="Vue 三大核心系统"></a>Vue 三大核心系统</h2><p>Vue源码包含三大核心：</p><ol><li>Compiler模块： 编译模板系统</li><li>Runtime模块： 也可以称为Renderer模块，真正渲染的模块</li><li>Reactivity模块： 响应式系统</li></ol><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/142c2d19851a4e9aa327bfd3d7d8978d~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="三大模块系统.png"></p><h2 id="Mini-Vue"><a href="#Mini-Vue" class="headerlink" title="Mini-Vue"></a>Mini-Vue</h2><p>实现一个简洁版的 Mini-Vue， 包含三个模块：</p><ul><li>渲染系统模块</li><li>可响应式系统模块</li><li>应用程序入口模块</li></ul><h3 id="渲染系统模块"><a href="#渲染系统模块" class="headerlink" title="渲染系统模块"></a>渲染系统模块</h3><h4 id="虚拟DOM的优势"><a href="#虚拟DOM的优势" class="headerlink" title="虚拟DOM的优势"></a>虚拟DOM的优势</h4><p>在传统的前端开发中，我们编写自己的HTML，最终被渲染到浏览器上。</p><p>而目前框架都会引入虚拟DOM来对真实的DOM进行抽象，这样做有很多的好处</p><ol><li>首先是可以对真实的元素节点进行抽象，抽象成VNode（虚拟节点），这样方便后续对其进行操作<ol><li>因为对于直接操作DOM来说是有很多限制的，比如diff、clone等等，但是使用js来操作这些就会变得简单</li><li>可以使用js来表达非常多的逻辑，而对于DOM本身来说是非常不方便的</li></ol></li><li>其次是方便实现跨平台，包括你可以将VNode节点渲染成任意你想要的节点<ol><li>比如渲染在WebGL，SSR，Native（ios，Android）上等等</li><li>并且Vue允许你开发属于自己的渲染器（renderer），在其他的平台上渲染</li></ol></li></ol><h2 id="渲染系统的实现"><a href="#渲染系统的实现" class="headerlink" title="渲染系统的实现"></a>渲染系统的实现</h2><p>该模块主要包含三个功能：</p><ol><li><p><strong>h 函数：</strong>用于返回一个VNode对象</p></li><li><p><strong>mount函数：</strong> 用于将VNode挂载在DOM上</p></li><li><p><strong>patch函数：</strong> 用于俩个VNode进行对比，判断如何处理新的VNode</p></li></ol><h3 id="h-函数的实现"><a href="#h-函数的实现" class="headerlink" title="h 函数的实现"></a>h 函数的实现</h3><blockquote><p>h函数的作用就是 生成VNode， 而vnode本质上是一个JavaScript对象</p></blockquote><p>实现一个<strong>h 函数</strong>很简单，直接返回一个VNode对象即可</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">h</span> = (<span class="hljs-params">tag, props, children</span>) =&gt; &#123;  <span class="hljs-keyword">return</span> &#123;    tag,    props,    children  &#125;&#125;</code></pre><h3 id="mount-函数的实现"><a href="#mount-函数的实现" class="headerlink" title="mount 函数的实现"></a>mount 函数的实现</h3><blockquote><p>mount 函数的作用就是 挂载VNode， 将vnode挂载DOM元素上并显示在浏览器上</p></blockquote><p>实现思路：</p><ol><li><p>根据 tag ， 创建HTML元素，并且存到 vnode的el中 （目前只考虑 标签 ，不考虑组件）</p></li><li><p>处理 props 属性 （目前只考虑俩种情况）</p><ol><li>如果以 on 开头，那么就是监听事件</li><li>如果是普通属性直接通过 setAttribute 添加即可</li></ol></li><li><p>处理子节点（只考虑俩种情况：字符串和数组）</p><ol><li>如果是 字符串， 那么就直接设置 textContent</li><li>如果数组，那么就遍历中调用 mount 函数</li></ol></li></ol><p>代码如下：</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">h</span> = (<span class="hljs-params">tag, props, children</span>) =&gt; &#123;  <span class="hljs-keyword">return</span> &#123;    tag,    props,    children  &#125;&#125;<span class="hljs-keyword">const</span> <span class="hljs-title function_">mount</span> = (<span class="hljs-params">vnode, container</span>) =&gt; &#123;  <span class="hljs-comment">// 1. 创建 html 元素</span>  <span class="hljs-keyword">const</span> el = vnode.<span class="hljs-property">el</span> = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(vnode.<span class="hljs-property">tag</span>)  <span class="hljs-comment">// 2. 处理 props属性</span>  <span class="hljs-keyword">if</span> (vnode.<span class="hljs-property">props</span>) &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> vnode.<span class="hljs-property">props</span>) &#123;      <span class="hljs-keyword">if</span> (!vnode.<span class="hljs-property">props</span>.<span class="hljs-title function_">hasOwnProperty</span>(key)) &#123;<span class="hljs-keyword">return</span>&#125;      <span class="hljs-keyword">const</span> value = vnode.<span class="hljs-property">props</span>[key]      <span class="hljs-keyword">if</span> (key.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&#x27;on&#x27;</span>)) &#123;        el.<span class="hljs-title function_">addEventListener</span>(key.<span class="hljs-title function_">slice</span>(<span class="hljs-number">2</span>).<span class="hljs-title function_">toLowerCase</span>(), value)      &#125; <span class="hljs-keyword">else</span> &#123;        el.<span class="hljs-title function_">setAttribute</span>(key, value)      &#125;    &#125;  &#125;  <span class="hljs-comment">// 3. 处理子节点</span>  <span class="hljs-keyword">if</span> (vnode.<span class="hljs-property">children</span>) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> vnode.<span class="hljs-property">children</span> === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;      el.<span class="hljs-property">textContent</span> = vnode.<span class="hljs-property">children</span>    &#125; <span class="hljs-keyword">else</span> &#123;      vnode.<span class="hljs-property">children</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;        <span class="hljs-title function_">mount</span>(item, el)      &#125;)    &#125;  &#125;  container.<span class="hljs-title function_">appendChild</span>(el)&#125;</code></pre><p>这样就能实现简单的渲染啦~</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;renderer.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">  <span class="hljs-keyword">const</span> vnode = <span class="hljs-title function_">h</span>(<span class="hljs-string">&#x27;div&#x27;</span>, &#123; <span class="hljs-attr">class</span>: <span class="hljs-string">&#x27;wangpf&#x27;</span> &#125;, [</span><span class="language-javascript">    <span class="hljs-title function_">h</span>(<span class="hljs-string">&#x27;h2&#x27;</span>, &#123; <span class="hljs-attr">class</span>: <span class="hljs-string">&#x27;title&#x27;</span> &#125;, <span class="hljs-string">&#x27;hello,I am wangpf&#x27;</span>),</span><span class="language-javascript">    <span class="hljs-title function_">h</span>(<span class="hljs-string">&#x27;div&#x27;</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">&#x27;当前计数：100&#x27;</span>),</span><span class="language-javascript">    <span class="hljs-title function_">h</span>(<span class="hljs-string">&#x27;button&#x27;</span>, &#123; <span class="hljs-attr">class</span>: <span class="hljs-string">&#x27;btn&#x27;</span> &#125;, <span class="hljs-string">&#x27;+1&#x27;</span>)</span><span class="language-javascript">  ])</span><span class="language-javascript">  </span><span class="language-javascript">  <span class="hljs-title function_">mount</span>(vnode, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#app&#x27;</span>))</span><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8566def27dbf48908cf54d3acc0773c9~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="test"></p><h3 id="patch-函数"><a href="#patch-函数" class="headerlink" title="patch 函数"></a>patch 函数</h3><blockquote><p>patch 函数作用就是 对比俩个新旧vnode，将不同的给替换掉，运用到了 diff 。</p></blockquote><p>对 patch 函数的实现，分为俩种情况 （n1为旧的vnode，n2为新的vnode）</p><ul><li>n1 和 n2 是不同类型的节点 （删除n1，挂载n2）<ul><li>找到 n1 的 el 父节点，删除原来 n1 节点的el</li><li>挂载 n2 节点 到 n1的el父节点上</li></ul></li><li>n1 和 n2 是相同的节点<ul><li>处理 props 的情况<ul><li>先将新节点的 props 全部挂载到 el 上</li><li>判断旧节点的 props 是否不需要在新节点上， 如果不需要，那么删除对应的属性</li></ul></li><li>处理 children 的情况<ul><li>如果新阶段是一个字符串类型，那么直接替换</li><li>如果新节点是不同一个字符串类型<ul><li>旧节点是一个字符串类型<ul><li>将el 内容 设为 空字符串</li><li>遍历新节点，挂载到el上</li></ul></li><li>旧节点是一个数组类型<ul><li>取出数组最小长度</li><li>遍历所有节点，新节点和旧节点进行 patch 操作</li><li>如果新节点长度大于旧节点，那么剩余的新节点就挂载</li><li>如果旧节点长度大于新节点，那么剩余的旧节点就卸载</li></ul></li></ul></li></ul></li></ul></li></ul><p>代码实现：</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">patch</span> = (<span class="hljs-params">n1, n2</span>) =&gt; &#123;  <span class="hljs-keyword">if</span> (n1.<span class="hljs-property">tag</span> !== n2.<span class="hljs-property">tag</span>) &#123;    <span class="hljs-keyword">const</span> n1ElParent = n1.<span class="hljs-property">el</span>.<span class="hljs-property">parentElement</span>    n1ElParent.<span class="hljs-title function_">removeChild</span>(n1.<span class="hljs-property">el</span>)    <span class="hljs-title function_">mount</span>(n2, n1ElParent)  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">// 1.取出 element对象，并且在 n2中进行保存</span>    <span class="hljs-keyword">const</span> el = n2.<span class="hljs-property">el</span> = n1.<span class="hljs-property">el</span>    <span class="hljs-comment">// 2. 处理 props</span>    <span class="hljs-keyword">const</span> oldProps = n1.<span class="hljs-property">props</span> || &#123;&#125;    <span class="hljs-keyword">const</span> newProps = n2.<span class="hljs-property">props</span> || &#123;&#125;    <span class="hljs-comment">// 2.1 获取所有的 newProps 添加到 el</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> newProps) &#123;      <span class="hljs-keyword">if</span> (!newProps.<span class="hljs-title function_">hasOwnProperty</span>(key)) &#123;<span class="hljs-keyword">return</span>&#125;      <span class="hljs-keyword">const</span> oldValue = oldProps[key]      <span class="hljs-keyword">const</span> newValue = newProps[key]      <span class="hljs-keyword">if</span> (oldValue !== newValue) &#123;        <span class="hljs-keyword">if</span> (key.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&#x27;on&#x27;</span>)) &#123;          el.<span class="hljs-title function_">addEventListener</span>(key.<span class="hljs-title function_">slice</span>(<span class="hljs-number">2</span>).<span class="hljs-title function_">toLowerCase</span>(), newValue)        &#125; <span class="hljs-keyword">else</span> &#123;          el.<span class="hljs-title function_">setAttribute</span>(key, newValue)        &#125;      &#125;    &#125;    <span class="hljs-comment">// 2.2 删除旧的props</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> oldProps) &#123;      <span class="hljs-keyword">if</span> (!newProps.<span class="hljs-title function_">hasOwnProperty</span>(key)) &#123;<span class="hljs-keyword">return</span>&#125;      <span class="hljs-keyword">if</span> (key.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&#x27;on&#x27;</span>)) &#123;        el.<span class="hljs-title function_">removeEventListener</span>(key.<span class="hljs-title function_">slice</span>(<span class="hljs-number">2</span>).<span class="hljs-title function_">toLowerCase</span>())      &#125;      <span class="hljs-keyword">if</span> (!(key <span class="hljs-keyword">in</span> newProps)) &#123;        el.<span class="hljs-title function_">removeAttribute</span>(key)      &#125;    &#125;    <span class="hljs-comment">// 3. 处理 children</span>    <span class="hljs-keyword">const</span> oldChildren = n1.<span class="hljs-property">children</span> || []    <span class="hljs-keyword">const</span> newChildren = n2.<span class="hljs-property">children</span> || []    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> newChildren === <span class="hljs-string">&#x27;string&#x27;</span>) &#123; <span class="hljs-comment">// 情况一</span>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> oldChildren === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;        <span class="hljs-keyword">if</span> (newChildren !== oldChildren) &#123;          el.<span class="hljs-property">textContent</span> = newChildren        &#125;      &#125; <span class="hljs-keyword">else</span> &#123;        el.<span class="hljs-property">innerHTML</span> = newChildren      &#125;    &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 情况二：newChildren是个数组</span>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> oldChildren === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;        el.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&#x27;&#x27;</span>        newChildren.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;          <span class="hljs-title function_">mount</span>(item, el)        &#125;)      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">// 如果都是数组</span>        <span class="hljs-comment">// oldChildren : [v1,v2,v3]</span>        <span class="hljs-comment">// newChildren : [v1,v5,v7,v8,v9]</span>        <span class="hljs-keyword">const</span> commonLength = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(newChildren.<span class="hljs-property">length</span>, oldChildren.<span class="hljs-property">length</span>)        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; commonLength; i++) &#123;          <span class="hljs-title function_">patch</span>(oldChildren[i], newChildren[i])        &#125;        <span class="hljs-keyword">if</span> (newChildren.<span class="hljs-property">length</span> &gt; oldChildren.<span class="hljs-property">length</span>) &#123;          newChildren.<span class="hljs-title function_">slice</span>(oldChildren.<span class="hljs-property">length</span>).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;            <span class="hljs-title function_">mount</span>(item, el)          &#125;)        &#125;        <span class="hljs-keyword">if</span> (newChildren.<span class="hljs-property">length</span> &lt; oldChildren.<span class="hljs-property">length</span>) &#123;          oldChildren.<span class="hljs-title function_">slice</span>(newChildren.<span class="hljs-property">length</span>).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;            el.<span class="hljs-title function_">removeChild</span>(item.<span class="hljs-property">el</span>)          &#125;)        &#125;      &#125;    &#125;  &#125;&#125;</code></pre><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;renderer.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">  <span class="hljs-comment">// 1.通过 h 函数创建一个 vnode</span></span><span class="language-javascript">  <span class="hljs-keyword">const</span> vnode = <span class="hljs-title function_">h</span>(<span class="hljs-string">&#x27;div&#x27;</span>, &#123; <span class="hljs-attr">class</span>: <span class="hljs-string">&#x27;wangpf&#x27;</span>, <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;aaa&#x27;</span> &#125;, [</span><span class="language-javascript">    <span class="hljs-title function_">h</span>(<span class="hljs-string">&#x27;h2&#x27;</span>, &#123; <span class="hljs-attr">class</span>: <span class="hljs-string">&#x27;title&#x27;</span> &#125;, <span class="hljs-string">&#x27;hello,I am wangpf&#x27;</span>),</span><span class="language-javascript">    <span class="hljs-title function_">h</span>(<span class="hljs-string">&#x27;div&#x27;</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">&#x27;当前计数：100&#x27;</span>),</span><span class="language-javascript">    <span class="hljs-title function_">h</span>(<span class="hljs-string">&#x27;button&#x27;</span>, &#123; <span class="hljs-attr">class</span>: <span class="hljs-string">&#x27;btn&#x27;</span> &#125;, <span class="hljs-string">&#x27;+1&#x27;</span>)</span><span class="language-javascript">  ])</span><span class="language-javascript">  </span><span class="language-javascript">  <span class="hljs-comment">// 2. 通过 mount 函数， 将 vnode 挂载在div#app上</span></span><span class="language-javascript">  <span class="hljs-title function_">mount</span>(vnode, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#app&#x27;</span>))</span><span class="language-javascript">  </span><span class="language-javascript">  <span class="hljs-comment">// 3. 创建新的 vnode</span></span><span class="language-javascript">  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><span class="language-javascript">    <span class="hljs-keyword">const</span> newVnode = <span class="hljs-title function_">h</span>(<span class="hljs-string">&#x27;div&#x27;</span>, &#123; <span class="hljs-attr">class</span>: <span class="hljs-string">&#x27;pf&#x27;</span>, <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;aaa&#x27;</span> &#125;, [</span><span class="language-javascript">      <span class="hljs-title function_">h</span>(<span class="hljs-string">&#x27;h2&#x27;</span>, &#123; <span class="hljs-attr">class</span>: <span class="hljs-string">&#x27;title&#x27;</span> &#125;, <span class="hljs-string">&#x27;hello,I am wangpf&#x27;</span>),</span><span class="language-javascript">      <span class="hljs-title function_">h</span>(<span class="hljs-string">&#x27;div&#x27;</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">&#x27;当前计数：0&#x27;</span>),</span><span class="language-javascript">      <span class="hljs-title function_">h</span>(<span class="hljs-string">&#x27;button&#x27;</span>, &#123; <span class="hljs-attr">class</span>: <span class="hljs-string">&#x27;btn222&#x27;</span> &#125;, <span class="hljs-string">&#x27;-1&#x27;</span>)</span><span class="language-javascript">    ])</span><span class="language-javascript">    <span class="hljs-title function_">patch</span>(vnode, newVnode)</span><span class="language-javascript">  &#125;, <span class="hljs-number">2000</span>)</span><span class="language-javascript"></span><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre><p>当定时器达到2s后, 新的vnode 会替换掉旧的vnode，通过 ptach 函数来diff出不同的地方进行替换。</p><p>大致上这就这样简单的实现一下渲染系统模块，分别有 h函数（返回vnode对象）、mount函数（用于挂载到页面上）、patch函数（对比新旧vnode，更新为最新的）</p><h2 id="响应式系统模块的实现"><a href="#响应式系统模块的实现" class="headerlink" title="响应式系统模块的实现"></a>响应式系统模块的实现</h2><p>响应式模块是vue的重中之重，vue2版本是通过 <code>Object.defineProperty </code> 来进行对数据进行依赖收集劫持的 ， vue3版本是通过 <code>proxy</code> 来实现的</p><h4 id="为什么使用proxy的原因"><a href="#为什么使用proxy的原因" class="headerlink" title="为什么使用proxy的原因"></a>为什么使用proxy的原因</h4><p><a href="https://cn.vuejs.org/v2/guide/reactivity.html#%E5%A6%82%E4%BD%95%E8%BF%BD%E8%B8%AA%E5%8F%98%E5%8C%96">深入响应式原理 — Vue.js (vuejs.org)</a></p><p>换为 <code>proxy</code> 原因在于 <code>defineProperty </code> 这个API虽然兼容性好，但是不能检测到对象和数组的变化，比如对对象的新增属性，我们需要去手动的给该属性收集依赖（通过**$set**）,才能实现响应式。<br>对于 <code>proxy</code>来说, Proxy 是劫持的整个对象，不需要做特殊处理 （我觉得这个为什么换为 proxy 的根本原因）</p><h4 id="代码实现思路"><a href="#代码实现思路" class="headerlink" title="代码实现思路"></a>代码实现思路</h4><p>雏形的响应式系统： 发布订阅的思想</p><pre><code class="hljs js"><span class="hljs-comment">// 响应式系统模块</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dep</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subscribers</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>()  &#125;  <span class="hljs-title function_">addEffect</span>(<span class="hljs-params">effect</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subscribers</span>.<span class="hljs-title function_">add</span>(effect)  &#125;  <span class="hljs-title function_">notify</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subscribers</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">effect</span> =&gt;</span> &#123;      <span class="hljs-title function_">effect</span>()    &#125;)  &#125;&#125;<span class="hljs-keyword">const</span> info = &#123; <span class="hljs-attr">counter</span>: <span class="hljs-number">100</span> &#125;<span class="hljs-keyword">const</span> <span class="hljs-title function_">doubleCounter</span> = (<span class="hljs-params"></span>) =&gt; &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(info.<span class="hljs-property">counter</span> * <span class="hljs-number">2</span>)&#125;<span class="hljs-keyword">const</span> <span class="hljs-title function_">multiplyCounter</span> = (<span class="hljs-params"></span>) =&gt; &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(info.<span class="hljs-property">counter</span> * info.<span class="hljs-property">counter</span>)&#125;<span class="hljs-keyword">const</span> dep = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dep</span>()dep.<span class="hljs-title function_">addEffect</span>(doubleCounter)dep.<span class="hljs-title function_">addEffect</span>(multiplyCounter)<span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;  info.<span class="hljs-property">counter</span>++  dep.<span class="hljs-title function_">notify</span>()&#125;, <span class="hljs-number">2000</span>)</code></pre><p>上述代码有很多不足之处，只要数据发生变化就得手动去调用。</p><p>我们希望数据只要一发生变化，那么就自动的去收集依赖并执行</p><p>所以改进了如下：</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> dep = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dep</span>()<span class="hljs-keyword">const</span> <span class="hljs-title function_">watchEffect</span> = (<span class="hljs-params">effect</span>) =&gt; &#123;  dep.<span class="hljs-title function_">addEffect</span>(effect)&#125;<span class="hljs-keyword">const</span> info = &#123; <span class="hljs-attr">counter</span>: <span class="hljs-number">100</span> &#125;<span class="hljs-title function_">watchEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(info.<span class="hljs-property">counter</span> * <span class="hljs-number">2</span>)&#125;)<span class="hljs-title function_">watchEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(info.<span class="hljs-property">counter</span> * info.<span class="hljs-property">counter</span>)&#125;)<span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;  info.<span class="hljs-property">counter</span>++  dep.<span class="hljs-title function_">notify</span>()&#125;, <span class="hljs-number">2000</span>)</code></pre><p>我就用 watchEffect 来统一管理它， 只不过需要在 watchEffect 函数中执行逻辑。</p><p>但这还是有些不足，比如不知道是谁的逻辑，而且并不是自动收集依赖</p><p>因此，再次进行改进，如下：</p><pre><code class="hljs js"><span class="hljs-comment">// 响应式系统模块</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dep</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subscribers</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>()  &#125;  <span class="hljs-title function_">depend</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">if</span> (activeEffect) &#123;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">subscribers</span>.<span class="hljs-title function_">add</span>(activeEffect)    &#125;  &#125;  <span class="hljs-title function_">notify</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subscribers</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">effect</span> =&gt;</span> &#123;      <span class="hljs-title function_">effect</span>()    &#125;)  &#125;&#125;<span class="hljs-keyword">const</span> dep = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dep</span>()<span class="hljs-keyword">let</span> activeEffect = <span class="hljs-literal">null</span><span class="hljs-keyword">const</span> <span class="hljs-title function_">watchEffect</span> = (<span class="hljs-params">effect</span>) =&gt; &#123;  activeEffect = effect  dep.<span class="hljs-title function_">depend</span>()  activeEffect = <span class="hljs-literal">null</span>&#125;<span class="hljs-keyword">const</span> info = &#123; <span class="hljs-attr">counter</span>: <span class="hljs-number">100</span> &#125;<span class="hljs-title function_">watchEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(info.<span class="hljs-property">counter</span> * <span class="hljs-number">2</span>)&#125;)<span class="hljs-title function_">watchEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(info.<span class="hljs-property">counter</span> * info.<span class="hljs-property">counter</span>)&#125;)<span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;  info.<span class="hljs-property">counter</span>++  dep.<span class="hljs-title function_">notify</span>()&#125;, <span class="hljs-number">2000</span>)</code></pre><p>用 depend 来取代替 addEffect ， 这样做的目的是 不需要去知道 subscribers 添加的具体是什么</p><p>但是呢， 这样做会使得对 info 整个有依赖， 如果我想监听 info 的某一个属性，所有我们需要有一个数据劫持的方法来实现。</p><p>这时候就可以用vue2响应式原理的思想来实现了， 通过 <code>Object.defineProperty</code> (Vue2响应式原理的核心)</p><h4 id="使用-Object-defineProperty-来实现"><a href="#使用-Object-defineProperty-来实现" class="headerlink" title="使用 Object.defineProperty 来实现"></a>使用 Object.defineProperty 来实现</h4><pre><code class="hljs js"><span class="hljs-comment">// 响应式系统模块</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dep</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subscribers</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>()  &#125;  <span class="hljs-title function_">depend</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">if</span> (activeEffect) &#123;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">subscribers</span>.<span class="hljs-title function_">add</span>(activeEffect)    &#125;  &#125;  <span class="hljs-title function_">notify</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subscribers</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">effect</span> =&gt;</span> &#123;      <span class="hljs-title function_">effect</span>()    &#125;)  &#125;&#125;<span class="hljs-keyword">let</span> activeEffect = <span class="hljs-literal">null</span><span class="hljs-keyword">const</span> <span class="hljs-title function_">watchEffect</span> = (<span class="hljs-params">effect</span>) =&gt; &#123;  activeEffect = effect  <span class="hljs-title function_">effect</span>()  <span class="hljs-comment">//  vue3 中 watchEffect 就会默认执行一次</span>  activeEffect = <span class="hljs-literal">null</span>&#125;<span class="hljs-keyword">const</span> targetMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>()<span class="hljs-keyword">const</span> <span class="hljs-title function_">getDep</span> = (<span class="hljs-params">target, key</span>) =&gt; &#123;  <span class="hljs-keyword">let</span> depsMap = targetMap.<span class="hljs-title function_">get</span>(target)  <span class="hljs-keyword">if</span> (!depsMap) &#123;    depsMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()    targetMap.<span class="hljs-title function_">set</span>(target, depsMap)  &#125;  <span class="hljs-keyword">let</span> dep = depsMap.<span class="hljs-title function_">get</span>(key)  <span class="hljs-keyword">if</span> (!dep) &#123;    dep = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dep</span>()    depsMap.<span class="hljs-title function_">set</span>(key, dep)  &#125;  <span class="hljs-keyword">return</span> dep&#125;<span class="hljs-comment">// vue2 数据劫持原理</span><span class="hljs-keyword">const</span> <span class="hljs-title function_">reactive</span> = (<span class="hljs-params">raw</span>) =&gt; &#123;  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(raw).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> &#123;    <span class="hljs-keyword">const</span> dep = <span class="hljs-title function_">getDep</span>(raw, key)    <span class="hljs-keyword">let</span> value = raw[key];    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(raw, key, &#123;      <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;        dep.<span class="hljs-title function_">depend</span>()        <span class="hljs-keyword">return</span> value      &#125;,      <span class="hljs-title function_">set</span>(<span class="hljs-params">newValue</span>) &#123;        <span class="hljs-keyword">if</span> (value !== newValue) &#123;          value = newValue          dep.<span class="hljs-title function_">notify</span>()        &#125;      &#125;    &#125;)  &#125;)  <span class="hljs-keyword">return</span> raw&#125;</code></pre><p>实现效果：</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> info = <span class="hljs-title function_">reactive</span>(&#123; <span class="hljs-attr">counter</span>: <span class="hljs-number">100</span> &#125;)<span class="hljs-title function_">watchEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(info.<span class="hljs-property">counter</span> * <span class="hljs-number">2</span>)&#125;)<span class="hljs-title function_">watchEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(info.<span class="hljs-property">counter</span> * info.<span class="hljs-property">counter</span>)&#125;)info.<span class="hljs-property">counter</span>++<span class="hljs-comment">// 70 10000</span><span class="hljs-comment">// 67 202</span><span class="hljs-comment">// 70 10201</span></code></pre><p><code>defineProperty</code> 已经说过了，所以我们可以使用<code>proxy</code> 对 <strong>reactive 函数</strong>进行重构</p><h4 id="使用-Proxy-来实现"><a href="#使用-Proxy-来实现" class="headerlink" title="使用 Proxy 来实现"></a>使用 Proxy 来实现</h4><pre><code class="hljs js"><span class="hljs-comment">// vue3 proxy 数据劫持</span><span class="hljs-keyword">const</span> <span class="hljs-title function_">reactive</span> = (<span class="hljs-params">raw</span>) =&gt; &#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(raw, &#123;    <span class="hljs-title function_">get</span>(<span class="hljs-params">target, p, receiver</span>) &#123;      <span class="hljs-keyword">const</span> dep = <span class="hljs-title function_">getDep</span>(target, p)      dep.<span class="hljs-title function_">depend</span>()      <span class="hljs-keyword">return</span> target[p]    &#125;,    <span class="hljs-title function_">set</span>(<span class="hljs-params">target, p, newValue, receiver</span>) &#123;      <span class="hljs-keyword">const</span> dep = <span class="hljs-title function_">getDep</span>(target, p)      target[p] = newValue      dep.<span class="hljs-title function_">notify</span>()    &#125;  &#125;)&#125;</code></pre><h3 id="应用程序入口模块的实现"><a href="#应用程序入口模块的实现" class="headerlink" title="应用程序入口模块的实现"></a>应用程序入口模块的实现</h3><blockquote><p>上述已经实现了 渲染系统模块和响应式系统模块，接下来我们就差最后一步了，模仿一下vue3 使用 createApp函数 作为入口 以及mount函数将其挂载到页面上</p></blockquote><p>从框架的层面来说，我们需要有俩部分内容：</p><ul><li>createApp 用于创建一个app对象</li><li>该app对象有一个 mount 方法，可以将根组件挂载到某一个dom元素上。</li></ul><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">createApp</span> = (<span class="hljs-params">rootComponent</span>) =&gt; &#123;  <span class="hljs-keyword">return</span> &#123;    <span class="hljs-title function_">mount</span>(<span class="hljs-params">selector</span>) &#123;      <span class="hljs-keyword">let</span> isMounted = <span class="hljs-literal">false</span>      <span class="hljs-keyword">let</span> preVnode = <span class="hljs-literal">null</span>      <span class="hljs-title function_">watchEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-comment">// 首次需要挂载， 后边就 patch</span>        <span class="hljs-keyword">if</span> (!isMounted) &#123;          preVnode = rootComponent.<span class="hljs-title function_">render</span>()          <span class="hljs-title function_">mount</span>(preVnode, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(selector))          isMounted = <span class="hljs-literal">true</span>        &#125; <span class="hljs-keyword">else</span> &#123;          <span class="hljs-keyword">const</span> newVnode = rootComponent.<span class="hljs-title function_">render</span>()          <span class="hljs-title function_">patch</span>(preVnode, newVnode)          preVnode = newVnode        &#125;      &#125;)    &#125;  &#125;&#125;</code></pre><h4 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h4><pre><code class="hljs js">  <span class="hljs-comment">// 1. 创建根组件</span><span class="hljs-keyword">const</span> <span class="hljs-title class_">App</span> = &#123;  <span class="hljs-attr">data</span>: <span class="hljs-title function_">reactive</span>(&#123;    <span class="hljs-attr">counter</span>: <span class="hljs-number">0</span>  &#125;),  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-title function_">h</span>(<span class="hljs-string">&#x27;div&#x27;</span>, <span class="hljs-literal">null</span>, [      <span class="hljs-title function_">h</span>(<span class="hljs-string">&#x27;h2&#x27;</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">`计数:<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.data.counter&#125;</span>`</span>),      <span class="hljs-title function_">h</span>(<span class="hljs-string">&#x27;button&#x27;</span>, &#123;        <span class="hljs-attr">onClick</span>: <span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>.<span class="hljs-property">counter</span>++&#125;      &#125;, <span class="hljs-string">&#x27;+1&#x27;</span>)    ])  &#125;&#125;<span class="hljs-comment">// 2. 挂载根组件</span><span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>).<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#app&#x27;</span>)</code></pre><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/21be39e02a714a96b2f4841610cc8b71~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="test1"></p><p>点击即可完成加一操作！</p>]]></content>
    
    
    <categories>
      
      <category>Vue.js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue3|Composition_API （全）总结</title>
    <link href="/2021/08/07/65-Composition_API/"/>
    <url>/2021/08/07/65-Composition_API/</url>
    
    <content type="html"><![CDATA[<p>为了能够使用Composition API, 我们需要有一个可以实际使用它的地方。在vue组件中，我们将此位置称为setup</p><h2 id="setup函数"><a href="#setup函数" class="headerlink" title="setup函数"></a>setup函数</h2><blockquote><p>setup函数是在组件创建之前执行的，setup函数中的props一旦被解析，就将作为Composition API 的入口</p></blockquote><p>需要注意的是： 我们不能在setup函数中使用this， 因为它不会找到组件实例。 原因是 虽然组件实例是在执行setup之前就会被创建出来了，但是<br>setup函数被调用之前，data,computed,methods等都没有被解析，所以它们无法在setup中被获取。</p><h3 id="setup接收俩个参数-props-context"><a href="#setup接收俩个参数-props-context" class="headerlink" title="setup接收俩个参数(props,context)"></a>setup接收俩个参数(props,context)</h3><h4 id="props"><a href="#props" class="headerlink" title="props"></a>props</h4><blockquote><p>作为setup函数中的第一个参数，props是响应式的，当传入新的prop时，它将会被更新</p><p>其实就是父组件传递过来的属性会被放到props对象中</p></blockquote><ul><li>对于定义props的类型，和Vue2一样，在props选项对象中定义</li><li>在template中的写法依然是不变的</li><li>因为props有直接作为参数传递到setup函数中，所以我们可以直接通过参数来使用。</li></ul><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  <span class="hljs-attr">props</span>: &#123;    <span class="hljs-attr">message</span>: &#123;      <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>,      <span class="hljs-attr">default</span>: <span class="hljs-string">&quot;hello&quot;</span>    &#125;  &#125;,  <span class="hljs-title function_">setup</span>(<span class="hljs-params">props</span>) &#123;    consloe.<span class="hljs-title function_">log</span>(props.<span class="hljs-property">message</span>)  &#125;&#125;</code></pre><p><strong>！！ 由于 <code>props</code> 是响应式的， 所以我们不能用 解构，它会消除props的响应性。</strong></p><p>如果需要结构props，那么需要用到 <code>toRefs</code>函数来完成操作。</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; toRefs &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><span class="hljs-title function_">setup</span>(<span class="hljs-params">props</span>)&#123;  <span class="hljs-keyword">const</span> message = <span class="hljs-title function_">toRefs</span>(props, <span class="hljs-string">&#x27;message&#x27;</span>)  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message.<span class="hljs-property">value</span>)&#125;</code></pre><h4 id="context"><a href="#context" class="headerlink" title="context"></a>context</h4><blockquote><p>作为setup函数的第二个参数， context是一个普通的JavaScript对象，它暴露组件的三个property</p></blockquote><ul><li>**attrs ** ：所有的非prop的attribute</li><li><strong>slots</strong>  ：父组件传递过来的插槽</li><li><strong>emit</strong>  ： 当我们组件内部需要发出事件时用到emit， 和vue2中 this.$emit用法一致</li></ul><p><strong>！！由于context只是一个普通的JavaScript对象，所以它不是响应式的，这就意味着我们可以安全地对 <code>context</code> 使用 解构</strong></p><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  <span class="hljs-title function_">setup</span>(<span class="hljs-params">props, &#123; attrs, slots, emit &#125;</span>) &#123;  ...  &#125;&#125;</code></pre><h3 id="setup函数的返回值"><a href="#setup函数的返回值" class="headerlink" title="setup函数的返回值"></a>setup函数的返回值</h3><blockquote><p>由于setup是一个函数，那么它就会有返回值</p></blockquote><p>如果<strong>setup</strong>的返回值是一个对象，那么该对象的property就可以在模板中访问到。</p><p>注意的是：从setup中返回的 <code>refs</code>在模板中是会自动浅解包的，所以不必在模板中用 <code>.value</code></p><h2 id="有关响应性的API"><a href="#有关响应性的API" class="headerlink" title="有关响应性的API"></a>有关响应性的API</h2><h3 id="reactive"><a href="#reactive" class="headerlink" title="reactive"></a>reactive</h3><blockquote><p>返回对象的响应式副本</p></blockquote><p>如果想在setup中定义的数据是具有响应式的，那么就可以使用 <code>reactive</code></p><pre><code class="hljs js"><span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;wangpf&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">18</span> &#125;)</code></pre><p>为什么会通过 <code>reactive</code> 就可以变成响应式的呢？</p><ul><li>因为当我们使用<strong>reactvie函数处理我们的数据之后，数据再次被使用时会进行以依赖收集</strong></li><li>当数据发生变化时，所有收集到的依赖都是进行对象的响应式的操作</li><li>事实上，在vue2中，我们编写的 data选项，也是在内部交给了 <code>reactive</code>函数将其变成了响应式对象的</li></ul><p>注意的俩点：</p><ul><li><p><code>reactive</code> 将解包所有深层的 refs，同时维持着 ref 的响应性</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)<span class="hljs-keyword">const</span> obj = <span class="hljs-title function_">reactive</span>(&#123; count &#125;)<span class="hljs-comment">// ref 会被解包</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count.<span class="hljs-property">value</span> === obj.<span class="hljs-property">value</span>) <span class="hljs-comment">// true</span><span class="hljs-comment">// 会更新到 &#x27;obj.count&#x27;</span>count.<span class="hljs-property">value</span>++ <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count.<span class="hljs-property">value</span>) <span class="hljs-comment">// 1</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">count</span>) <span class="hljs-comment">// 1</span><span class="hljs-comment">// 也会更新到 ref &#x27;count&#x27;</span>obj.<span class="hljs-property">count</span>++<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count.<span class="hljs-property">value</span>) <span class="hljs-comment">// 2</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj,value) <span class="hljs-comment">// 2</span></code></pre></li></ul><ul><li><p>当把 <code>ref</code> 分配给 <code>reactive</code> 时，将会自动解包</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">1</span>)<span class="hljs-keyword">const</span> obj = <span class="hljs-title function_">reactive</span>(&#123; &#125;)obj.<span class="hljs-property">count</span> = count<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">count</span>) <span class="hljs-comment">// 1</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">count</span> === count.<span class="hljs-property">value</span>) <span class="hljs-comment">// true</span></code></pre></li></ul><p>但是由于 <code>reactive</code> 对传入的类型是有限制的，它要求我们必须传入的是一个对象或者数组</p><p>如果我们传入的是一个基本的数据类型（String,Number,Boolean）则会报警告.</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87dc49efe45d49cf9a43ead801bb38a4~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="reactive的限制.png"><br>这时，我们可以使用另一个API， <strong>ref</strong></p><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><blockquote><p>接受一个内部值并返回一个响应式且可变的 ref 对象。 ref对象具有指向内部值的单个property （.vlaue）</p></blockquote><p>ref 会返回一个可变的响应式对象，该对象作为一个响应式的引用（reference） 维护着它内部的值。</p><p>内部的值是在 ref的 vlaue属性中被维护的</p><h3 id="readonly"><a href="#readonly" class="headerlink" title="readonly"></a>readonly</h3><blockquote><p>我们通过 <code>reactive</code> 或者 <code>ref</code> 可以获取到一个响应式的对象，但是某些情况下， 我们传入给其他地方（组件） 的这个响应式对象希望在另外一个地方（组件）被使用，<strong>但是不能被修改</strong>，这个时候就可以用 readonly 了</p></blockquote><p>readnoly 会返回原生对象的只读代理 原理在于： 利用 proxy 中的set，在set方法中将其劫持，并且设置该值不能修改</p><h3 id="关于reactive-判断-的API"><a href="#关于reactive-判断-的API" class="headerlink" title="关于reactive 判断 的API"></a>关于reactive 判断 的API</h3><h4 id="isProxy"><a href="#isProxy" class="headerlink" title="isProxy"></a>isProxy</h4><blockquote><p>检查对象是否由 <code>reactive</code> 或 <code>readonly</code> 创建的 proxy</p></blockquote><pre><code class="hljs js"><span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>(&#123; <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> &#125;)<span class="hljs-keyword">const</span> count = <span class="hljs-number">0</span><span class="hljs-title function_">isProxy</span>(state) <span class="hljs-comment">// true</span><span class="hljs-title function_">isProxy</span>(<span class="hljs-title function_">readonly</span>(state)) <span class="hljs-comment">// true</span><span class="hljs-title function_">isProxy</span>(count) <span class="hljs-comment">// false</span></code></pre><h4 id="isReactive"><a href="#isReactive" class="headerlink" title="isReactive"></a>isReactive</h4><blockquote><p>检查对象是否由 <code>reactive</code> 创建处理的相应手机代理</p></blockquote><p>但如果代理是由 <code>readonly</code>创建的，但包裹了由 <code>reactive</code>创建 另一个代理，也会返回 true</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>(&#123; <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> &#125;)<span class="hljs-title function_">isReactive</span>(state) <span class="hljs-comment">// true</span><span class="hljs-title function_">isReactive</span>(<span class="hljs-title function_">readonly</span>(state)) <span class="hljs-comment">// true</span></code></pre><h4 id="isReadOnly"><a href="#isReadOnly" class="headerlink" title="isReadOnly"></a>isReadOnly</h4><blockquote><p>检查对象是否由 <code>readonly</code>创建的只读代理</p></blockquote><h4 id="toRaw"><a href="#toRaw" class="headerlink" title="toRaw"></a>toRaw</h4><blockquote><p>返回 <code>reactive 或 readonly 代理的原始对象</code>  （不建议保留对原始对象的持久化引用，谨慎使用）</p></blockquote><h4 id="shallowReactive"><a href="#shallowReactive" class="headerlink" title="shallowReactive"></a>shallowReactive</h4><p>shallow（浅层）</p><blockquote><p>创建一个响应式代理，他跟踪其自身property的响应性，但不执行嵌套对象的深层响应式转换 （深层还是原生对象）</p><p>类似于浅拷贝，只把第一层转为响应式了，深层还是原始对象</p></blockquote><h4 id="shallowReadonly"><a href="#shallowReadonly" class="headerlink" title="shallowReadonly"></a>shallowReadonly</h4><blockquote><p>创建一个 proxy ， 使其自身的 property 为只读， 但不执行嵌套对象的深度只读转换</p><p>就是说第一层是只读的，但是深层还是可读，可写的</p></blockquote><h3 id="toRefs"><a href="#toRefs" class="headerlink" title="toRefs"></a>toRefs</h3><p>由于我们使用ES6的解构语法对 reactive 返回的对象进行解构赋值，那么解构后的数据是不具有响应式的</p><p>而使用 toRefs 可以将 reative 返回的对象中的属性都转成 ref 这样我们再次解构出来的数据都是 ref的。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;wangpf&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">18</span> &#125;);<span class="hljs-keyword">const</span> &#123; name, age &#125; = state; <span class="hljs-comment">// 这样解构出来的数据是没有响应式的</span><span class="hljs-keyword">const</span> &#123; name, age &#125; = <span class="hljs-title function_">toRefs</span>(state) <span class="hljs-comment">// 这样的解构出来的数据转换成了ref的，是响应式的</span><span class="hljs-comment">// 上述的做法， 相当于在 state.name 和 name.value 之间建立了连接， 修改任何一个都会引起另外一个变化</span></code></pre><h3 id="toRef"><a href="#toRef" class="headerlink" title="toRef"></a>toRef</h3><p>如果我们希望转换一个 reactive 对象中的属性为 ref ，那么可以使用 toRef 的方法</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;wangpf&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">18</span> &#125;);<span class="hljs-keyword">const</span> name = <span class="hljs-title function_">toRef</span>(state, <span class="hljs-string">&quot;name&quot;</span>); <span class="hljs-comment">// 该 name 是ref的，  </span><span class="hljs-comment">// 同样的， name.value 和 state.name 之间建立了连接， 修改会互相影响</span></code></pre><h3 id="ref其他的API"><a href="#ref其他的API" class="headerlink" title="ref其他的API"></a>ref其他的API</h3><h4 id="unref"><a href="#unref" class="headerlink" title="unref"></a>unref</h4><p>如果想要获取一个ref引用中的value，可以通过 unref 方法：</p><ul><li><p>如果参数是一个 ref， 则返回内部值，否则返回参数本事</p></li><li><p>其实是一个语法糖：</p><ul><li><pre><code class="js">val = isRef(val) ? val.value : val<pre><code class="hljs reasonml">```ts<span class="hljs-keyword">function</span> use<span class="hljs-constructor">Foo(<span class="hljs-params">x</span>: <span class="hljs-params">number</span> | Ref&lt;<span class="hljs-params">number</span>&gt;)</span> &#123;  const unwrapped = unref(x) <span class="hljs-comment">// unwrapped 现在一定是数字类型</span>&#125;</code></pre></code></pre></li></ul></li></ul><h4 id="isRef"><a href="#isRef" class="headerlink" title="isRef"></a>isRef</h4><blockquote><p>判断值是否是一个ref对象</p></blockquote><h3 id="shallowRef"><a href="#shallowRef" class="headerlink" title="shallowRef"></a>shallowRef</h3><blockquote><p>创建一个浅层的ref对象</p></blockquote><pre><code class="hljs js"><span class="hljs-keyword">const</span> info = <span class="hljs-title function_">shallowRef</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;wangpf&quot;</span> &#125;)<span class="hljs-keyword">const</span> <span class="hljs-title function_">changeInfo</span> = (<span class="hljs-params"></span>) =&gt; &#123;  info.<span class="hljs-property">value</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;wpf&#x27;</span>  <span class="hljs-comment">// 此时的修改是不能够实现响应式的</span>&#125;</code></pre><h4 id="triggerRef"><a href="#triggerRef" class="headerlink" title="triggerRef"></a>triggerRef</h4><blockquote><p>手动触发和 shallowRef 相关联的副作用</p></blockquote><pre><code class="hljs js"><span class="hljs-keyword">const</span> info = <span class="hljs-title function_">shallowRef</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;wangpf&quot;</span> &#125;)<span class="hljs-keyword">const</span> <span class="hljs-title function_">changeInfo</span> = (<span class="hljs-params"></span>) =&gt; &#123;  info.<span class="hljs-property">value</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;wpf&#x27;</span>  <span class="hljs-comment">// 此时的修改是不能够实现响应式的</span>  <span class="hljs-comment">// 使用 triggerRef 可以触发</span>  <span class="hljs-title function_">triggerRef</span>(info)&#125;</code></pre><h4 id="customRef"><a href="#customRef" class="headerlink" title="customRef"></a>customRef</h4><blockquote><p>创建一个自定义的 ref ，并对其依赖项跟踪和更新触发进行显示控制</p></blockquote><ul><li>它需要一个工厂函数，该函数接受 track 和 trigger 函数 作为参数</li><li>应该返回一个带有 get 和 set 的对象</li></ul><h6 id="用-customRef-做的一个防抖案例"><a href="#用-customRef-做的一个防抖案例" class="headerlink" title="用 customRef 做的一个防抖案例"></a>用 customRef 做的一个防抖案例</h6><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; customRef &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">value, delay = <span class="hljs-number">300</span></span>) &#123;  <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;  <span class="hljs-keyword">return</span> <span class="hljs-title function_">customRef</span>(<span class="hljs-function">(<span class="hljs-params">track, trigger</span>) =&gt;</span> &#123;    <span class="hljs-keyword">return</span> &#123;      <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-title function_">track</span>();        <span class="hljs-keyword">return</span> value;      &#125;,      <span class="hljs-title function_">set</span>(<span class="hljs-params">newValue</span>) &#123;        <span class="hljs-built_in">clearTimeout</span>(timer);        timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;          value = newValue;          <span class="hljs-title function_">trigger</span>();        &#125;, delay);      &#125;,    &#125;;  &#125;);&#125;</code></pre><pre><code class="hljs vue">&lt;template&gt;  &lt;input type=&quot;text&quot; v-model=&quot;message&quot;/&gt;  &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;&lt;/template&gt;&lt;script&gt;import useDebounceRef from &quot;../hooks/useDebounceRef&quot;;export default &#123;  name: &quot;Demo2&quot;,  setup() &#123;    const message = useDebounceRef(&quot;hello&quot;, 300);    return &#123;      message,    &#125;;  &#125;,&#125;;&lt;/script&gt;</code></pre><h3 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h3><blockquote><p>该API 的方法 和 vue2 的一样， 只不过写的地方是在setup函数中了， 但还需注意的点是 computed 返回的值是一个 ref</p></blockquote><ul><li>方式一： 接收一个 getter 函数，并为 getter 函数返回的值，返回一个不变的 ref 对象</li></ul><pre><code class="hljs js">    <span class="hljs-keyword">const</span> firstName = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&quot;wangpf&quot;</span>);<span class="hljs-keyword">const</span> lastName = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&quot;ok&quot;</span>);<span class="hljs-keyword">const</span> fullName = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;firstName.value&#125;</span> <span class="hljs-subst">$&#123;lastName.value&#125;</span>`</span>)</code></pre><ul><li>方式二 ： 接收一个具有 get 和 set 的对象，返回一个可变的（可读写的）ref对象</li></ul><pre><code class="hljs js">    <span class="hljs-keyword">const</span> firstName = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&quot;wangpf&quot;</span>);<span class="hljs-keyword">const</span> lastName = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&quot;ok&quot;</span>);<span class="hljs-keyword">const</span> fullName = <span class="hljs-title function_">computed</span>(&#123;  <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;firstName.value&#125;</span> <span class="hljs-subst">$&#123;lastName.value&#125;</span>`</span>;  &#125;,  <span class="hljs-title function_">set</span>(<span class="hljs-params">newValue</span>) &#123;    <span class="hljs-keyword">const</span> names = newValue.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot; &quot;</span>);    firstName.<span class="hljs-property">value</span> = names[<span class="hljs-number">0</span>];    lastName.<span class="hljs-property">value</span> = names[<span class="hljs-number">1</span>];  &#125;,&#125;);<span class="hljs-keyword">const</span> <span class="hljs-title function_">changeName</span> = (<span class="hljs-params"></span>) =&gt; &#123;  fullName.<span class="hljs-property">value</span> = <span class="hljs-string">&quot;wpf err&quot;</span>;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fullName.<span class="hljs-property">value</span>);&#125;;</code></pre><h3 id="侦听数据的变化-（watch-watchEffect）"><a href="#侦听数据的变化-（watch-watchEffect）" class="headerlink" title="侦听数据的变化 （watch  watchEffect）"></a>侦听数据的变化 （watch  watchEffect）</h3><blockquote><p>在 Composition API 中， 我们可以使用 watchEffect 和 watch 来完成响应式数据的侦听</p></blockquote><ul><li>watch 需要手动指定侦听的数据源</li><li>watchEffect 用于自动收集响应式数据的依赖</li></ul><h4 id="watchEffect"><a href="#watchEffect" class="headerlink" title="watchEffect"></a>watchEffect</h4><p><a href="https://v3.cn.vuejs.org/guide/reactivity-computed-watchers.html#watcheffect">响应式计算和侦听 | Vue.js (vuejs.org)</a></p><blockquote><p>当侦听到某些响应式数据变化时，我们希望执行某些操作，这个时候就可以用 watchEffect</p></blockquote><p>来看一个案例：</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> name = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;wangpf&#x27;</span>)<span class="hljs-keyword">const</span> age = <span class="hljs-title function_">ref</span>(<span class="hljs-number">18</span>)<span class="hljs-title function_">watchEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;watchEffect执行了&#x27;</span>, name.<span class="hljs-property">value</span>, age.<span class="hljs-property">value</span>)&#125;)</code></pre><ul><li>通过以上代码，首先 watchEffect 传入的函数会立即被执行一次，并且在执行的过程中会收集依赖<ul><li>（为什么需要立即执行一次的原因就是需要去收集依赖）</li></ul></li><li>其次，只有收集的依赖发生变化时，watchEffect 传入的函数才会被执行</li></ul><h5 id="watchEffect-的停止侦听"><a href="#watchEffect-的停止侦听" class="headerlink" title="watchEffect 的停止侦听"></a>watchEffect 的停止侦听</h5><ul><li>如果在发生某些情况下，我们希望停止侦听，这个时候我们可以获取 <strong>watchEffect 的返回值函数</strong>， 调用它即可</li></ul><p>看一个案例:</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> stopWatch = <span class="hljs-title function_">watchEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;watchEffect执行了&#x27;</span>, name.<span class="hljs-property">value</span>, age.<span class="hljs-property">value</span>)&#125;)<span class="hljs-keyword">const</span> <span class="hljs-title function_">changeAge</span> = (<span class="hljs-params"></span>) =&gt; &#123;  age.<span class="hljs-property">value</span>++;  <span class="hljs-keyword">if</span> (age.<span class="hljs-property">value</span> &gt; <span class="hljs-number">20</span>) &#123;    <span class="hljs-title function_">stopWatch</span>() <span class="hljs-comment">// 掉用 watchEffect 的返回值就可以停止侦听了</span>  &#125;&#125;</code></pre><h5 id="watchEffect-清除副作用"><a href="#watchEffect-清除副作用" class="headerlink" title="watchEffect 清除副作用"></a>watchEffect 清除副作用</h5><blockquote><p>用途： 比如在开发中我们需要在侦听函数中执行网络请求，但是在网络请求还没有达到的时候，我们停止了侦听器，或者侦听器侦听函数被再次执行了，这时我们需要把上一次的网络请求 取消掉， 就可以用到该方法了</p></blockquote><p>看了一个案例：</p><pre><code class="hljs js"><span class="hljs-title function_">watchEffect</span>(<span class="hljs-function">(<span class="hljs-params">onInvalidate</span>) =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;watchEffect执行了&#x27;</span>, name.<span class="hljs-property">value</span>, age.<span class="hljs-property">value</span>)  <span class="hljs-keyword">const</span> timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;1s后执行的操作&#x27;</span>)  &#125;, <span class="hljs-number">1000</span>)  <span class="hljs-title function_">onInvalidate</span>(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-comment">// 在这里操作一些清除工作</span>    <span class="hljs-title function_">clearTimeour</span>(timer)  &#125;)&#125;)</code></pre><p>在上述代码中，我们给 watchEffect 传入的函数被回调时，可以获取到一个参数：<strong>onInvalidate</strong> （该参数是一个函数），可以在这个参数中，执行一些清除工作。</p><h5 id="watchEffect-的执行时间（刷新时机）"><a href="#watchEffect-的执行时间（刷新时机）" class="headerlink" title="watchEffect 的执行时间（刷新时机）"></a>watchEffect 的执行时间（刷新时机）</h5><p>在默认情况下 ， 组件的更新会在 watchEffect （副作用函数） 之前执行</p><pre><code class="hljs js">  <span class="hljs-keyword">const</span> title = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>);  <span class="hljs-comment">// 该title 已和 div 标签绑定了</span><span class="hljs-title function_">watchEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(title.<span class="hljs-property">value</span>);&#125;);<span class="hljs-keyword">return</span> &#123; title &#125;;</code></pre><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8596249c110242bdaee05621fb1679e9~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="watchEffect 的执行时间.png"><br>那么，当我们在 watchEffect （副作用函数) 获取元素时， 第一次执行是肯定是个null， 是不可以的。只有当DOM挂载完毕后，才会给 title 赋新的值，watchEffect （副作用函数）才会再次执行， 打印出对应的元素</p><p>我们希望第一次就打印出该元素的话，这时候需要给 watchEffect 传入第二个参数， 该参数是一个 对象，对象中的 flush 可取三个值 ：<code> &#39;pre&#39; (默认的) ,  &#39;post&#39; , &#39;async&#39; (不建议使用)</code></p><pre><code class="hljs js"><span class="hljs-comment">// 在组件更新后触发，这样你就可以访问更新的 DOM。</span><span class="hljs-comment">// 注意：这也将推迟副作用的初始运行，直到组件的首次渲染完成。</span><span class="hljs-title function_">watchEffect</span>(  <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-comment">/* ... */</span>  &#125;,  &#123;    <span class="hljs-attr">flush</span>: <span class="hljs-string">&#x27;post&#x27;</span> <span class="hljs-comment">// 在 DOM元素挂载或更新之后执行，  &quot;pre&quot; 立即执行 （默认的）</span>  &#125;)</code></pre><h4 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h4><blockquote><p>watch API 的功能和 vue 2 的 option API 中的 watch 功能一样， 默认情况下， watch 只有当被侦听的源发送改变时才会去回调</p></blockquote><p>与 watchEffect 比较，不同的是：</p><ul><li>watch 是 懒执行副作用</li><li>更具体地说明了什么状态下应该触发侦听器重新运行</li><li>可以访问到侦听状态变化前后的值</li></ul><h5 id="侦听单个数据源"><a href="#侦听单个数据源" class="headerlink" title="侦听单个数据源"></a>侦听单个数据源</h5><p>想要侦听<strong>单个</strong>数据源的话， 有俩种方法： <strong>传入 getter 函数 或 ref 对象</strong></p><pre><code class="hljs js"><span class="hljs-comment">//  侦听  getter </span><span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;wangpf&#x27;</span> &#125;)<span class="hljs-title function_">watch</span>(<span class="hljs-function">() =&gt;</span> state.<span class="hljs-property">name</span>, <span class="hljs-function">(<span class="hljs-params">newVal, oldVal</span>) =&gt;</span> &#123;  <span class="hljs-comment">/* ... */</span>&#125;)<span class="hljs-comment">// 侦听 ref</span><span class="hljs-keyword">const</span> name = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;wamgpf&#x27;</span>)<span class="hljs-title function_">watch</span>(name, <span class="hljs-function">(<span class="hljs-params">newVal, oldVal</span>) =&gt;</span> &#123;  <span class="hljs-comment">/* ... */</span>  <span class="hljs-comment">// 这里的 newVal,oldVal 的值是 是返回的 ref.value 的值</span>&#125;)</code></pre><h5 id="侦听多个数据源"><a href="#侦听多个数据源" class="headerlink" title="侦听多个数据源"></a>侦听多个数据源</h5><p>方法： 传入数组</p><pre><code class="hljs js">    <span class="hljs-keyword">const</span> firstName = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&quot;AAA&quot;</span>);<span class="hljs-keyword">const</span> lastName = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&quot;bbb&quot;</span>);<span class="hljs-keyword">const</span> <span class="hljs-title function_">changeName</span> = (<span class="hljs-params"></span>) =&gt; &#123;  firstName.<span class="hljs-property">value</span> = <span class="hljs-string">&quot;A&quot;</span>;  lastName.<span class="hljs-property">value</span> = <span class="hljs-string">&quot;b&quot;</span>;&#125;;<span class="hljs-title function_">watch</span>([firstName, lastName], <span class="hljs-function">(<span class="hljs-params">newVal, oldVal</span>) =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;newVal:&quot;</span>, newVal, <span class="hljs-string">&quot;oldVal:&quot;</span>, oldVal);&#125;);<span class="hljs-comment">// newVal:  [&quot;A&quot;, &quot;b&quot;] oldVal:  [&quot;AAA&quot;, &quot;bbb&quot;]</span></code></pre><h5 id="侦听响应式对象"><a href="#侦听响应式对象" class="headerlink" title="侦听响应式对象"></a>侦听响应式对象</h5><p>就是侦听 reactive 对象</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> numbers = <span class="hljs-title function_">reactive</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])<span class="hljs-title function_">watch</span>(  <span class="hljs-function">() =&gt;</span> [...numbers],  <span class="hljs-function">(<span class="hljs-params">numbers, prevNumbers</span>) =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(numbers, prevNumbers)  &#125;)numbers.<span class="hljs-title function_">push</span>(<span class="hljs-number">5</span>) <span class="hljs-comment">// logs: [1,2,3,4,5] [1,2,3,4]</span></code></pre><p>想要深度侦听嵌套对象或数组时，<strong>需要 deep 设为 true</strong>,</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>(&#123;  <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>,  <span class="hljs-attr">attributes</span>: &#123;    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;&#x27;</span>,  &#125;&#125;)<span class="hljs-title function_">watch</span>(  <span class="hljs-function">() =&gt;</span> state,  <span class="hljs-function">(<span class="hljs-params">state, prevState</span>) =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(      <span class="hljs-string">&#x27;not deep&#x27;</span>,      state.<span class="hljs-property">attributes</span>.<span class="hljs-property">name</span>,      prevState.<span class="hljs-property">attributes</span>.<span class="hljs-property">name</span>    )  &#125;)<span class="hljs-title function_">watch</span>(  <span class="hljs-function">() =&gt;</span> state,  <span class="hljs-function">(<span class="hljs-params">state, prevState</span>) =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(      <span class="hljs-string">&#x27;deep&#x27;</span>,      state.<span class="hljs-property">attributes</span>.<span class="hljs-property">name</span>,      prevState.<span class="hljs-property">attributes</span>.<span class="hljs-property">name</span>    )  &#125;,  &#123; <span class="hljs-attr">deep</span>: <span class="hljs-literal">true</span> &#125;)state.<span class="hljs-property">attributes</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;Alex&#x27;</span> <span class="hljs-comment">// 日志: &quot;deep&quot; &quot;Alex&quot; &quot;Alex&quot;</span></code></pre><p>但是会发现 新的值和旧的值是一样的。这时候为了完全侦听，需要使用深拷贝了</p><h2 id="其他API"><a href="#其他API" class="headerlink" title="其他API"></a>其他API</h2><h3 id="生命周期函数"><a href="#生命周期函数" class="headerlink" title="生命周期函数"></a>生命周期函数</h3><p>em…. 去看文档吧，</p><p><a href="https://v3.cn.vuejs.org/guide/composition-api-lifecycle-hooks.html">生命周期钩子 | Vue.js (vuejs.org)</a></p><h3 id="Provide-Inject"><a href="#Provide-Inject" class="headerlink" title="Provide / Inject"></a>Provide / Inject</h3><blockquote><p>功能和之前一样，</p></blockquote><p>我们可以通过 provide 来提供数据</p><ul><li>通过 provide 方法来定义每个 property</li><li>传入俩个参数： name（提供的属性名称）， value（提供的属性值）</li></ul><p>我们可以通过 jnject 来注入需要的内容</p><ul><li>要 inject 的 property 的 name</li><li>默认值 (<strong>可选</strong>)</li></ul><pre><code class="hljs js"><span class="hljs-keyword">let</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">100</span>)<span class="hljs-keyword">let</span> info = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;wangpf&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">18</span> &#125;<span class="hljs-title function_">provide</span>(<span class="hljs-string">&quot;count&quot;</span>, <span class="hljs-title function_">readonly</span>(count))<span class="hljs-title function_">provide</span>(<span class="hljs-string">&quot;info&quot;</span>, <span class="hljs-title function_">readonly</span>(info))   <span class="hljs-comment">// 这里建议使用 readonly 对值进行包裹，防止传递的数据不会被 inject 的组件更改</span><span class="hljs-comment">// 在后代组件中 通过 inject 来获取</span><span class="hljs-keyword">const</span> count = <span class="hljs-title function_">inject</span>(<span class="hljs-string">&quot;count&quot;</span>)<span class="hljs-keyword">const</span> info = <span class="hljs-title function_">inject</span>(<span class="hljs-string">&quot;info&quot;</span>)</code></pre><h3 id="h函数"><a href="#h函数" class="headerlink" title="h函数"></a>h函数</h3><blockquote><p>vue在生成真实DOM之前，会将我们的节点转换成VNode，而VNode组合起来会形成一颗树结构，即 <strong>虚拟DOM</strong></p><p>在 template 中的 html 是使用渲染函数生成的对应的VNode</p><p>如果我们想要利用 JavaScript 来编写 createVNode 函数，生成对应的VNode 那么就可以使用 <strong>h() 函数</strong></p></blockquote><p>h() 函数是一个用于常见 VNode 的一个函数， 其实更准确的命名是 createVNode() 函数，但为了简便 vue 将其简化为 h() 函数</p><p>h() 函数接收三个参数: (标签，属性，后代)</p><pre><code class="hljs js"><span class="hljs-title function_">h</span>(  <span class="hljs-comment">// &#123;String | Object | Function&#125; tag</span>  <span class="hljs-comment">// 一个 HTML 标签名、一个组件、一个异步组件、或</span>  <span class="hljs-comment">// 一个函数式组件。</span>  <span class="hljs-comment">//</span>  <span class="hljs-comment">// 必需的。</span>  <span class="hljs-string">&#x27;div&#x27;</span>,  <span class="hljs-comment">// &#123;Object&#125; props</span>  <span class="hljs-comment">// 与 attribute、prop 和事件相对应的对象。</span>  <span class="hljs-comment">// 我们会在模板中使用。</span>  <span class="hljs-comment">//</span>  <span class="hljs-comment">// 可选的。</span>  &#123;&#125;,  <span class="hljs-comment">// &#123;String | Array | Object&#125; children</span>  <span class="hljs-comment">// 子 VNodes, 使用 `h()` 构建,</span>  <span class="hljs-comment">// 或使用字符串获取 &quot;文本 Vnode&quot; 或者</span>  <span class="hljs-comment">// 有插槽的对象。</span>  <span class="hljs-comment">//</span>  <span class="hljs-comment">// 可选的。</span>  [    <span class="hljs-string">&#x27;Some text comes first.&#x27;</span>,    <span class="hljs-title function_">h</span>(<span class="hljs-string">&#x27;h1&#x27;</span>, <span class="hljs-string">&#x27;A headline&#x27;</span>),    <span class="hljs-title function_">h</span>(<span class="hljs-title class_">MyComponent</span>, &#123;      <span class="hljs-attr">someProp</span>: <span class="hljs-string">&#x27;foobar&#x27;</span>    &#125;)  ])</code></pre><p>注意：如果没有props，可以将 children 作为第二个参数传入， 但是会产生歧义，所以一般会将 null 作为第二个参数传入，将 children 作为第三个参数传入</p><h4 id="h函数的基本使用"><a href="#h函数的基本使用" class="headerlink" title="h函数的基本使用"></a>h函数的基本使用</h4><ul><li>可以在 render 函数选项中使用</li><li>可以在 setup 函数选项中使用</li></ul><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-title function_">h</span>(<span class="hljs-string">&#x27;div&#x27;</span>, &#123; <span class="hljs-attr">class</span>: <span class="hljs-string">&#x27;app&#x27;</span> &#125;, <span class="hljs-string">&#x27;hello app&#x27;</span>)  &#125;&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">h</span>(<span class="hljs-string">&#x27;div&#x27;</span>, &#123; <span class="hljs-attr">class</span>: <span class="hljs-string">&#x27;app&#x27;</span> &#125;, <span class="hljs-string">&#x27;hello app&#x27;</span>)  &#125;&#125;</code></pre><p>这样写代码，不仅慢而且阅读性一般， 所以 推荐使用 jsx， 语法和 react一样， 这里不细说了。可看文档</p><p><a href="https://v3.cn.vuejs.org/guide/render-function.html#jsx">jsx | Vue.js (vuejs.org)</a></p><h3 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h3><p><a href="https://v3.cn.vuejs.org/guide/custom-directive.html#%E7%AE%80%E4%BB%8B">自定义指令 | Vue.js (vuejs.org)</a></p><blockquote><p>在 Vue 中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令。</p></blockquote><p>自定义指令分为俩种：</p><ul><li>自定义局部指令： 组件中通过 directives 选项，只能在当前组件中使用。</li><li>自定义全局指令： app的 directive 方法， 可以在任意组件中被使用。</li></ul><h4 id="指令的生命周期"><a href="#指令的生命周期" class="headerlink" title="指令的生命周期"></a>指令的生命周期</h4><p>一个指令定义的对象，Vue提供了如下的几个钩子函数：</p><ul><li>created：在绑定元素的 attribute 或事件监听器被应用之前调用；</li><li>beforeMount：当指令第一次绑定到元素并且在挂载父组件之前调用；</li><li>mounted：在绑定元素的父组件被挂载后调用；</li><li>beforeUpdate：在更新包含组件的 VNode 之前调用；</li><li>updated：在包含组件的 VNode 及其子组件的 VNode 更新后调用；</li><li>beforeUnmount：在卸载绑定元素的父组件之前调用；</li><li>unmounted：当指令与元素解除绑定且父组件已卸载时，只调用一次</li></ul><p>这几个钩子函数中可传入四个参数：<code>el</code>、<code>binding</code>、<code>vnode</code> 和 <code>prevNnode</code></p><h4 id="案例：时间格式化的指令"><a href="#案例：时间格式化的指令" class="headerlink" title="案例：时间格式化的指令"></a>案例：时间格式化的指令</h4><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dcce4da1d46a42638efad0e8ea7bf3ea~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="时间格式化的指令.png"></p><h3 id="Teleport"><a href="#Teleport" class="headerlink" title="Teleport"></a>Teleport</h3><p><a href="https://v3.cn.vuejs.org/guide/teleport.html">Teleport | Vue.js (vuejs.org)</a></p><blockquote><p>瞬移组件， 可以将该组件转移到其他dom元素上。</p><p>通常用于 封装模态框、土司之类的，将它放在Body元素上和 div#app 元素平级</p></blockquote><h4 id="俩个属性"><a href="#俩个属性" class="headerlink" title="俩个属性"></a>俩个属性</h4><ol><li><strong>to：</strong>  指定将其中的内容移动到的目标元素，可以使用选择器</li><li><strong>disabled：</strong> 是否禁用 teleport 的功能</li></ol><pre><code class="hljs js">&lt;teleport :to = <span class="hljs-string">&#x27;#demo&#x27;</span> &gt;  &lt; h2 &gt; hello &lt; /h2&gt;&lt;/teleport&gt;<span class="hljs-comment">// 该元素就会被转移到 id 为 demo 元素上</span></code></pre><h3 id="Vue插件"><a href="#Vue插件" class="headerlink" title="Vue插件"></a>Vue插件</h3><p><a href="https://v3.cn.vuejs.org/guide/plugins.html#%E6%8F%92%E4%BB%B6">插件 | Vue.js (vuejs.org)</a></p><blockquote><p>通常情况下，我们向Vue全局去添加一些功能时，会采用插件的模式</p></blockquote><h4 id="俩种编写方式"><a href="#俩种编写方式" class="headerlink" title="俩种编写方式"></a>俩种编写方式</h4><ol><li>对象类型<ul><li>一个 <strong>对象</strong>，但是必须包含一个 <code>install</code> 的函数，<strong>该函数会在安装插件时执行</strong></li></ul></li><li>函数类型<ul><li>一个 <strong>function</strong>，这个函数会在 <strong>安装插件时自动执行</strong></li></ul></li></ol><pre><code class="hljs js"><span class="hljs-comment">// plugin_obect.js</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  <span class="hljs-title function_">install</span>(<span class="hljs-params">app</span>) &#123;    app.<span class="hljs-property">config</span>.<span class="hljs-property">globalProperties</span>.<span class="hljs-property">$name</span> = <span class="hljs-string">&quot;wangpf&quot;</span>;  &#125;,&#125;;<span class="hljs-comment">// main.js</span><span class="hljs-keyword">import</span> plugin_object <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./plugins/plugin_object&quot;</span>;app.<span class="hljs-title function_">use</span>(plugin_object);<span class="hljs-comment">// app.vue </span><span class="hljs-keyword">import</span> &#123; getCurrentInstance &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;<span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>)&#123;  <span class="hljs-keyword">const</span> <span class="hljs-title class_">Instance</span> = <span class="hljs-title function_">getCurrentInstance</span>();  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Instance&quot;</span>, <span class="hljs-title class_">Instance</span>.<span class="hljs-property">appContext</span>.<span class="hljs-property">config</span>.<span class="hljs-property">globalProperties</span>.<span class="hljs-property">$name</span>);&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Vue.js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue3中的异步组件到底是干啥的？</title>
    <link href="/2021/07/19/64-vue3%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6/"/>
    <url>/2021/07/19/64-vue3%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="异步组件的用途是啥？"><a href="#异步组件的用途是啥？" class="headerlink" title="异步组件的用途是啥？"></a>异步组件的用途是啥？</h2><blockquote><p>减少页面首屏渲染时间，可使用 异步组件来实现</p></blockquote><p>用异步组件来实现，打包时，webpack 可将其自动分包，也就是打包到其他文件里，这样当我们访问页面时，不会立马加载该组件，当需要时才加载，这样就缩短了首屏的渲染时间，达到其目的。</p><h3 id="webpack-的代码分别"><a href="#webpack-的代码分别" class="headerlink" title="webpack 的代码分别"></a>webpack 的代码分别</h3><p>其实在默认情况下，webpack 在打包时会将组件模块都打包到一起的（比如一个 app.js 文件中）</p><p>但这有一些隐患，就是当项目不断的庞大时，那么 app.js 文件的内容就会越来越大，这样就会造成首屏渲染的速度越来越慢。</p><p>所以在打包时，我们应该对于一些不需要立即使用的组件，单独地进行拆分，拆分分成一些小的代码块 chunk.js；</p><p>这些 chunk.js 文件会在需要时从服务器上加载下来，并且运行代码，显示对应的内容。</p><h3 id="webpack-是如何对代码进行分包的？"><a href="#webpack-是如何对代码进行分包的？" class="headerlink" title="webpack 是如何对代码进行分包的？"></a>webpack 是如何对代码进行分包的？</h3><pre><code class="hljs js"><span class="hljs-title function_">import</span>(<span class="hljs-string">&#x27;./xxx/xx.js&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">&#123; xx文件中的函数名 &#125;</span>) =&gt;</span> &#123;  这里调用&#125;)</code></pre><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c9c39f621826407eb8949017f51b098b~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="webpack分包处理.png"></p><p>而异步组件就用到了这种方式来实现的。</p><h3 id="Vue-中实现异步组件"><a href="#Vue-中实现异步组件" class="headerlink" title="Vue 中实现异步组件"></a>Vue 中实现异步组件</h3><p>更详细的建议参考文档，</p><p>对于某些组件，我们希望通过异步的方式来进行加载（目的是对其进行分包处理），那么 Vue 中提供了一个函数: <strong>defineAsyncComponent</strong></p><h4 id="defineAsyncComponent-使用-（接受俩种类型的参数）"><a href="#defineAsyncComponent-使用-（接受俩种类型的参数）" class="headerlink" title="defineAsyncComponent 使用 （接受俩种类型的参数）"></a>defineAsyncComponent 使用 （接受俩种类型的参数）</h4><ul><li>类型一： 工厂函数， 该工厂函数需要返回一个 Promise 对象；</li><li>类型二： 接收一个对象类型，对异步函数进行配置；</li></ul><h4 id="工厂函数写法："><a href="#工厂函数写法：" class="headerlink" title="工厂函数写法："></a>工厂函数写法：</h4><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c75807d30324b21bb0278c0b95de906~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="异步组件工厂函数写法.png"></p><h4 id="对象写法："><a href="#对象写法：" class="headerlink" title="对象写法："></a>对象写法：</h4><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4087800ffe25465db7cbac8838fcd711~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="异步组件对象写法.png"></p><h3 id="Suspense"><a href="#Suspense" class="headerlink" title="Suspense"></a>Suspense</h3><p>一个内置的全局组件， 该组件有俩个插槽：</p><ul><li>#default: 如果 default 可以显示，那么显示 default 的内容</li><li>#fallback: 如果 default 无法显示，那么会显示 fallback 插槽的内容</li></ul><p>这个全局组件比较适合用于于异步组件， 搭配着 loading 组件来使用</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/172209d141164c37b8f3d292ffbfa6ea~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="suspense组件用法.png"></p>]]></content>
    
    
    <categories>
      
      <category>Vue.js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从Vue3源码中分析key的作用</title>
    <link href="/2021/06/03/63-%E5%88%86%E6%9E%90Key%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
    <url>/2021/06/03/63-%E5%88%86%E6%9E%90Key%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>在文档中说到：</p><ul><li>key 的特殊 attribute 主要用在 Vue 的<code>虚拟 DOM 算法</code>，在新旧 nodes 对比时辨识 <code>VNodes</code>。</li><li>如果不使用 key，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试就地<code>修改/复用相同类型元素</code>的算法。</li><li>而使用 key 时，它会基于 key 的变化<code>重新排列元素顺序</code>，并且会<code>移除/销毁 key</code> 不存在的元素。</li></ul><blockquote><p>在分析之前需要简单了解俩个概念 <strong>Vnode</strong> 和 <strong>虚拟 DOM</strong></p></blockquote><h2 id="需要了解的俩个概念"><a href="#需要了解的俩个概念" class="headerlink" title="需要了解的俩个概念"></a>需要了解的俩个概念</h2><h3 id="Vnode"><a href="#Vnode" class="headerlink" title="Vnode"></a>Vnode</h3><p>Vnode 全称为 Virtual Node， 即 虚拟节点 ，而它的本质就是一个 JS 对象</p><p><strong>以代码为例：</strong></p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;font-size: 26px;color: pink&quot;</span>&gt;</span>这是一段文本内容<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><p><strong>// vue 会把 模板中的内容 转换为 vNode（对象）</strong></p><pre><code class="hljs js"><span class="hljs-keyword">const</span> vNode = &#123;  <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;div&#x27;</span>,  <span class="hljs-attr">props</span>: &#123;    <span class="hljs-attr">class</span>: <span class="hljs-string">&#x27;text&#x27;</span>,    <span class="hljs-attr">style</span>: &#123;      <span class="hljs-string">&#x27;font-size&#x27;</span>: <span class="hljs-string">&#x27;26px&#x27;</span>,      <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;pink&#x27;</span>,    &#125;,  &#125;,  <span class="hljs-attr">children</span>: <span class="hljs-string">&#x27;这是一段文本内容&#x27;</span>,&#125;</code></pre><h3 id="虚拟-DOM"><a href="#虚拟-DOM" class="headerlink" title="虚拟 DOM"></a>虚拟 DOM</h3><p>文档中说到：</p><ul><li>虚拟 DOM 是轻量级的 JavaScript 对象，由渲染函数创建。</li><li>它包含三个参数：元素，具有数据、prop、attr 等的对象，以及一个数组。</li><li>数组是我们传递子级的地方，子级也具有所有这些参数，然后它们也可以具有子级，依此类推，直到我们构建完整的元素树为止。</li></ul><p><strong>以代码为例：</strong></p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>标题<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>  这是一段文本内容  <span class="hljs-comment">&lt;!-- 这是注释 --&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><p><strong>// 转换为虚拟 DOM</strong></p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a2ec882cf7824853b38a317ae69758e0~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="image.png"></p><h2 id="插入内容的案例"><a href="#插入内容的案例" class="headerlink" title="插入内容的案例"></a>插入内容的案例</h2><p>先看一个案例：当我们点击按钮时会插入一个数字 5 进去：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/afda7036eeda4c90a34bd734d15de71e~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="image.png"></p><p>在整个过程中，我们可以确定的是 vue 在内部这次更新对于 ul 和 button 是不需要进行更新，需要更新的是 li 的列表。</p><p>在 Vue 中，对于相同父元素的子元素节点并不会重新渲染整个列表；因为对于列表中 1、2、3、4 它们都是没有变化的。在操作真实 DOM 的时候，我们只需要在中间插入一个 5 的 li 即可。</p><p><strong>那么 Vue 中对于列表的更新究竟是如何操作的呢？</strong></p><p>Vue 事实上会对于有 key 和没有 key 会调用两个不同的方法：</p><ol><li>有 key，那么就使用 <code>patchKeyedChildren</code> 方法；</li><li>没有 key，那么久使用 <code>patchUnkeyedChildren</code> 方法；</li></ol><h2 id="Vue3-源码对于-Key-的判断"><a href="#Vue3-源码对于-Key-的判断" class="headerlink" title="Vue3 源码对于 Key 的判断"></a>Vue3 源码对于 Key 的判断</h2><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/10466024631c43e495bc0bf239466572~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="image.png"></p><h3 id="没有-key-的操作情况下，vue-源码的做法"><a href="#没有-key-的操作情况下，vue-源码的做法" class="headerlink" title="没有 key 的操作情况下，vue 源码的做法"></a>没有 key 的操作情况下，vue 源码的做法</h3><p>在没有 key 的情况下，vue3 源码是通过 <code>patchUnkeyedChildren</code> 方法来实现的</p><p>具体实现如图下：</p><p><strong>第一步：遍历循环通过 patch 方法来做比较</strong><br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0072b096b1fc4ac9aaeebef2e603d462~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="image.png"><br><strong>第二步和第三步:判断新旧 nodes 的长度来进行对节点的删除或者新增</strong><br><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a8262272a56e49abb884d604e660fd9d~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="image.png"></p><h3 id="在有-key-的情况下，vue-源码的做法"><a href="#在有-key-的情况下，vue-源码的做法" class="headerlink" title="在有 key 的情况下，vue 源码的做法"></a>在有 key 的情况下，vue 源码的做法</h3><p>有 key 的情况下，vue 对其操作有点复杂，可分为 5 个步骤。</p><p>具体如下图所示：</p><p><strong>第一步：</strong></p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5cea5c68dfac4cec884335ab5f590db8~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="image.png"></p><p><strong>第二步：</strong></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c7646dd0b51846b5afb0a4edd939e00f~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="image.png"></p><p><strong>第三步：</strong></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c8fb09995b9488d89d77f6787b5d3a9~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="image.png"></p><p><strong>第四步：</strong></p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a236d9245719426d99acd4918feb2bb3~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="image.png"></p><p><strong>第五步：</strong></p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/faf29156e94843ee9ecd2bc39e5370e7~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="image.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们可以发现，Vue 在进行 diff 算法的时候，会尽量利用我们的 key 来进行优化操作，所有在没有 key 的情况下我们的效率是非常低的。 在进行插入或者重置排序的时候，保持相同的 key 可以让 diff 算法更加高效。</p>]]></content>
    
    
    <categories>
      
      <category>Vue.js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>methods中this指向问题</title>
    <link href="/2021/05/18/62-methods%E4%B8%ADthis%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98/"/>
    <url>/2021/05/18/62-methods%E4%B8%ADthis%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在看Vue文档时，提到了 methdos中的函数是不能使用箭头函数的</p><p>这其实在Vue文档中已经给出答案了，因为 箭头函数是没有this 的， 默认this指向是指向上一级作用域。</p><p>所有如果我们在methods中的函数使用箭头函数的话，那么this指向将会指向上一级作用域， 则就是 window了。</p><h3 id="那么Vue是如何将methods中的函数this指向改变的？"><a href="#那么Vue是如何将methods中的函数this指向改变的？" class="headerlink" title="那么Vue是如何将methods中的函数this指向改变的？"></a>那么Vue是如何将methods中的函数this指向改变的？</h3><p>我们在Vue源码中可以找到答案，通过对methods中的所有函数进行遍历，并且使用bind方法来绑定this</p><ol><li>先对methods对象中的所有函数进行遍历，将函数取出。</li><li>并把函数中的this通过bind方法绑定到 publicThis 这个变量上</li><li>而这个变量是 实例上的 proxy</li></ol><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/57485f5d5993448ea793dab98b8642a9~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="image.png"></p>]]></content>
    
    
    <categories>
      
      <category>HTTP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTPS是如何保障数据传输安全的</title>
    <link href="/2021/04/02/61-HTTPS/"/>
    <url>/2021/04/02/61-HTTPS/</url>
    
    <content type="html"><![CDATA[<h2 id="需要对密码学简单认识一下"><a href="#需要对密码学简单认识一下" class="headerlink" title="需要对密码学简单认识一下"></a>需要对密码学简单认识一下</h2><p>什么是对称加密、非对称加密、单向散列、消息认证码、数字签名、证书、PKI 体系</p><p><strong>信息安全</strong></p><ul><li>机密性：信息是否被泄漏。使用对称加密、非对称加密来保证</li><li>完整性：信息是否被修改，使用单向散列、消息认证码、数字签名来保证</li><li>真实性：发送者是否冒名顶替的。使用消息认证码、数字签名来保证</li><li>不可否认性：做过了会不会抵赖。使用数字签名来保证</li></ul><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p><strong>实现信息安全的机密性，那么可以使用对称加密</strong></p><p><strong>什么是对称加密：</strong></p><ul><li>使用同一个密钥进行加密解密，算法速度快。</li><li>对称加密常见的算法是 DES 和 AES。</li><li>对称加密算法常用来加密大量内容。</li></ul><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/78083874b76d4995b0d277bb293eb1c0~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="对称加密.png"></p><h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><p><strong>实现信息安全的机密性，那么可以使用非对称加密</strong></p><p><strong>什么是非对称加密：</strong></p><ul><li>拥有俩个密钥：公钥和私钥，公钥公开的给别人，私钥自己保存着。</li><li>公钥加密后的密文可以使用私钥来解密</li><li>私钥加密后的密文可以使用公钥来解密</li><li>对比与 对称加密要慢上许多</li><li>常见的非对称算法是 RSA</li></ul><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/41f50a747b3e4fc1a5c50cfb08819dda~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="非对称加密.png"></p><p>使用非对称加密算法可以直接加密信息。比如小明生成自己的密钥时，把公钥对外公开。小红想向小明传输信息可使用小明的公钥对消息加密后再发送，然后小明收到后可以用自己的私钥来解密。其他人即时得到加密后的信息也无法破解。</p><p><strong>不过这样使用开销很大，一般现实中使用对称加密来加密原始消息，使用非对称加密来传输用来加密消息的对称密钥，（用非对称加密来加密对称加密的密钥。）</strong></p><h3 id="单向散列（hash）"><a href="#单向散列（hash）" class="headerlink" title="单向散列（hash）"></a>单向散列（hash）</h3><p><strong>可以用单向散列来证明数据的完整性</strong></p><p>不定长的数经散发处理后会压缩成固定长度。其特点是相同的输入一定有相同的输出，不同的输入几乎没有相同的输出，根据输出无法还原输入。</p><p>场景举例：我们再网站上对外公布了一个 10Gb 大小的资源链接和对应的 sha256 哈希值。用户从第三方下载到类似资源后可以做 sha256 散列运算，如果计算的哈希值和我们原始资源的哈希值相同，就表示数据是真实完整的</p><p>常见的散列算法有：MD5(<strong>不安全</strong>)、SHA1、SHA256</p><h3 id="消息认证码（hmac）"><a href="#消息认证码（hmac）" class="headerlink" title="消息认证码（hmac）"></a>消息认证码（hmac）</h3><p><strong>消息认证码就是带密钥的散列函数</strong></p><p><strong>特点：</strong></p><ol><li>大量信息经过处理变成短小固定长度值（有点类似单向散列）</li><li>消息不同或者密钥不同会导致结果不同</li><li>无法从结果“解密”出原始信息</li></ol><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c467eedef60d4d0c9514e4c39888126e~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="消息认证码.png"></p><p><strong>toekn = header（算法名）+ ‘.’ + payload(有用信息) + ‘.’ + hmac(header + ‘.’ + patload,密钥)</strong></p><p>使用场景:JWT 鉴权使用的 token 就用到了消息认证码。当服务器把 token 发送给客户端，客户端下次请求时要带上 token，服务器收到 token 后会截取 header + ‘.’ + payload 做 hmac 运算，得到的结果和 token 的第三部分即 hmac 做对比。</p><h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p>小明使用私钥对消息加密即<strong>签名</strong>，其他人使用小明的公钥如果能解密表示消息一定是小明发的。</p><p><strong>签名能防止抵赖的发生，用来保证信息的不可否认性</strong></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b8f7d6aa8131464f91b8f9f30e0f4132~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="数字签名.png"></p><h3 id="证书与-PKI-体系"><a href="#证书与-PKI-体系" class="headerlink" title="证书与 PKI 体系"></a>证书与 PKI 体系</h3><p>一个证书上包含一些公开的明文信息以及证书颁发者对该信息的签名(私钥加密)。任何人想验证证书信息的真伪，只需要用证书颁发者的公钥对签名进行解密，再和证书上的明文信息做对比即可。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b882f0b46cb49c3b3b7af869881d2b5~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="image.png"></p><h2 id="HTTPS-是如何做密钥协商的"><a href="#HTTPS-是如何做密钥协商的" class="headerlink" title="HTTPS 是如何做密钥协商的"></a>HTTPS 是如何做密钥协商的</h2><h3 id="什么是-HTTPS"><a href="#什么是-HTTPS" class="headerlink" title="什么是 HTTPS"></a>什么是 HTTPS</h3><p>HTTPS 是超文本传输安全协议,在 HTTP 的基础上通过传输加密和身份认证保证了传输过程的安全性。</p><p><strong>HTTPS = HTTP + SSL</strong></p><h3 id="HTTP-与-HTTPS-的区别"><a href="#HTTP-与-HTTPS-的区别" class="headerlink" title="HTTP 与 HTTPS 的区别"></a>HTTP 与 HTTPS 的区别</h3><ul><li>HTTP 的 url 是 http:// 开头 ， HTTPS 的 url 是 https:// 开头。</li><li>HTTP 使用 80 端口 ， HTTPS 使用 443 端口。</li><li>HTTP 数据传是明文传输，不安全。 HTTPS 数据加密了，可保证数据私密性、完整性、防止中间人攻击。</li></ul><h3 id="SSL-TLS-协议流程（HTTPS-握手过程）"><a href="#SSL-TLS-协议流程（HTTPS-握手过程）" class="headerlink" title="SSL/TLS 协议流程（HTTPS 握手过程）"></a>SSL/TLS 协议流程（HTTPS 握手过程）</h3><p><strong>详细流程：</strong></p><ol><li>浏览器将自己支持的一套加密算法发给服务器，同时发一个浏览器随机数</li><li>服务器向浏览器发送选择的加密算法、服务器生成的随机数、服务器数字证书</li><li>浏览器收到证书后对证书的 CA 签名进行验证，如果验证通过，会从证书中拿到服务器的公钥。</li><li>浏览器对浏览器随机数+服务器随机数进行处理，生成预备主密码。</li><li>浏览器使用服务器的公钥对预备主密码进行加密，发给服务器。</li><li>服务器收到后使用自己的私钥解密出预备主密钥。</li><li>浏览器和服务器分别使用预备主密钥和俩个随机数，生成共享主密钥。</li><li>二者使用共享主密钥，使用对称加密算法加密数据。</li></ol><p><strong>简单的来说：</strong></p><ol><li>浏览器使用 HTTPS 的 url 访问服务器与服务器建立 SSL 连接。</li><li>服务器收到请求行，会发送包含公钥的证书</li><li>浏览器使用公钥加密对称密钥并发送给服务器</li><li>服务器使用私钥解密对称密钥</li></ol>]]></content>
    
    
    <categories>
      
      <category>HTTP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>keep-alive与多路复用</title>
    <link href="/2021/03/28/60-keep-alive%E5%92%8C%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
    <url>/2021/03/28/60-keep-alive%E5%92%8C%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP 1.0"></a>HTTP 1.0</h2><p>在HTTP1.0版本，存在一个问题：建立的一次连接，只有包含一个请求响应(也就是对应一个资源)。</p><p>如果有多个请求，那么效率就会很低。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c6190da97624831b3345130f2a98e0c~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="http1.0.png"></p><h2 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP 1.1"></a>HTTP 1.1</h2><p>在HTTP 1.1 中 <strong>connection: keep-alive</strong> 是默认开启的</p><h3 id="改进一：连接复用"><a href="#改进一：连接复用" class="headerlink" title="改进一：连接复用"></a>改进一：<strong>连接复用</strong></h3><p>一次连接，可以有多个请求响应（对应多个资源）。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2348d9bf29144a04baf5e62a90cf3849~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="连接复用.png"></p><h3 id="改进二：增加流水线（pipeline）"><a href="#改进二：增加流水线（pipeline）" class="headerlink" title="改进二：增加流水线（pipeline）"></a>改进二：<strong>增加流水线（pipeline）</strong></h3><p>下一次的请求不需要等待上一个响应来之后再发送。</p><p>但响应的顺序是不变的，FIFO（先进先出）</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cbc27b1a983e4f8d9ae43dbb35c5352f~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="image.png"></p><p>依旧存在的问题：</p><ul><li>请求是按次序的，后来者需要排队等待。</li><li>请求头大多类似，重复传输浪费资源。</li><li>同一域名的浏览器有最大并行请求限制。</li></ul><h2 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP 2.0"></a>HTTP 2.0</h2><h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><p>由于 HTTP 1.X 是基于文本的，因为是文本，就导致了它必须是个整体，在传输是不可切割的，只能整体去传。</p><p>但 HTTP 2.0 是基于二进制流的。有两个非常重要的概念，分别是<strong>帧（frame）和流（stream）</strong></p><ul><li>帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流。</li><li>流就是多个帧组成的数据流。</li></ul><p>将 HTTP 消息分解为独立的帧，交错发送，然后在另一端重新组装。</p><ul><li>并行交错地发送多个请求，请求之间互不影响。</li><li>并行交错地发送多个响应，响应之间互不干扰。</li><li>使用一个连接并行发送多个请求和响应。</li></ul><p><strong>简单的来说： 在同一个TCP连接中，同一时刻可以发送多个请求和响应，且不用按照顺序一一对应。</strong></p><p>之前是同一个连接只能用一次， 如果开启了keep-alive，虽然可以用多次，但是同一时刻只能有一个HTTP请求。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d638d0ea6d734699b31ef18cf3e882b2~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="多路复用.png"></p>]]></content>
    
    
    <categories>
      
      <category>HTTP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一次弄懂HTTP缓存</title>
    <link href="/2021/03/27/59-HTTP%E7%BC%93%E5%AD%98/"/>
    <url>/2021/03/27/59-HTTP%E7%BC%93%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h2 id="情况一-Cache-Control-max-age-60-时"><a href="#情况一-Cache-Control-max-age-60-时" class="headerlink" title="情况一:  Cache-Control:max-age = 60 时"></a>情况一:  <strong>Cache-Control:max-age = 60 时</strong></h2><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0dbc063671b041349511e3beac85d0fe~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="情况一.png"></p><h2 id="情况二-Cache-Control-max-age-0-or-no-cache-时"><a href="#情况二-Cache-Control-max-age-0-or-no-cache-时" class="headerlink" title="情况二: Cache-Control:max-age = 0 or no-cache 时"></a>情况二: <strong>Cache-Control:max-age = 0 or no-cache 时</strong></h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a9114f6864f4e73b3e2b5e1c6f47405~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="情况二.png"></p><h2 id="HTTP缓存流程图"><a href="#HTTP缓存流程图" class="headerlink" title="HTTP缓存流程图"></a>HTTP缓存流程图</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/694ffc8bfd0743a98980b18510c57521~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="HTTP缓存流程图.png"></p><h2 id="HTTP缓存相关面试题"><a href="#HTTP缓存相关面试题" class="headerlink" title="HTTP缓存相关面试题"></a>HTTP缓存相关面试题</h2><h3 id="1-说一下浏览器的缓存机制（HTTP如何控制缓存的）"><a href="#1-说一下浏览器的缓存机制（HTTP如何控制缓存的）" class="headerlink" title="1.说一下浏览器的缓存机制（HTTP如何控制缓存的）"></a>1.说一下浏览器的缓存机制（HTTP如何控制缓存的）</h3><ul><li>浏览器第一次向服务器发请求资源，服务器响应报文的状态是200，响应头会带上<strong>Cache-Control、Etag</strong>字段 。 浏览器收到响应后会把资源存到本地。</li><li>当浏览器再次发送请求获取该资源时，浏览器会先检查该资源是否过期（通过<strong>Cache-Control:max-age = 时间</strong>）。如果在时间内，就直接使用该资源。</li><li>如果时间过期，则发送请求询问该资源是否可以用。 请求头包含 <strong>If-None-Match</strong>，也就是之前响应报文中的 <strong>Etag</strong>。</li><li>服务器收到请求后通过  <strong>If-None-Match</strong>里的Etag和新计算的Etag做对比，<strong>如果匹配，则直接返回一个状态码 304 ，不包含任何响应体报文</strong>，告诉浏览器该资源可以用。 <strong>如果不匹配，则返回一个状态码为200再带上 Cache-Control、Etag和原始资源的新报文</strong></li><li>如果不存在Etag，则用 Last-Modified 和 if-Modified-Since 做类似的判断。</li></ul><h3 id="2-Last-Modified、If-Modified-Since字段有什么作用？"><a href="#2-Last-Modified、If-Modified-Since字段有什么作用？" class="headerlink" title="2.Last-Modified、If-Modified-Since字段有什么作用？"></a>2.Last-Modified、If-Modified-Since字段有什么作用？</h3><p>俩个都表示资源的最后修改时间</p><p>Last-Modified 则是 是由服务器发送给客户端的HTTP请求头标签</p><p>If-Modified-Since 则是由客户端发送给服务器的HTTP请求头标签</p><p><strong>服务器可根据请求的文件修改时间和真实的文件修改时间做比较，来判断资源是否过期。</strong></p><h3 id="3-Etag和If-None-Match字段有什么作用？"><a href="#3-Etag和If-None-Match字段有什么作用？" class="headerlink" title="3.Etag和If-None-Match字段有什么作用？"></a>3.Etag和If-None-Match字段有什么作用？</h3><p>Etag相当于给资源生成了一个独一无二的标识，当资源被修改了，Etag就会改变。 作用和 Last-Modified 类似。</p><h3 id="4-Last-Modified和Etag哪个更好？"><a href="#4-Last-Modified和Etag哪个更好？" class="headerlink" title="4.Last-Modified和Etag哪个更好？"></a>4.Last-Modified和Etag哪个更好？</h3><p>二者的作用一样，但还有一些细微的差异</p><ol><li>Last-Modified的单位是秒，如果一秒内对文件进行修改了，那么使用Last-Modified不变，而Etag一般会发生改变。</li><li>语义上有差别， 一个是 文件的修改时间，一个是文件的唯一标识。</li><li>使用 Last-Modified，浏览器会直接看到文件的修改时间，这个信息的暴露是不好的。</li></ol><h3 id="5-Expires字段是什么意思？"><a href="#5-Expires字段是什么意思？" class="headerlink" title="5.Expires字段是什么意思？"></a>5.Expires字段是什么意思？</h3><p>Expires是HTTP1.0版本的报文字段，代表资源的过期时间，如果设置了Cache-control: max-age=过期秒数，Expires会被忽略。</p><p>现在大多数使用Cache-Control替代</p><h3 id="6-Expires和Cache-Control有什么区别？"><a href="#6-Expires和Cache-Control有什么区别？" class="headerlink" title="6.Expires和Cache-Control有什么区别？"></a>6.Expires和Cache-Control有什么区别？</h3><ol><li><strong>Expires的值代表一个GMT的时间点</strong>，表示到什么时间点过期；</li><li><strong>Cache-control:max-age = value</strong> ,这个value是以秒为单位的时间段，代表有效期是多少秒。</li><li>Cache-control可以设置更复杂的场景，比如：<strong>Cache-control：no-cahce 、 no-store 、private</strong></li></ol><p>最重要的一点，如果使用Expires，那么服务器告诉所有浏览器某资源在2021年11月11日到期，到了该时间点时，则需要该资源的每一个浏览器都会在同一时间发送请求。而用Cache-control，那么服务器告诉所有浏览器某资源各自存储365天，由于每一个浏览器请求的时间不一样，所以需要该资源的浏览器不会同时发请求。</p><h3 id="7-Cache-Control-max-age-3600是什么意思？"><a href="#7-Cache-Control-max-age-3600是什么意思？" class="headerlink" title="7.Cache-Control: max-age=3600是什么意思？"></a>7.Cache-Control: max-age=3600是什么意思？</h3><p>就是服务器告诉浏览器，这个资源在本地缓存下来，如果再次需要该资源并且是在3600秒内，那么就不要发请求而直接使用该资源，如果超过3600秒，则发送请求向服务器询问是否能够继续使用。</p><h3 id="8-Cache-Control-no-cache是什么意思？"><a href="#8-Cache-Control-no-cache是什么意思？" class="headerlink" title="8.Cache-Control: no-cache是什么意思？"></a>8.Cache-Control: no-cache是什么意思？</h3><p>相当于 max-age = 0, 就是告诉浏览器，收到这个资源先缓存下来，下次需要该资源时先向服务器确认该资源的有效性，再使用。</p><h3 id="9-Cache-Control-no-store是什么意思？"><a href="#9-Cache-Control-no-store是什么意思？" class="headerlink" title="9.Cache-Control: no-store是什么意思？"></a>9.Cache-Control: no-store是什么意思？</h3><p>告诉浏览器，不要缓存该资源。需要该资源时请求服务器，服务器会直接给新的。</p><h3 id="10-Cache-Control-private、public分别是什么意思？"><a href="#10-Cache-Control-private、public分别是什么意思？" class="headerlink" title="10.Cache-Control: private、public分别是什么意思？"></a>10.Cache-Control: private、public分别是什么意思？</h3><p>private是告诉中间的代理服务器不要缓存资源，只让目标浏览器缓存。</p><p>public表示任何情况下都能缓存。</p><h3 id="11-Cache-Control-no-cache-和-Cache-Control-no-store-有什么区别？"><a href="#11-Cache-Control-no-cache-和-Cache-Control-no-store-有什么区别？" class="headerlink" title="11.Cache-Control: no-cache 和 Cache-Control: no-store 有什么区别？"></a>11.Cache-Control: no-cache 和 Cache-Control: no-store 有什么区别？</h3><p>一个是先缓存下来但不直接使用， 另一个是完全不缓存。</p>]]></content>
    
    
    <categories>
      
      <category>HTTP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重写数组遍历方法（forEach,filter,map,reduce）</title>
    <link href="/2021/03/20/58-%E9%87%8D%E5%86%99JS%E6%96%B9%E6%B3%95%E4%BA%8C/"/>
    <url>/2021/03/20/58-%E9%87%8D%E5%86%99JS%E6%96%B9%E6%B3%95%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="直接上代码了"><a href="#直接上代码了" class="headerlink" title="直接上代码了"></a>直接上代码了</h2><pre><code class="hljs js"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myForEach</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">callback</span>) &#123;    <span class="hljs-keyword">let</span> arg2 = <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>] || <span class="hljs-variable language_">window</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span>; i++) &#123;      callback.<span class="hljs-title function_">apply</span>(arg2, [<span class="hljs-variable language_">this</span>[i], i, <span class="hljs-variable language_">this</span>]);    &#125;  &#125;;  <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myMap</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">callback</span>) &#123;    <span class="hljs-keyword">let</span> arg2 = <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>] || <span class="hljs-variable language_">window</span>;    <span class="hljs-keyword">let</span> newArr = [];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span>; i++) &#123;      <span class="hljs-comment">// 这里需要对对象进行深拷贝，这里就省略了</span>      newArr.<span class="hljs-title function_">push</span>(callback.<span class="hljs-title function_">apply</span>(arg2, [<span class="hljs-variable language_">this</span>[i], i, <span class="hljs-variable language_">this</span>]));    &#125;    <span class="hljs-keyword">return</span> newArr;  &#125;;  <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myFilter</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">callback</span>) &#123;    <span class="hljs-keyword">let</span> arg2 = <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>] || <span class="hljs-variable language_">window</span>;    <span class="hljs-keyword">let</span> newArr = [];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span>; i++) &#123;       <span class="hljs-comment">// 这里需要对对象进行深拷贝，这里就省略了</span>      callback.<span class="hljs-title function_">apply</span>(arg2, [<span class="hljs-variable language_">this</span>[i], i, <span class="hljs-variable language_">this</span>]) ? newArr.<span class="hljs-title function_">push</span>(<span class="hljs-variable language_">this</span>[i]) : newArr;    &#125;    <span class="hljs-keyword">return</span> newArr;  &#125;;  <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myEvery</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">callback</span>) &#123;    <span class="hljs-keyword">let</span> arg2 = <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>] || <span class="hljs-variable language_">window</span>;    <span class="hljs-keyword">let</span> gate = <span class="hljs-literal">true</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span>; i++) &#123;      <span class="hljs-keyword">if</span> (!callback.<span class="hljs-title function_">apply</span>(arg2, [<span class="hljs-variable language_">this</span>[i], i, <span class="hljs-variable language_">this</span>])) &#123;        gate = <span class="hljs-literal">false</span>;        <span class="hljs-keyword">break</span>;      &#125;    &#125;    <span class="hljs-keyword">return</span> gate;  &#125;;  <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">mySome</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">callback</span>) &#123;    <span class="hljs-keyword">let</span> arg2 = <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>] || <span class="hljs-variable language_">window</span>;    <span class="hljs-keyword">let</span> gate = <span class="hljs-literal">false</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span>; i++) &#123;      <span class="hljs-keyword">if</span> (callback.<span class="hljs-title function_">apply</span>(arg2, [<span class="hljs-variable language_">this</span>[i], i, <span class="hljs-variable language_">this</span>])) &#123;        gate = <span class="hljs-literal">true</span>;        <span class="hljs-keyword">break</span>;      &#125;    &#125;    <span class="hljs-keyword">return</span> gate;  &#125;;  <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myReduce</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">callback, initialValue</span>) &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span>; i++) &#123;        <span class="hljs-comment">// 这里需要对对象进行深拷贝，这里就省略了</span>      initialValue = <span class="hljs-title function_">callback</span>(initialValue, <span class="hljs-variable language_">this</span>[i], i, <span class="hljs-variable language_">this</span>);    &#125;    <span class="hljs-keyword">return</span> initialValue;  &#125;;  <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myReduceRight</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">callback, initialValue</span>) &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;        <span class="hljs-comment">// 这里需要对对象进行深拷贝，这里就省略了</span>      initialValue = <span class="hljs-title function_">callback</span>(initialValue, <span class="hljs-variable language_">this</span>[i], i, <span class="hljs-variable language_">this</span>);    &#125;    <span class="hljs-keyword">return</span> initialValue;  &#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重写bind,call,apply方法</title>
    <link href="/2021/03/17/57-%E9%87%8D%E5%86%99JS%E6%96%B9%E6%B3%95/"/>
    <url>/2021/03/17/57-%E9%87%8D%E5%86%99JS%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>不能使用ES6的语法糖来实现，比如（解构赋值，symbol）</strong></p><h2 id="call方法"><a href="#call方法" class="headerlink" title="call方法"></a>call方法</h2><p>想要对call 的重写，前提是需要知道 call 的几个特点：(<strong>假设有一个 函数 test</strong>)</p><ol><li>test 调用 call() ,那么就会执行 text。</li><li>test 中的this 指向 call 的第一个参数。</li><li>call 的第二个参数开始，都在test函数的参数列表中</li></ol><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>,<span class="hljs-variable language_">arguments</span>);&#125;test.<span class="hljs-title function_">call</span>(&#123;<span class="hljs-attr">a</span>:<span class="hljs-number">1</span>,<span class="hljs-attr">b</span>:<span class="hljs-number">2</span>&#125;,<span class="hljs-string">&#x27;张三&#x27;</span>,<span class="hljs-string">&#x27;李四&#x27;</span>)</code></pre><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/788aeb81c07d445dade1b137033e51e5~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="call.png"></p><h3 id="重写call"><a href="#重写call" class="headerlink" title="重写call"></a>重写call</h3><p>在重写call前，我需要知道一个知识：</p><p><strong>谁调用这个函数，这个函数内的this就指向谁</strong></p><p>上述的 test 函数，默认是window调用它的，所以 test函数的this就指向 window</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><pre><code class="hljs js"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myCall</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">context</span>) &#123;  context = context ? <span class="hljs-title class_">Object</span>(context) : <span class="hljs-variable language_">window</span>; <span class="hljs-comment">// 简化了， 这里就直接把数据类型都转换为Object了</span>  <span class="hljs-keyword">let</span> uniqueKey = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>().<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// 创建一个唯一值，避免方法名冲突</span>  context[uniqueKey] = <span class="hljs-variable language_">this</span>;  <span class="hljs-keyword">let</span> args = [];  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span>; i++) &#123;    args.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;arguments[&#x27;</span> + i + <span class="hljs-string">&#x27;]&#x27;</span>);  &#125;  <span class="hljs-keyword">const</span> result = <span class="hljs-built_in">eval</span>(<span class="hljs-string">&#x27;context[uniqueKey](&#x27;</span> + args + <span class="hljs-string">&#x27;)&#x27;</span>);  <span class="hljs-keyword">delete</span> context[uniqueKey];  <span class="hljs-keyword">return</span> result;&#125;;</code></pre><h2 id="重写-apply"><a href="#重写-apply" class="headerlink" title="重写 apply"></a>重写 apply</h2><p>它和 call 的区别就在于第二个参数是数组.</p><p>但还是需要注意一下：</p><ol><li>apply 的 第二个参数接收 数组</li><li>apply <strong>只取到第二个参数</strong>，从第三个参数开始到最后直接被忽略</li><li>apply 的 第二个参数，<strong>如果是 object/funciton/null/undefined ,那么 arguments.length 直接为 0</strong></li><li>apply 的 第二个参数， <strong>如果是 number/string/boolean，会报错</strong></li></ol><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code class="hljs js"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myApply</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">context, args</span>) &#123;  context = context ? <span class="hljs-title class_">Object</span>(context) : <span class="hljs-variable language_">window</span>;  <span class="hljs-keyword">let</span> uniqueKey = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>().<span class="hljs-title function_">toString</span>();  context[uniqueKey] = <span class="hljs-variable language_">this</span>;  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> args === <span class="hljs-string">&#x27;number&#x27;</span> || <span class="hljs-keyword">typeof</span> args === <span class="hljs-string">&#x27;string&#x27;</span> || <span class="hljs-keyword">typeof</span> args === <span class="hljs-string">&#x27;boolean&#x27;</span>) &#123;    <span class="hljs-keyword">throw</span>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&#x27;CreateListFromArrayLike called on non-object&#x27;</span>);  &#125;  <span class="hljs-keyword">if</span> (!args || <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(args) === <span class="hljs-literal">false</span>) &#123;    <span class="hljs-keyword">return</span> context[uniqueKey]();  &#125;  <span class="hljs-comment">// 代码到这里了就证明args是一个数组了，</span>  <span class="hljs-keyword">let</span> result = context[uniqueKey](...args);  <span class="hljs-keyword">delete</span> context[uniqueKey];  <span class="hljs-keyword">return</span> result;&#125;;</code></pre><h2 id="重写bind"><a href="#重写bind" class="headerlink" title="重写bind"></a>重写bind</h2><p>写之前，先看一看bind都有哪些特点：(<strong>假设有一个 函数 test</strong>)</p><ol><li>使用 bind() 时，test 不会执行，而是<strong>返回一个新的函数</strong></li><li>bind 的第一个参数和 call,apply 一样的特点</li><li>bind 可以分离 text 的参数  （<strong>函数柯里化</strong>）<ul><li>bind 可以接收一部分参数，返回的新函数也可以接收一部分参数</li></ul></li><li><strong>返回的新函数可以作为构造函数，而this指向的是 test 构造出来的实例</strong><ul><li>实例应该继承test构造函数上的原型属性</li></ul></li></ol><p>根据以上特点来实现一下</p><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code class="hljs js"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myBind</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">context</span>) &#123;   <span class="hljs-keyword">let</span> _this = <span class="hljs-variable language_">this</span>,     <span class="hljs-comment">// bind()传的参数列表</span>     args = [].<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>, <span class="hljs-number">1</span>), <span class="hljs-comment">// 去掉第一个，因为第一个是this指向的东西</span>     _tempFn = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;&#125;;  <span class="hljs-comment">// 作为原型链继承的中间件函数</span>      <span class="hljs-keyword">let</span> newFn = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;     <span class="hljs-comment">// 返回的新函数的参数列表</span>     <span class="hljs-keyword">let</span> newArgs = [].<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>);     <span class="hljs-keyword">return</span> _this.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span> <span class="hljs-keyword">instanceof</span> newFn ? <span class="hljs-variable language_">this</span> : context, args.<span class="hljs-title function_">concat</span>(newArgs));   &#125;;   <span class="hljs-comment">// newFn.prototype = this.prototype  // 这个共用了一个原型，不太好</span>   _tempFn.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;   newFn.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_">_tempFn</span>();   <span class="hljs-keyword">return</span> newFn; &#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实现几个经典排序算法</title>
    <link href="/2021/03/16/56-%E5%AE%9E%E7%8E%B0%E5%87%A0%E4%B8%AA%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>/2021/03/16/56-%E5%AE%9E%E7%8E%B0%E5%87%A0%E4%B8%AA%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h3 id="冒泡排序实现思路"><a href="#冒泡排序实现思路" class="headerlink" title="冒泡排序实现思路"></a>冒泡排序实现思路</h3><blockquote><p>冒泡排序算法相对其他排序运行效率较低，但是在概念上他是排序算法中最简单的</p></blockquote><p><strong>思路：</strong></p><ol><li>依次比较相邻的数字，如果前一个比后一个大，那么就交换。 即 小数放在前，大数放在后边。</li><li>然后比较第2个数和第3个数，小数在前，大数在后，依次类推则将最大的数滚动到最后边。</li><li>开始第二趟，将第二大的数移动至倒数第二位</li><li>依次类推…..</li></ol><p>最后需要 第 （n-1） 趟就能完成排序。</p><p>参考动画：<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fac3f7394d324da589050a06e6850be6~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="冒泡排序动画"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayList</span> &#123;  array = []  <span class="hljs-comment">// 用于插入数据</span>  <span class="hljs-title function_">insert</span>(<span class="hljs-params">item</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">array</span>.<span class="hljs-title function_">push</span>(item)  &#125;  <span class="hljs-title function_">swap</span>(<span class="hljs-params">m,n</span>) &#123;    <span class="hljs-keyword">let</span> temp = <span class="hljs-variable language_">this</span>.<span class="hljs-property">array</span>[m]    <span class="hljs-variable language_">this</span>.<span class="hljs-property">array</span>[m] = <span class="hljs-variable language_">this</span>.<span class="hljs-property">array</span>[n]    <span class="hljs-variable language_">this</span>.<span class="hljs-property">array</span>[n] = temp  &#125; <span class="hljs-comment">// 冒泡排序  （核心代码在这里）</span>  <span class="hljs-title function_">bubblesSort</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">array</span> === <span class="hljs-literal">null</span> || <span class="hljs-variable language_">this</span>.<span class="hljs-property">array</span>.<span class="hljs-property">length</span> &lt; <span class="hljs-number">2</span>) &#123; <span class="hljs-keyword">return</span> &#125;    <span class="hljs-comment">// 这里注意需要 length -1 。 原因是 如果是最后一个数会有bug，因为没有 第最后一个数+1的数</span>    <span class="hljs-comment">// 也可以理解将 length -1 为 比较的次数</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-variable language_">this</span>.<span class="hljs-property">array</span>.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; j; i++) &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">array</span>[i] &gt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">array</span>[i + <span class="hljs-number">1</span>]) &#123;          <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">swap</span>(i, i + <span class="hljs-number">1</span>)        &#125;      &#125;    &#125;  &#125;<span class="hljs-keyword">let</span> list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>()list.<span class="hljs-title function_">insert</span>(<span class="hljs-number">12</span>)list.<span class="hljs-title function_">insert</span>(<span class="hljs-number">2</span>)list.<span class="hljs-title function_">insert</span>(<span class="hljs-number">45</span>)list.<span class="hljs-title function_">insert</span>(<span class="hljs-number">123</span>)list.<span class="hljs-title function_">insert</span>(<span class="hljs-number">481</span>)list.<span class="hljs-title function_">insert</span>(<span class="hljs-number">56</span>)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(list.<span class="hljs-property">array</span>);   <span class="hljs-comment">// [ 12, 2, 45, 123, 481, 56 ]</span><span class="hljs-comment">// 调用冒泡排序</span>list.<span class="hljs-title function_">bubblesSort</span>()<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(list.<span class="hljs-property">array</span>);  <span class="hljs-comment">// [ 2, 12, 45, 56, 123, 481 ]</span></code></pre><h3 id="冒泡排序的效率"><a href="#冒泡排序的效率" class="headerlink" title="冒泡排序的效率"></a>冒泡排序的效率</h3><p><strong>冒泡排序的比较次数（假设每一次比较都需要交换）：</strong></p><ul><li>按照代码中来说，一共有6个数字</li><li>第一次循环进行 6 次比较，第二次循环进行 5 次比较，第三次循环进行 4 次比较…..直到最后一趟进行一次比较</li><li>对于 6 个数据来说就是： 6+5+4+3+2+1 次</li><li>那么对于 n 个数据来就是： (n-1) + (n-2) + (n-3) + …..+ 1 = *<em>n * (n-1) / 2*</em></li></ul><p>通过大O表示法来推，则为 O(N²)</p><p>因为只考虑了每一次比较就需要交换， 所有大致的平均时间复杂度为: O(N²)</p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="选择排序实现思路"><a href="#选择排序实现思路" class="headerlink" title="选择排序实现思路"></a>选择排序实现思路</h3><p><strong>思路：</strong></p><p>从第一个数开始与后面的每个数进行比较，找出最小的（默认是升序），然后交换，以此类推，直到排序结束。</p><p><strong>代码实现步骤思路：</strong></p><ol><li>先取出第一个数的下标值为变量 <strong>min</strong> ， 循环遍历数组的长度</li><li>在循环中 用第一个数 分别比较每个数，最后将最小的数的下标值赋值给 <strong>min</strong></li><li>将俩个数交换。这样就实现了第一个数为最小值</li><li>最后在整体套个循环，循环上面的思路即可</li></ol><p>参考动画：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d3440515605140ac8c6efe7e9a05261f~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="select.gif"></p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayList</span> &#123;  array = [];  <span class="hljs-comment">// 用于插入数字</span>  <span class="hljs-title function_">insert</span>(<span class="hljs-params">item</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">array</span>.<span class="hljs-title function_">push</span>(item);  &#125;  <span class="hljs-comment">// 交换两个数字</span>  <span class="hljs-title function_">swap</span>(<span class="hljs-params">m, n</span>) &#123;    <span class="hljs-keyword">let</span> temp = <span class="hljs-variable language_">this</span>.<span class="hljs-property">array</span>[m];    <span class="hljs-variable language_">this</span>.<span class="hljs-property">array</span>[m] = <span class="hljs-variable language_">this</span>.<span class="hljs-property">array</span>[n];    <span class="hljs-variable language_">this</span>.<span class="hljs-property">array</span>[n] = temp;  &#125;  <span class="hljs-comment">// 选择排序</span>  <span class="hljs-title function_">selectSort</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-comment">// 外部的循环表示 : 从0的位置开始取出数据，直到倒数第二个数的位置，即 length - 2</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">array</span>.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; j++) &#123;      <span class="hljs-keyword">let</span> min = j;      <span class="hljs-comment">// 内部的循环表示：从 min+1位置开始，和后面的数进行比较</span>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = min + <span class="hljs-number">1</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">array</span>.<span class="hljs-property">length</span>; i++) &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">array</span>[min] &gt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">array</span>[i]) &#123;          min = i;        &#125;      &#125;      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">swap</span>(min, j);    &#125;  &#125;  &#125;<span class="hljs-keyword">let</span> list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();list.<span class="hljs-title function_">insert</span>(<span class="hljs-number">12</span>);list.<span class="hljs-title function_">insert</span>(<span class="hljs-number">2</span>);list.<span class="hljs-title function_">insert</span>(<span class="hljs-number">45</span>);list.<span class="hljs-title function_">insert</span>(<span class="hljs-number">123</span>);list.<span class="hljs-title function_">insert</span>(<span class="hljs-number">481</span>);list.<span class="hljs-title function_">insert</span>(<span class="hljs-number">56</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(list.<span class="hljs-property">array</span>); <span class="hljs-comment">// [ 12, 2, 45, 123, 481, 56 ]</span><span class="hljs-comment">// 调用选择排序</span>list.<span class="hljs-title function_">selectSort</span>();<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(list.<span class="hljs-property">array</span>); <span class="hljs-comment">// [ 2, 12, 45, 56, 123, 481 ]</span></code></pre><h4 id="选择算法效率"><a href="#选择算法效率" class="headerlink" title="选择算法效率"></a>选择算法效率</h4><p>同样和冒泡排序效率差不多</p><p>时间复杂度:O(N²)</p><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="插入排序思路"><a href="#插入排序思路" class="headerlink" title="插入排序思路"></a>插入排序思路</h3><p>插入排序是简单排序中效率最好的一种</p><p>插入排序也是学习其他高级排序的基础，比如快速排序，</p><p>插入排序思想的核心 <strong>局部有序（部分有序）</strong></p><p><strong>思路:</strong></p><ul><li>从 i 等于 1 开始变量，拿到当前数 current，与前面的数进行比较</li><li>用while进行循环，如果前面的数大于当前的数，那么就进行交换。</li><li>最好在外部套个循环，直到未排序的数没有了，那么排序就结束。</li></ul><p>参考动画：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ceb7dd06b55748b88d6c799d4954af58~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="insert.gif"></p><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayList</span> &#123;  array = [];  <span class="hljs-comment">// 用于插入数字</span>  <span class="hljs-title function_">insert</span>(<span class="hljs-params">item</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">array</span>.<span class="hljs-title function_">push</span>(item);  &#125;  <span class="hljs-comment">//  插入排序</span>  <span class="hljs-title function_">insertSort</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">array</span>.<span class="hljs-property">length</span>; i++) &#123;      <span class="hljs-keyword">let</span> j = i; <span class="hljs-comment">// 获取当前的下标值，存起来。</span>      <span class="hljs-keyword">let</span> current = <span class="hljs-variable language_">this</span>.<span class="hljs-property">array</span>[i];  <span class="hljs-comment">// 获取当前的数，存起来</span>    <span class="hljs-comment">// 由于不确定循环次数，所有用while</span>      <span class="hljs-keyword">while</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">array</span>[j - <span class="hljs-number">1</span>] &gt; current &amp;&amp; j &gt; <span class="hljs-number">0</span>) &#123;       <span class="hljs-comment">// 如果当前数的前一个比当前数大，就交换。</span>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">array</span>[j] = <span class="hljs-variable language_">this</span>.<span class="hljs-property">array</span>[j - <span class="hljs-number">1</span>];        j--;      &#125;      <span class="hljs-comment">// 将j位置的数，放到当前位置。</span>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">array</span>[j] = current;    &#125;  &#125;&#125;<span class="hljs-keyword">let</span> list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();list.<span class="hljs-title function_">insert</span>(<span class="hljs-number">12</span>);list.<span class="hljs-title function_">insert</span>(<span class="hljs-number">2</span>);list.<span class="hljs-title function_">insert</span>(<span class="hljs-number">45</span>);list.<span class="hljs-title function_">insert</span>(<span class="hljs-number">123</span>);list.<span class="hljs-title function_">insert</span>(<span class="hljs-number">481</span>);list.<span class="hljs-title function_">insert</span>(<span class="hljs-number">56</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(list.<span class="hljs-property">array</span>);  <span class="hljs-comment">// [ 12, 2, 45, 123, 481, 56 ]</span><span class="hljs-comment">// 调用 插入排序</span>list.<span class="hljs-title function_">insertSort</span>();<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(list.<span class="hljs-property">array</span>); <span class="hljs-comment">// [ 2, 12, 45, 56, 123, 481 ]</span></code></pre><h3 id="插入排序的效率"><a href="#插入排序的效率" class="headerlink" title="插入排序的效率"></a>插入排序的效率</h3><p><strong>插入排序的比较次数：</strong></p><ul><li>第一趟时，需要的最多次数是1，第二趟最多次数是2，以此类推，最后一趟是 N-1 次</li><li>因此插入排序比较的最多次数是：1+2+3+4+….+N-1 = N*(N-1) /2</li></ul><p><strong>插入排序的复制次数：</strong></p><ul><li>第一趟时，需要的最多复制次数是1，第二趟最多次数是2，依次类推，最后一趟是N-1次</li><li>因此复制最多次数是 ：1+2+3+4+….+N-1 = N*(N-1) /2</li><li>平均次数是  N*(N-1) /4</li></ul><p>所以时间复杂度为：O(N²)</p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="快速排序思路"><a href="#快速排序思路" class="headerlink" title="快速排序思路"></a>快速排序思路</h3><p>思路核心: <strong>分而治之</strong>,即分成若个部分，逐个解决</p><p><strong>思路:</strong></p><ul><li>在数组中，选择一个数作为”基准”（pivot）。</li><li>将数组分成<strong>左右</strong>俩部分，小于 <code>基准</code> 的放在<strong>左部分</strong>，大于 <code>基准</code> 的放在<strong>右部分</strong>。</li><li>对”基准”左部分和右部分，不断重复第一步和第二步，直到所有部分只剩下一个元素为止。</li></ul><p>动画参考:<br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3044a244fd864c48b0c5f841b617526b~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="quick.gif"></p><h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayList</span> &#123;  array = [];  <span class="hljs-comment">// 用于插入数字</span>  <span class="hljs-title function_">insert</span>(<span class="hljs-params">item</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">array</span>.<span class="hljs-title function_">push</span>(item);  &#125;  <span class="hljs-comment">// 快速排序</span>  <span class="hljs-title function_">quickSort</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">const</span> <span class="hljs-title function_">quick</span> = (<span class="hljs-params">array</span>) =&gt; &#123;      <span class="hljs-keyword">if</span> (array.<span class="hljs-property">length</span> &lt;= <span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">return</span> array;&#125;      <span class="hljs-keyword">let</span> pivotIndex = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(array.<span class="hljs-property">length</span> / <span class="hljs-number">2</span>);      <span class="hljs-keyword">let</span> pivot = array.<span class="hljs-title function_">splice</span>(pivotIndex, <span class="hljs-number">1</span>)[<span class="hljs-number">0</span>];      <span class="hljs-keyword">let</span> left = [];      <span class="hljs-keyword">let</span> right = [];      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; array.<span class="hljs-property">length</span>; i++) &#123;        <span class="hljs-keyword">if</span> (array[i] &gt; pivot) &#123;          right.<span class="hljs-title function_">push</span>(array[i]);        &#125; <span class="hljs-keyword">else</span> &#123;          left.<span class="hljs-title function_">push</span>(array[i]);        &#125;      &#125;      <span class="hljs-keyword">return</span> <span class="hljs-title function_">quick</span>(left).<span class="hljs-title function_">concat</span>([pivot], <span class="hljs-title function_">quick</span>(right));    &#125;;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">array</span> = <span class="hljs-title function_">quick</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">array</span>);  &#125;&#125;<span class="hljs-keyword">let</span> list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();list.<span class="hljs-title function_">insert</span>(<span class="hljs-number">12</span>);list.<span class="hljs-title function_">insert</span>(<span class="hljs-number">2</span>);list.<span class="hljs-title function_">insert</span>(<span class="hljs-number">45</span>);list.<span class="hljs-title function_">insert</span>(<span class="hljs-number">123</span>);list.<span class="hljs-title function_">insert</span>(<span class="hljs-number">481</span>);list.<span class="hljs-title function_">insert</span>(<span class="hljs-number">56</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(list.<span class="hljs-property">array</span>);<span class="hljs-comment">// 调用快速排序</span>list.<span class="hljs-title function_">quickSort</span>();<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(list.<span class="hljs-property">array</span>);</code></pre><h3 id="快速排序的效率"><a href="#快速排序的效率" class="headerlink" title="快速排序的效率"></a>快速排序的效率</h3><p>时间复杂度: O(nlogn)</p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="归并排序思路"><a href="#归并排序思路" class="headerlink" title="归并排序思路"></a>归并排序思路</h3><p>归并排序也是采用 <strong>分而治之</strong> 的思想</p><p>将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。</p><p><strong>思路:</strong><br><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/480f8a177c1c4c32867c39a6ed1c9dd1~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="merge.png"></p><p>动画参考:</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d283596ede884232aeb1ce05f828e732~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="merge.gif"></p><h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayList</span> &#123;  array = [];  <span class="hljs-comment">// 用于插入数字</span>  <span class="hljs-title function_">insert</span>(<span class="hljs-params">item</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">array</span>.<span class="hljs-title function_">push</span>(item);  &#125;  <span class="hljs-comment">// 归并排序</span>  <span class="hljs-title function_">mergeSort</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">const</span> <span class="hljs-title function_">mergerSorts</span> = (<span class="hljs-params">array</span>) =&gt; &#123;      <span class="hljs-keyword">if</span> (array.<span class="hljs-property">length</span> === <span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">return</span> array;&#125;      <span class="hljs-keyword">let</span> left = array.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(array.<span class="hljs-property">length</span> / <span class="hljs-number">2</span>));      <span class="hljs-keyword">let</span> right = array.<span class="hljs-title function_">slice</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(array.<span class="hljs-property">length</span> / <span class="hljs-number">2</span>));      <span class="hljs-keyword">const</span> <span class="hljs-title function_">merge</span> = (<span class="hljs-params">a, b</span>) =&gt; &#123;        <span class="hljs-keyword">if</span> (a.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> b;        <span class="hljs-keyword">if</span> (b.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> a;        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>] ? [a[<span class="hljs-number">0</span>]].<span class="hljs-title function_">concat</span>(<span class="hljs-title function_">merge</span>(a.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>), b)) : [b[<span class="hljs-number">0</span>]].<span class="hljs-title function_">concat</span>(<span class="hljs-title function_">merge</span>(a, b.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>)));      &#125;;      <span class="hljs-keyword">return</span> <span class="hljs-title function_">merge</span>(<span class="hljs-title function_">mergerSorts</span>(left), <span class="hljs-title function_">mergerSorts</span>(right));    &#125;;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">array</span> = <span class="hljs-title function_">mergerSorts</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">array</span>);  &#125;&#125;<span class="hljs-keyword">let</span> list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();list.<span class="hljs-title function_">insert</span>(<span class="hljs-number">12</span>);list.<span class="hljs-title function_">insert</span>(<span class="hljs-number">2</span>);list.<span class="hljs-title function_">insert</span>(<span class="hljs-number">45</span>);list.<span class="hljs-title function_">insert</span>(<span class="hljs-number">123</span>);list.<span class="hljs-title function_">insert</span>(<span class="hljs-number">481</span>);list.<span class="hljs-title function_">insert</span>(<span class="hljs-number">56</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(list.<span class="hljs-property">array</span>);<span class="hljs-comment">// 调用归并排序</span>list.<span class="hljs-title function_">mergeSort</span>();<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(list.<span class="hljs-property">array</span>);</code></pre><h3 id="快速排序的效率-1"><a href="#快速排序的效率-1" class="headerlink" title="快速排序的效率"></a>快速排序的效率</h3><p>时间复杂度: O(nlogn)</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>三次握手和四次挥手</title>
    <link href="/2021/02/20/55-TCP%E8%BF%9E%E6%8E%A5%E5%92%8C%E6%96%AD%E5%BC%80/"/>
    <url>/2021/02/20/55-TCP%E8%BF%9E%E6%8E%A5%E5%92%8C%E6%96%AD%E5%BC%80/</url>
    
    <content type="html"><![CDATA[<h2 id="关于TCP的-三次握手"><a href="#关于TCP的-三次握手" class="headerlink" title="关于TCP的 三次握手"></a>关于TCP的 三次握手</h2><h3 id="关于TCP协议"><a href="#关于TCP协议" class="headerlink" title="关于TCP协议"></a>关于TCP协议</h3><p>TCP（Transmission Control Protocol，传输控制协议） 是一种面向连接的，可靠的，基于字节流的传输层通信协议。</p><p>与之对应的是<strong>UDP</strong>（User Datagram Protocol，用户数据协议），是不可靠的传输层协议。</p><h3 id="关于TCP报文"><a href="#关于TCP报文" class="headerlink" title="关于TCP报文"></a>关于TCP报文</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c4304c090c942a3866ef8c51dcce008~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="tcp报文"></p><p>在了解什么三次握手之前，我们需要知道TCP报文的一些知识。</p><ul><li>源端口号</li><li>目的端口号</li><li><strong>ACK</strong> : TCP协议规定，只有ACK=1时有效，也规定连接建立后所有发送的报文的ACK必须为1。</li><li><strong>SYN</strong>(SYNchronization) : 在连接建立时用来同步序号。当SYN=1而ACK=0时，表明这是一个连接请求报文。对方若同意建立连接，则应在响应报文中使SYN=1和ACK=1. 因此,  SYN置1就表示这是一个连接请求或连接接受报文。</li></ul><h3 id="生活中的例子说明什么是三次握手"><a href="#生活中的例子说明什么是三次握手" class="headerlink" title="生活中的例子说明什么是三次握手"></a>生活中的例子说明什么是三次握手</h3><p>直接给出专业名词确实很难理解，那么就举个生活中的例子：</p><ul><li>小明说:  你好吗?</li><li>小红说：我很好，你呢？</li><li>小明说：我也是！</li></ul><p>这段话中，</p><p><strong>小明和小红</strong>  就分别是 <strong>源端口号</strong> 和 <strong>目的端口号</strong> ，</p><p><strong>你好吗？</strong> 是询问对方的， 所以是 <strong>SYN</strong> ， 而 seq 就可以理解为询问的内容。</p><p><strong>我很好，你呢？</strong>  中 <strong>我很好</strong> 是回应对方的，所以是 <strong>ACK</strong>，而 ack 就可以理解为 回应的内容 ， <strong>你呢?</strong>  是询问对方的， 所以是 <strong>SYN</strong></p><p><strong>我也是！</strong>  同样 回应对方的， 所以是 <strong>ACK</strong></p><p>而这整个流程就是 <strong>三次握手</strong> ！</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f058e1d83c38411692f9af71108fa792~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="三次握手"></p><h3 id="三次握手流程"><a href="#三次握手流程" class="headerlink" title="三次握手流程"></a>三次握手流程</h3><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35c2f6e2af714eb5834a98d4108b54a9~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="三次握手流程"><br>这个过程中，分别是：</p><ol><li>客户端发送 SYN = 1 的 询问报文给服务器端， seq 是 x， 进入 SYN_SENT 状态</li><li>服务器回应一个 ACK =1 , SYN =1 的应答 + 询问报文。 应答号ack是 x+1 , 询问号seq是 y， 进入 SYN_RCVD 状态</li><li>客户端收到后，回应一个 ACK = 1的应答报文， 应答号是 y+1 , 进入 ESTAB-LISHED 状态</li></ol><h3 id="为什么不是俩次握手-或者是-四次握手呢？"><a href="#为什么不是俩次握手-或者是-四次握手呢？" class="headerlink" title="为什么不是俩次握手 或者是 四次握手呢？"></a>为什么不是俩次握手 或者是 四次握手呢？</h3><p>假设如果是  俩次握手的话， 那么客户端发送请求报文A， 因为网络延迟的原因，服务器没收到， 然后客户端发送第二遍报文A ,  服务器终于收到了然后建立连接等待客户端发送数据， 然后客户端正常发送数据。 但是过了一会 第一次发送的报文A也到达了服务器，那么服务器就会再次建立连接等待客户端发送数据，而客户端并不知情，这样就导致 服务器资源的浪费了。</p><p>TCP作为一种可靠的传输控制协议，其<strong>核心思想</strong>就是：既要保证数据的可靠传输，又要提高传输的效率，而用三次恰恰可以满足以上俩方面的需求。</p><p>所以三次握手能解决的问题，为什么需要画蛇添足呢？</p><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>当客户端和服务器端建立TCP连接（三次握手）后，客户端请求HTTP，服务器端响应给他，等到客户端收到响应后。客户端和服务器端会断开 TCP连接。 而断开TCP连接需要经过四次挥手这个流程。</p><p>如下图：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff1fdeb63df44b408aa3ca1ea83e7236~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="四次挥手"></p><ol><li>客户端发送一个 FIN ， 告诉服务器关闭连接</li><li>服务器端发送一个 ACK ，告诉客户端 已经收到。</li><li>然后服务器端通知 其他应用程序关闭连接，等程序关闭后，服务器会发送一个 FIN ，告诉 客户端 我已断开连接</li><li>客户端再发送 一个ACK 告诉服务器端 收到！ </li></ol>]]></content>
    
    
    <categories>
      
      <category>HTTP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>运算符 typeof 与 instanceof 区别</title>
    <link href="/2021/02/17/54-typeof%E5%92%8Cinstanceof/"/>
    <url>/2021/02/17/54-typeof%E5%92%8Cinstanceof/</url>
    
    <content type="html"><![CDATA[<h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><p>type 中文翻译：“类型”</p><p>用于判断数据类型，返回值是6个不同的字符串：分别是：<strong>string</strong>  <strong>number</strong>   <strong>boolean</strong>  <strong>undefined</strong>  <strong>function</strong>  <strong>object</strong></p><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-string">&quot;1&quot;</span>);   <span class="hljs-comment">// string</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-number">1</span>);  <span class="hljs-comment">// number</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-literal">false</span>);  <span class="hljs-comment">// boolean</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-literal">undefined</span>);  <span class="hljs-comment">// undefined</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;&#125;);   <span class="hljs-comment">// function</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> &#123;&#125;);   <span class="hljs-comment">// object</span></code></pre><p>除了以上之外，你会发现 typeof 判断 <strong>null</strong>  <strong>Array</strong>   <strong>构造函数的实例</strong>时， 会发现 永远得到是 <strong>object</strong></p><p>因此可知道 typeof 运算符  适用于检测除null的基础数据类型和函数类型</p><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p>instance 中文翻译：“实例”  因此可以通过他的翻译知道这个含义了，就是 判断该对象是属于谁的实例。由于是实例，所以不得不牵扯到了对象的继承，即原型的知识了。而 <strong>instanceof</strong>  就是根据原型链进行搜寻的。</p><p>所以 instanceof 是检测对象之间的关联性</p><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Number</span>() <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Number</span>);  <span class="hljs-comment">// true</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>() <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">String</span>);  <span class="hljs-comment">// true</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>] <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span>);  <span class="hljs-comment">// true</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;foo&quot;</span> &#125; <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>);  <span class="hljs-comment">// true</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">String</span>);  <span class="hljs-comment">// false</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Number</span>); <span class="hljs-comment">// false</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-literal">false</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Boolean</span>);   <span class="hljs-comment">// false</span></code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table><thead><tr><th></th><th>typeof</th><th>instanceof</th></tr></thead><tbody><tr><td>作用</td><td>检测数据类型</td><td>检测对象之间的关联性</td></tr><tr><td>返回值</td><td>小写的字母 字符串</td><td>布尔值</td></tr><tr><td>操作符</td><td>简单数据类型（没有null）、函数或者对象</td><td>左边必须是引用类型，右边必须是函数</td></tr><tr><td>操作数数量</td><td>1个</td><td>2个</td></tr></tbody></table><p><strong>typeof</strong>   中的 type 是类型的意思，所以他是用来检测数据类型的， 可以检测除了null以外的数据类型加上function，返回字符串</p><p><strong>instanceof</strong> 中的 instance是实例的意思， 所以他是用来检测这个实例是谁 <strong>new</strong> 出来的。返回布尔值</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组去重</title>
    <link href="/2021/02/15/53-%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/"/>
    <url>/2021/02/15/53-%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/</url>
    
    <content type="html"><![CDATA[<h2 id="借鉴计数排序的原理-使用hash"><a href="#借鉴计数排序的原理-使用hash" class="headerlink" title="借鉴计数排序的原理,使用hash"></a>借鉴计数排序的原理,使用hash</h2><pre><code class="hljs js">unique = <span class="hljs-function">(<span class="hljs-params">array</span>) =&gt;</span> &#123;    <span class="hljs-keyword">const</span> hash = []    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;array.<span class="hljs-property">length</span>; i++)&#123;        hash[array[i]] = <span class="hljs-literal">true</span>    &#125;    <span class="hljs-keyword">const</span> result = []    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> k <span class="hljs-keyword">in</span> hash)&#123;        result.<span class="hljs-title function_">push</span>(k)    &#125;    <span class="hljs-keyword">return</span> result&#125;</code></pre><p><strong>缺点</strong>：只支持数字或者字符串数组，如果数组里面有对象，比如 array = [{number:1}, 2]，就会出错。</p><h2 id="使用-Set"><a href="#使用-Set" class="headerlink" title="使用 Set"></a>使用 Set</h2><pre><code class="hljs js">unique = <span class="hljs-function">(<span class="hljs-params">array</span>) =&gt;</span> &#123;    <span class="hljs-keyword">return</span> [...<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(array)]     <span class="hljs-comment">// 或者 return Array.from(new Set(array))</span>&#125;</code></pre><p><strong>缺点</strong>：不支持对象去重</p><h2 id="Map数据结构实现"><a href="#Map数据结构实现" class="headerlink" title="Map数据结构实现"></a>Map数据结构实现</h2><pre><code class="hljs js">unique = <span class="hljs-function">(<span class="hljs-params">array</span>) =&gt;</span> &#123;  <span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();  <span class="hljs-keyword">let</span> result = []  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; array.<span class="hljs-property">length</span>; i++) &#123;    <span class="hljs-keyword">if</span>(map.<span class="hljs-title function_">has</span>(array[i])) &#123; <span class="hljs-comment">// 判断 map 中是否已有该 key</span>      <span class="hljs-keyword">continue</span>    &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 如果 map 中没有该 key，就加入 result 中</span>      map.<span class="hljs-title function_">set</span>(array[i], <span class="hljs-literal">true</span>);      result.<span class="hljs-title function_">push</span>(array[i]);    &#125;  &#125;  <span class="hljs-keyword">return</span> result;&#125;<span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-string">&quot;1&quot;</span>,&#123;<span class="hljs-attr">a</span>:<span class="hljs-number">1</span>,<span class="hljs-attr">b</span>:<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-attr">b</span>:<span class="hljs-number">2</span>,<span class="hljs-attr">c</span>:<span class="hljs-number">3</span>&#125;]</code></pre>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>call、apply、bind 的用法分别是什么？</title>
    <link href="/2021/02/12/52.%E7%BB%91%E5%AE%9Athis%E6%8C%87%E5%90%91/"/>
    <url>/2021/02/12/52.%E7%BB%91%E5%AE%9Athis%E6%8C%87%E5%90%91/</url>
    
    <content type="html"><![CDATA[<h2 id="它们最主要的作用是-改变this的指向"><a href="#它们最主要的作用是-改变this的指向" class="headerlink" title="它们最主要的作用是 改变this的指向"></a>它们最主要的作用是 改变this的指向</h2><h3 id="call"><a href="#call" class="headerlink" title="call()"></a>call()</h3><p>call() 写法 ： <code>function.call(thisArg, arg1, arg2, ...)</code></p><p>call()调用一个函数，第一个参数是指定的this值，其他参数分别是提供的参数，用逗号隔开。</p><p><strong>call()用法</strong></p><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">a,b,c</span>)&#123;&#125;<span class="hljs-comment">//  fn 的this指向的是obj， 参数是 1，2，3</span>fn.<span class="hljs-title function_">call</span>(obj,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<span class="hljs-comment">// 这个fn 的this指向obj， 但它参数是 [1,2,3]  、 undefined 、 undefined</span>fn.<span class="hljs-title function_">call</span>(obj,[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>])</code></pre><h2 id="apply"><a href="#apply" class="headerlink" title="apply()"></a>apply()</h2><p>apply()写法： <code>func.apply(thisArg, [argsArray])</code></p><p>apply 只接收俩个参数， 第一个参数和call一样。 第二个参数，必须是数组或者类数组。</p><p><strong>apply() 和call() 使用上是一致的，唯一区别在于 call() 方法接受若干个参数，而apply()方法接受一个包含多个参数的数组</strong></p><h2 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h2><p>bind() 不同于 call() 和 apply() ， 它返回一个新的函数，该函数将this设置未我们赋给它的值。</p><pre><code class="hljs js"><span class="hljs-comment">// mdn demo</span><span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> = <span class="hljs-number">9</span>; <span class="hljs-comment">// 在浏览器中this指向全局的 window 对象</span><span class="hljs-keyword">var</span> <span class="hljs-variable language_">module</span> = &#123;  <span class="hljs-attr">x</span>: <span class="hljs-number">81</span>,  <span class="hljs-attr">getX</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span>; &#125;&#125;;<span class="hljs-variable language_">module</span>.<span class="hljs-title function_">getX</span>(); <span class="hljs-comment">// 81</span><span class="hljs-keyword">var</span> retrieveX = <span class="hljs-variable language_">module</span>.<span class="hljs-property">getX</span>;<span class="hljs-title function_">retrieveX</span>();<span class="hljs-comment">// 返回9 - 因为函数是在全局作用域中调用的</span><span class="hljs-comment">// 创建一个新函数，把this绑定都module对象上</span><span class="hljs-keyword">var</span> bondGetX = retrieveX.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">module</span>);<span class="hljs-title function_">bondGetX</span>(); <span class="hljs-comment">// 81</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什么是闭包？闭包的用途是什么？闭包的缺点是什么？</title>
    <link href="/2021/02/12/51-%E9%97%AD%E5%8C%85/"/>
    <url>/2021/02/12/51-%E9%97%AD%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<p><strong>闭包：</strong> 函数 和 函数内部可以访问到的变量 总和就是一个闭包</p><pre><code class="hljs js"><span class="hljs-comment">// 变量foo  + fn函数 就是闭包</span><span class="hljs-keyword">let</span> foo = <span class="hljs-string">&#x27;111&#x27;</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo)&#125;<span class="hljs-title function_">fn</span>()  <span class="hljs-comment">// 111</span></code></pre><h3 id="闭包的用途："><a href="#闭包的用途：" class="headerlink" title="闭包的用途："></a>闭包的用途：</h3><ul><li>间接访问一个变量 ,让这个变量始终保持再内存中</li></ul><p><strong>即 隐藏局部变量，暴露操作函数</strong></p><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">createAdd</span> = (<span class="hljs-params"></span>)=&gt;&#123;    <span class="hljs-keyword">let</span> n = <span class="hljs-number">0</span>    <span class="hljs-keyword">return</span> <span class="hljs-function">()=&gt;</span>&#123;        n += <span class="hljs-number">1</span>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(n)    &#125;&#125;<span class="hljs-keyword">const</span> add = <span class="hljs-title function_">createAdd</span>()<span class="hljs-title function_">add</span>() <span class="hljs-comment">// 1</span><span class="hljs-title function_">add</span>() <span class="hljs-comment">// 2</span></code></pre><h3 id="闭包的缺点："><a href="#闭包的缺点：" class="headerlink" title="闭包的缺点："></a>闭包的缺点：</h3><ul><li>由于闭包会使变量始终保存在内存中，所以内存消耗会很大。</li><li>闭包会在父函数外部，改变父函数内部变量的值</li></ul><h3 id="立即执行函数"><a href="#立即执行函数" class="headerlink" title="立即执行函数"></a>立即执行函数</h3><ul><li>声明一个匿名函数</li><li>马上调用这个匿名函数</li></ul><p><strong>立即执行函数的作用：</strong> 创建一个独立的作用域。这个作用域的变量，外面访问不到(即避免变量污染) </p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React Hooks 学习总结</title>
    <link href="/2021/02/02/50-React%20Hooks/"/>
    <url>/2021/02/02/50-React%20Hooks/</url>
    
    <content type="html"><![CDATA[<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3b4f5a08e744902bf7dada96f605578~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="React Hooks"></p><h2 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h2><p><strong>基本使用:</strong></p><pre><code class="hljs jsx"><span class="hljs-comment">// 这里可以任意命名，因为返回的是数组，数组解构</span><span class="hljs-keyword">const</span> [state, setState] = <span class="hljs-title function_">useState</span>(initialState);<span class="hljs-keyword">const</span> [n,setN] = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>)<span class="hljs-keyword">const</span> [user,setUser] = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useState</span>(&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;张三&quot;</span>&#125;)</code></pre><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><h4 id="1-不可局部更新"><a href="#1-不可局部更新" class="headerlink" title="1. 不可局部更新"></a><strong>1. 不可局部更新</strong></h4><p>如果state是一个对象，是不可以合并属性的。</p><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">const</span> [user, setUser] = <span class="hljs-title function_">useState</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Wangpf&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">18</span> &#125;)  <span class="hljs-keyword">const</span> <span class="hljs-title function_">changeState</span> = (<span class="hljs-params"></span>) =&gt; &#123;    <span class="hljs-title function_">setUser</span>(&#123;      <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Mark&quot;</span>    &#125;)  &#125;  <span class="hljs-keyword">return</span> (    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>名字：&#123;user.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>年龄：&#123;user.age&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;changeState&#125;</span>&gt;</span>改变<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>  )&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span></code></pre><p>看代码所示，当我点击按钮时，它会把名字改为 Mark ，<strong>但是 age 会显示不见</strong>， 这就是因为它不会局部更新，不会帮我们合并属性，因此需要我们自己加上。</p><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> <span class="hljs-title function_">changeState</span> = (<span class="hljs-params"></span>) =&gt; &#123;    <span class="hljs-title function_">setUser</span>(&#123;      ...user,      <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Mark&quot;</span>    &#125;)  &#125;</code></pre><h4 id="2-地址会变"><a href="#2-地址会变" class="headerlink" title="2. 地址会变"></a><strong>2. 地址会变</strong></h4><p>setState(obj)，如果<strong>obj</strong>地址不变，那么React就认为数据没有变化。</p><p>意思就是，我们不能在原来的数据上进行操作，而是重新写一个新的对象来覆盖之前的。</p><h4 id="useState-和-setState-都可以接收函数"><a href="#useState-和-setState-都可以接收函数" class="headerlink" title="useState 和 setState 都可以接收函数"></a>useState 和 setState 都可以接收函数</h4><pre><code class="hljs jsx"><span class="hljs-comment">// useState</span> <span class="hljs-keyword">const</span> [user, setUser] = <span class="hljs-title function_">useState</span>(<span class="hljs-function">() =&gt;</span> &#123;   <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Wangpf&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">18</span> &#125;  &#125;)<span class="hljs-comment">// setState</span>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">changeState</span> = (<span class="hljs-params"></span>) =&gt; &#123;    <span class="hljs-title function_">setUser</span>(<span class="hljs-function">(<span class="hljs-params">user</span>) =&gt;</span> &#123;      <span class="hljs-keyword">return</span> &#123;        ...user,        <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Mark&quot;</span>      &#125;    &#125;)  &#125;</code></pre><h2 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h2><ol><li>Effect Hook 可以让你在函数组件中执行副作用操作(用于模拟类组件中的生命周期钩子)</li><li>React中的副作用操作:<pre><code> 发ajax请求数据获取 设置订阅 / 启动定时器 手动更改真实DOM</code></pre></li><li>语法和说明:<ul><li><pre><code class="jsx">     useEffect(() =&gt; &#123;   // 在此可以执行任何带副作用操作    return () =&gt; &#123; // 在组件卸载前执行      // 在此做一些收尾工作, 比如清除定时器/取消订阅等    &#125;  &#125;, [stateValue]) // 如果指定的是[], 回调函数只会在第一次render()后执行<pre><code class="hljs moonscript"><span class="hljs-number">4.</span> 可以把 useEffect Hook 看做如下三个函数的组合- componentDidMount()- componentDidUpdate()- componentWillUnmount()```jsx  useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;    console.log(<span class="hljs-string">&#x27;第一次渲染之后及之后每次都会执行&#x27;</span>);  &#125;)  useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;   // componentDidMount    console.log(<span class="hljs-string">&quot;只执行第一次渲染之后&quot;</span>);  &#125;, [])  useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;   // componentDidUpdate()    <span class="hljs-keyword">if</span> (count !== <span class="hljs-number">0</span>) &#123;      console.log(<span class="hljs-string">&#x27;count变化了&#x27;</span>);    &#125;  &#125;, [count])  useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;  <span class="hljs-keyword">return</span> () =&gt; &#123; componentWillUnmount()  &#125;  &#125;, [])</code></pre></code></pre></li></ul></li></ol><h2 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h2><p><strong>“上下文”</strong></p><ul><li>全局变量 是全局的“上下文”</li><li>“上下文”是局部的全局变量</li></ul><p><strong>使用步骤：</strong></p><ol><li>const XxxContext = React.createContext()</li><li>渲染子组时，外面包裹xxxContext.Provider, 通过value属性给后代组件传递数据：<ul><li> &lt;xxxContext.Provider value={数据}&gt;<br>  子组件<br>  &lt;/xxxContext.Provider&gt;</li></ul></li><li>后代组件读取数据<ul><li> const {数据} = useContext(xxxContext)</li></ul></li></ol><p>适合用于祖孙组件的通信</p><p><strong>使用代码如下：</strong></p><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; createContext, useContext, useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><span class="hljs-keyword">const</span> <span class="hljs-title class_">Context</span> = <span class="hljs-title function_">createContext</span>(<span class="hljs-literal">null</span>)<span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>)  <span class="hljs-keyword">return</span> (    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Context.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">count</span>, <span class="hljs-attr">setCount</span> &#125;&#125;&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">A</span> /&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">Context.Provider</span>&gt;</span></span>  )&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">A</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">return</span> (    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>我是A组件<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">B</span> /&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>  )&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">B</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">const</span> &#123; count, setCount &#125; = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">Context</span>)  <span class="hljs-keyword">const</span> <span class="hljs-title function_">increment</span> = (<span class="hljs-params"></span>) =&gt; &#123;    <span class="hljs-title function_">setCount</span>(<span class="hljs-function"><span class="hljs-params">n</span> =&gt;</span> n + <span class="hljs-number">1</span>)  &#125;  <span class="hljs-keyword">return</span> (    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>我是B组件<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>count:&#123;count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;increment&#125;</span>&gt;</span>+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>  )&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span></code></pre><h2 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h2><blockquote><p>此hooks API 践行了Redux的思想</p></blockquote><p><strong>逻辑步骤：</strong></p><ol><li><p> 创建初始值 <code>initialState</code></p></li><li><p> 创建所有操作 <code>reducer = (state, action)=&gt;&#123;&#125;</code></p></li><li><p> 传给 <code>useReducer</code>，得到读写的API</p></li><li><p> 调用并写 <code>&#123;&#123;type:'操作类型'&#125;&#125;</code></p></li></ol><p><strong>详细代码如下：</strong></p><pre><code class="hljs jsx"><span class="hljs-comment">// 初始化状态</span><span class="hljs-keyword">const</span> initialState = &#123; <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> &#125;<span class="hljs-keyword">const</span> <span class="hljs-title function_">reducer</span> = (<span class="hljs-params">state, action</span>) =&gt; &#123;  <span class="hljs-keyword">const</span> &#123; type, data &#125; = action  <span class="hljs-keyword">if</span> (type === <span class="hljs-string">&#x27;increment&#x27;</span>) &#123;    <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">count</span>: state.<span class="hljs-property">count</span> + data &#125;  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type === <span class="hljs-string">&#x27;decrement&#x27;</span>) &#123;    <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">count</span>: state.<span class="hljs-property">count</span> - data &#125;  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;unknown type&#x27;</span>)  &#125;&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">A</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">const</span> [state, dispatch] = <span class="hljs-title function_">useReducer</span>(reducer, initialState)  <span class="hljs-keyword">const</span> &#123; count &#125; = state  <span class="hljs-keyword">const</span> <span class="hljs-title function_">increment</span> = (<span class="hljs-params"></span>) =&gt; &#123;    <span class="hljs-title function_">dispatch</span>(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;increment&quot;</span>, <span class="hljs-attr">data</span>: <span class="hljs-number">1</span> &#125;)  &#125;  <span class="hljs-keyword">const</span> <span class="hljs-title function_">decrement</span> = (<span class="hljs-params"></span>) =&gt; &#123;    <span class="hljs-title function_">dispatch</span>(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;decrement&quot;</span>, <span class="hljs-attr">data</span>: <span class="hljs-number">2</span> &#125;)  &#125;  <span class="hljs-keyword">return</span> (    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>我是A组件<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>count:&#123;count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;increment&#125;</span>&gt;</span>加<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;decrement&#125;</span>&gt;</span>减<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>  )&#125;</code></pre><h2 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h2><p>通过一个实例，来理解下 useMemo的用法。</p><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">const</span> [n, setN] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>)  <span class="hljs-keyword">const</span> [m, setM] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>)  <span class="hljs-keyword">const</span> <span class="hljs-title function_">updateN</span> = (<span class="hljs-params"></span>) =&gt; &#123;    <span class="hljs-title function_">setN</span>(<span class="hljs-function"><span class="hljs-params">n</span> =&gt;</span> n + <span class="hljs-number">1</span>)  &#125;  <span class="hljs-keyword">const</span> <span class="hljs-title function_">updateM</span> = (<span class="hljs-params"></span>) =&gt; &#123;    <span class="hljs-title function_">setM</span>(<span class="hljs-function"><span class="hljs-params">m</span> =&gt;</span> m + <span class="hljs-number">1</span>)  &#125;  <span class="hljs-keyword">return</span> (    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;updateN&#125;</span>&gt;</span>update n &#123;n&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;updateM&#125;</span>&gt;</span>update m &#123;m&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">A</span> <span class="hljs-attr">data</span>=<span class="hljs-string">&#123;m&#125;</span> /&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>  )&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">A</span>(<span class="hljs-params">props</span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;A组件执行了&#x27;</span>);  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>A组件：&#123;props.data&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span></code></pre><p>注意打印console.log的位置。</p><p>当我们点击APP组件的更新N的按钮时候，A组件会发生改变，但是M是没有改变的啊。</p><p>结论：不管我们是否改变了A组件的数据，我们会发现A组件会被重新渲染的。这就意味着性能的损耗。</p><p>因此，为了优化这个，React.memo 就派上用场了。<br>只需把A组件改为：</p><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> A = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">memo</span>(<span class="hljs-function">(<span class="hljs-params">props</span>) =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;A组件执行了&#x27;</span>);  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>A组件：&#123;props.data&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>&#125;)</code></pre><p>这样，只有APP组件的M数据不发生改变，那么A组件就不会重新渲染。</p><p>但是！！这样有个BUG，</p><p>当我给A组件绑定一个事件时，</p><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState, memo &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">const</span> [n, setN] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>)  <span class="hljs-keyword">const</span> [m, setM] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>)  <span class="hljs-keyword">const</span> <span class="hljs-title function_">updateN</span> = (<span class="hljs-params"></span>) =&gt; &#123;    <span class="hljs-title function_">setN</span>(<span class="hljs-function"><span class="hljs-params">n</span> =&gt;</span> n + <span class="hljs-number">1</span>)  &#125;  <span class="hljs-keyword">const</span> <span class="hljs-title function_">updateM</span> = (<span class="hljs-params"></span>) =&gt; &#123;    <span class="hljs-title function_">setM</span>(<span class="hljs-function"><span class="hljs-params">m</span> =&gt;</span> m + <span class="hljs-number">1</span>)  &#125;  <span class="hljs-keyword">const</span> <span class="hljs-title function_">changeA</span> = (<span class="hljs-params"></span>) =&gt; &#123;  &#125;  <span class="hljs-keyword">return</span> (    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;updateN&#125;</span>&gt;</span>update n &#123;n&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;updateM&#125;</span>&gt;</span>update m &#123;m&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">A</span> <span class="hljs-attr">data</span>=<span class="hljs-string">&#123;m&#125;</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;changeA&#125;</span> /&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>  )&#125;<span class="hljs-keyword">const</span> A = <span class="hljs-title function_">memo</span>(<span class="hljs-function">(<span class="hljs-params">props</span>) =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;A组件执行了&#x27;</span>);  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;props.changeA&#125;</span>&gt;</span>A组件：&#123;props.data&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>&#125;)<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span></code></pre><p>这样，即时我不该关于A组件的任何数据，A组件也会随着发生渲染，</p><p>问题的原因是因为：当我们重新渲染APP组件时，它会自动调用该changeA事件，那么它就会改变A组件的渲染。</p><p>解决该问题的方法就是： 使用 useMemo</p><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> changeA = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> &#123;&#125;,[])</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p><strong>特点</strong></p><ul><li><p>第一个参数是 () =&gt; value</p></li><li><p>第二参数是 依赖 [xx]</p></li><li><p>只有当依赖变化时，会计算出新的value</p></li><li><p>如果依赖不变，那么就重用之前的value</p></li></ul><p>是不是 Vue 中的 computed？</p><p><strong>注意项：</strong></p><ul><li><p>如果 ()=&gt; value 中的value 是个函数的话，那么你要写成：useMemo(()=&gt;{(x)=&gt;{xxxxxx}})</p></li><li><p>那么这就是一个返回函数的函数啊。</p></li></ul><p><strong>因此， useCallback 出来了</strong></p><h3 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h3><p>下面俩个是等价的。</p><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> changeA = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> &#123;   <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">m</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(m) &#125;, [])<span class="hljs-keyword">const</span> changeA = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function"><span class="hljs-params">m</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(m), [])</code></pre><h2 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h2><p>useRef返回的是一个可变的ref对象，其 xx.current 属性也就是 useRef(inital)中的inital初始化值。</p><p>所以注意  const xxxRef = useRef(0) 中， 此处的 0  实际是个对象为：{current:0}</p><p>为什么是对象的原因请看用处二</p><p><strong>用处一： 获取 元素，可以做一些操作元素之类</strong></p><p>通过如下简单实例可以明白</p><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useRef &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">const</span> inputRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>)  <span class="hljs-keyword">const</span> <span class="hljs-title function_">onclick</span> = (<span class="hljs-params"></span>) =&gt; &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(inputRef.<span class="hljs-property">current</span>);  <span class="hljs-comment">// 获得到input元素</span>  &#125;  <span class="hljs-keyword">return</span> (    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;inputRef&#125;</span> /&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onclick&#125;</span>&gt;</span>获取input<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>  )&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span></code></pre><p><strong>用处二：保持可变变量</strong></p><p>目的： 如果需要一个值，在组件不断render时保持不变</p><p>返回的ref对象在组件的整个生命周期内保持不变</p><p>举个常见的场景: 对定时器的清除操作。</p><p>我们需要确保 setInterval 的执行结果timer的引用，才能准确的清除对应的定时器。</p><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useEffect, useRef &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">const</span> timerRef = <span class="hljs-title function_">useRef</span>()  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;    timerRef.<span class="hljs-property">current</span> = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;timerRef&#x27;</span>);    &#125;, <span class="hljs-number">1000</span>);    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;      timerRef.<span class="hljs-property">current</span> &amp;&amp; <span class="hljs-built_in">clearInterval</span>(timerRef.<span class="hljs-property">current</span>)    &#125;  &#125;, [])  <span class="hljs-keyword">return</span> (    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">      App....</span><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>  )&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span></code></pre><h3 id="forwardRef"><a href="#forwardRef" class="headerlink" title="forwardRef"></a>forwardRef</h3><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useRef, forwardRef, useEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">const</span> btnRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>)  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(btnRef.<span class="hljs-property">current</span>);  &#125;, [])  <span class="hljs-keyword">return</span> (    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;btnRef&#125;</span> /&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>  )&#125;<span class="hljs-keyword">const</span> <span class="hljs-title class_">Button</span> = <span class="hljs-title function_">forwardRef</span>(<span class="hljs-function">(<span class="hljs-params">props, ref</span>) =&gt;</span> &#123;  <span class="hljs-keyword">return</span> (    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;ref&#125;</span> &#123;<span class="hljs-attr">...props</span>&#125;&gt;</span>按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>  )&#125;)<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span></code></pre><p>React 会将  <code>&lt;Button ref=&#123;ref&#125; /&gt;</code>元素的 ref 作为第二个参数传递给 React.forwardRef 函数中的渲染函数。</p><p>该渲染函数会将 ref 传递给 <code>&lt;button ref=&#123;ref&#125; /&gt; </code> 元素。</p><p>因此，当 React 附加了 ref 属性之后，inputRef.current 将直接指向 <code>button </code>DOM 元素实例。</p><h3 id="useImperativeHandle"><a href="#useImperativeHandle" class="headerlink" title="useImperativeHandle"></a>useImperativeHandle</h3><p>如果想要给给该组件的属性改个名字，或者返回其他额外的属性或者方法，我们可以使用useImperativeHandle。</p><p>这个API具体我没去深入了解。</p><h2 id="自定义-Hook"><a href="#自定义-Hook" class="headerlink" title="自定义 Hook"></a>自定义 Hook</h2><p>做一个hooks来实现渲染列表以及删除列表</p><p><strong>组件：</strong></p><pre><code class="hljs jsx"><span class="hljs-comment">// App组件</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><span class="hljs-keyword">import</span> useList <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./hooks/useList&#x27;</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">const</span> &#123; list, deleteIndex &#125; = <span class="hljs-title function_">useList</span>()  <span class="hljs-keyword">return</span> (    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>小说列表<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="language-xml">      &#123;</span><span class="language-xml">        list ?</span><span class="language-xml">          (<span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><span class="language-xml">            &#123;list.map((item, index) =&gt; (</span><span class="language-xml">              <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;item.id&#125;</span>&gt;</span>&#123;item.name&#125;</span><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123; deleteIndex(index) &#125;&#125;&gt;删除<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml">              <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><span class="language-xml">            )</span><span class="language-xml">            )&#125;</span><span class="language-xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>) :</span><span class="language-xml">          (<span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>加载中....<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>)</span><span class="language-xml">      &#125;</span><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>  )&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span></code></pre><p><strong>自定义hook：</strong></p><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123; useState, useEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><span class="hljs-keyword">import</span> &#123;nanoid &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;nanoid&#x27;</span><span class="hljs-keyword">const</span> <span class="hljs-title function_">useList</span> = (<span class="hljs-params"></span>) =&gt; &#123;  <span class="hljs-keyword">const</span> [list, setList] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">null</span>)  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-title function_">ajax</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">list</span> =&gt;</span> &#123;      <span class="hljs-title function_">setList</span>(list)    &#125;)  &#125;, [])  <span class="hljs-keyword">return</span> &#123;    <span class="hljs-attr">list</span>: list,    <span class="hljs-attr">setList</span>: setList,    <span class="hljs-attr">deleteIndex</span>: <span class="hljs-function"><span class="hljs-params">index</span> =&gt;</span> &#123;      <span class="hljs-title function_">setList</span>(list.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>,index).<span class="hljs-title function_">concat</span>(list.<span class="hljs-title function_">slice</span>(index+<span class="hljs-number">1</span>)))    &#125;  &#125;&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> useList<span class="hljs-keyword">function</span> <span class="hljs-title function_">ajax</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;      <span class="hljs-title function_">resolve</span>([        &#123;<span class="hljs-attr">id</span>: <span class="hljs-title function_">nanoid</span>(),<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;小王子&quot;</span>&#125;,        &#123;<span class="hljs-attr">id</span>: <span class="hljs-title function_">nanoid</span>(),<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;明朝那些事儿&quot;</span>&#125;,        &#123;<span class="hljs-attr">id</span>: <span class="hljs-title function_">nanoid</span>(),<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;三体&quot;</span>&#125;,      ])    &#125;,<span class="hljs-number">2000</span>)  &#125;)&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redux 学习总结</title>
    <link href="/2021/01/31/49-Redux%20%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <url>/2021/01/31/49-Redux%20%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="redux-是什么"><a href="#redux-是什么" class="headerlink" title="redux 是什么"></a>redux 是什么</h2><ol><li>rduex是一个专门用于做状态管理的JS库（注意:不是React插件库）</li><li>它可以在任何框架里使用，也可以在原生JS中使用，但基本与react搭配使用</li><li>作用:集中式管理 多个组件共享的状态</li></ol><h2 id="redux原理"><a href="#redux原理" class="headerlink" title="redux原理"></a>redux原理</h2><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/894ca0cbc1f349af965aaa07bb97386b~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="redux原理图"></p><p>看图很抽象，需要用一个生活中的例子来形象表达出来，估计会理解的更深。</p><p>比如： 我饿了，去餐馆吃饭，我给服务员说我要一份蛋炒饭，然后服务员把菜单传给餐馆老板，老板通知厨师要求做一份蛋炒饭，厨师做完蛋炒饭后再交给老板，然后我自己去取餐。</p><p>现在，我就是：React Components ， 服务员就是 Action Creators ， 餐馆老板就是: Store, 后厨就是：Reducers 。</p><p>瞧，redux就是这样一个工作流程，是不是感觉很生活？</p><p>即：action 定义状态，dispatch派发状态，store执行，reducers执行，reducers返回一个新的状态，然后getstate更新视图</p><h2 id="redux-三个核心概念"><a href="#redux-三个核心概念" class="headerlink" title="redux 三个核心概念"></a>redux 三个核心概念</h2><h3 id="1-action"><a href="#1-action" class="headerlink" title="1. action"></a>1. action</h3><ol><li>动作的对象</li><li>包含 俩个属性<ul><li>type: 标识属性，值为字符串，唯一，必要属性</li><li>data: 数据属性，值类型任意，可选属性</li></ul></li><li>例子： {type:”ADD_USER”,data:{name:”Wangpf”,age:”18”}}</li></ol><h3 id="2-reducer"><a href="#2-reducer" class="headerlink" title="2. reducer"></a>2. reducer</h3><ol><li>用于初始化状态，加工状态。</li><li>加工时，根据 旧的 state 和 action ，产生新的 state 的<strong>纯函数</strong></li></ol><h3 id="3-store"><a href="#3-store" class="headerlink" title="3. store"></a>3. store</h3><p>将 state 、 action 、 reducer 联系在一起的对象</p><h2 id="先通过一个小案例来体现简单版的redux"><a href="#先通过一个小案例来体现简单版的redux" class="headerlink" title="先通过一个小案例来体现简单版的redux"></a>先通过一个小案例来体现简单版的redux</h2><p>redux使用步骤</p><ol><li><p><strong>创建 reducer.js</strong></p><ul><li>renducer 的本质是一个函数，接收 preState,action， 返回加工后的状态</li><li>renducer 有俩个作用： 初始化状态，加工状态</li><li>注意：renducer 被第一次调用时，是store自动触发的<ul><li>传递的 preState是 undefined</li><li>传递的 action 是：{type:”@@REDUX/INIT_d.5.f.4”} 类似于这种形式的</li></ul></li><li>通过<strong>dispatc（aciton）</strong>，把state（{type,data}）放入reducer函数中加工，并返回新的state。</li></ul></li><li><p><strong>创建 store.js</strong></p><ul><li>引入 redux 中的 <code>createStore</code>方法，创建一个store</li><li><code>createStore</code>调用时要传入一个为其服务的 reducer</li><li>即在此文件中 使用 <code>createStore</code> API</li></ul></li><li><p><strong>在组件中引入 store</strong></p><ul><li>使用 <strong>getState，dispatch，subscribe</strong>等API来实现状态更新。</li></ul></li></ol><p>小试牛刀，按照上面步骤，相应代码如下：</p><pre><code class="hljs jsx"><span class="hljs-comment">// count_reducer JS文件</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">countReducer</span>(<span class="hljs-params">preState =<span class="hljs-number">0</span>, action</span>) &#123;  <span class="hljs-keyword">const</span> &#123; type, data &#125; = action  <span class="hljs-keyword">const</span> typeMap = &#123;    <span class="hljs-string">&quot;increment&quot;</span>: preState + data,    <span class="hljs-string">&quot;decrement&quot;</span>: preState - data  &#125;  <span class="hljs-keyword">if</span> (type <span class="hljs-keyword">in</span> typeMap) &#123;    <span class="hljs-keyword">return</span> typeMap[type]  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-keyword">return</span> preState  &#125;&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> countReducer</code></pre><pre><code class="hljs jsx"><span class="hljs-comment">// store js文件</span><span class="hljs-keyword">import</span> &#123; createStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span><span class="hljs-keyword">import</span> countReducer <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./count_reducer&#x27;</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">createStore</span>(countReducer)</code></pre><pre><code class="hljs jsx"><span class="hljs-comment">// 组件 方法代码</span><span class="hljs-comment">// render 方法中的  &lt;h2&gt;当前求和为：&#123;store.getState()&#125;&lt;/h2&gt;</span>  <span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) &#123;    store.<span class="hljs-title function_">subscribe</span>(<span class="hljs-function">() =&gt;</span> &#123;      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;&#125;)    &#125;)  &#125;  <span class="hljs-comment">// 加法</span>  increment = <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-keyword">const</span> &#123; value &#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">currentNum</span>    store.<span class="hljs-title function_">dispatch</span>(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;increment&quot;</span>, <span class="hljs-attr">data</span>: value * <span class="hljs-number">1</span> &#125;)  &#125;  <span class="hljs-comment">// 减法</span>  decrement = <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-keyword">const</span> &#123; value &#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">currentNum</span>    store.<span class="hljs-title function_">dispatch</span>(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;decrement&quot;</span>, <span class="hljs-attr">data</span>: value * <span class="hljs-number">1</span> &#125;)  &#125;</code></pre><p>目前我们还没有用上 action 这个概念， 所以把代码优化一下：</p><p>优化步骤：</p><ol><li>创建 action.js<ul><li>用来记录用户发生的动作</li><li>专门用于创建action对象</li></ul></li><li>创建 constant.js<ul><li>使用变量控制action中的type，统一管理并防止单词出错</li></ul></li></ol><p>代码如下(我放在一起了)：</p><pre><code class="hljs js"><span class="hljs-comment">// constant.js</span><span class="hljs-comment">// 该模块是用于 定义action对象中的type类型的常量值，目的只有一个：便于管理的同时防止单词写错</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">INCREMENT</span> = <span class="hljs-string">&#x27;increment&#x27;</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">DECREMENT</span> = <span class="hljs-string">&#x27;decrement&#x27;</span><span class="hljs-comment">// action.js</span><span class="hljs-keyword">import</span> &#123; <span class="hljs-variable constant_">INCREMENT</span>,<span class="hljs-variable constant_">DECREMENT</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./constant&#x27;</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">createIncrementAction</span> = data =&gt; (&#123; <span class="hljs-attr">type</span>: <span class="hljs-variable constant_">INCREMENT</span>, data&#125;)<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">createDecrementAction</span> = data =&gt; (&#123; <span class="hljs-attr">type</span>: <span class="hljs-variable constant_">DECREMENT</span>, data&#125;)<span class="hljs-comment">// reducer.js 代码部分优化</span><span class="hljs-comment">// 把原来的字符串改为变量名</span> <span class="hljs-keyword">const</span> typeMap = &#123;    [<span class="hljs-variable constant_">INCREMENT</span>]: preState + data,    [<span class="hljs-variable constant_">DECREMENT</span>]: preState - data  &#125;<span class="hljs-comment">// 组件  实现方法代码优化</span>  increment = <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-keyword">const</span> &#123; value &#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">currentNum</span>    store.<span class="hljs-title function_">dispatch</span>(<span class="hljs-title function_">createIncrementAction</span>(value * <span class="hljs-number">1</span>))  &#125;  decrement = <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-keyword">const</span> &#123; value &#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">currentNum</span>    store.<span class="hljs-title function_">dispatch</span>(<span class="hljs-title function_">createDecrementAction</span>(value * <span class="hljs-number">1</span>))  &#125;</code></pre><p>以上就 过了一遍如何使用<strong>redux</strong>的一个简单流程。</p><h2 id="异步-action"><a href="#异步-action" class="headerlink" title="异步 action"></a>异步 action</h2><p><strong>使用前提：</strong> 如果我们不想把 延迟的动作交给组件自身（也就是异步操作不想在组件内上实现），而想交给action来处理。</p><p><strong>什么时候需要异步action：</strong> 想要对状态进行操作，但是具体的数据需要靠异步任务返回。</p><p>具体步骤：</p><ol><li>npm install redux-thunk， 并在store中配置它<pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123; createStore,applyMiddleware &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span><span class="hljs-comment">// 用于支持异步action</span><span class="hljs-keyword">import</span> thunk <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux-thunk&#x27;</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">createStore</span>(countReducer,<span class="hljs-title function_">applyMiddleware</span>(thunk))</code></pre></li><li>创建action的函数不再返回一般对象，而是一个函数，因为函数可以写异步任务。</li><li>异步任务有结果后，发布一个同步的action去真正操作数据</li></ol><p>案例代码如下：</p><pre><code class="hljs jsx"><span class="hljs-comment">// action.js</span><span class="hljs-comment">// 处理 异步    它必须返回的是一个 函数</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">createIncrementAsyncAction</span> = (<span class="hljs-params">data,time</span>) =&gt; &#123;  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">dispatch</span>) =&gt;</span> &#123;    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;      <span class="hljs-title function_">dispatch</span>(&#123; <span class="hljs-attr">type</span>: <span class="hljs-variable constant_">DECREMENT</span>, data &#125;)     &#125;,time)   &#125;&#125;<span class="hljs-comment">// 组件内的</span>  incrementAsync = <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-keyword">const</span> &#123; value &#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">currentNum</span>    store.<span class="hljs-title function_">dispatch</span>(<span class="hljs-title function_">createIncrementAsyncAction</span>(value * <span class="hljs-number">1</span>, <span class="hljs-number">500</span>))  &#125;</code></pre><p><strong>总结:</strong> 其实我们完全可以自己等待异步任务的结果后再去发布同步action，所以感觉这个 异步action不太重要，了解即可。</p><h2 id="react-redux"><a href="#react-redux" class="headerlink" title="react-redux"></a>react-redux</h2><h3 id="需要明确俩个概念："><a href="#需要明确俩个概念：" class="headerlink" title="需要明确俩个概念："></a>需要明确俩个概念：</h3><ol><li><strong>UI组件：</strong> 不能使用任何 render 的api，只负责页面的呈现，交互等，状态完全由外部控制。</li><li><strong>容器组件：</strong>  负责和redux通信，将结果交给UI组件。</li></ol><h3 id="需要明确俩个核心："><a href="#需要明确俩个核心：" class="headerlink" title="需要明确俩个核心："></a>需要明确俩个核心：</h3><p><strong>Provider 和 connect</strong></p><h4 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a>Provider</h4><p><strong>Provider</strong> 的目的是让所有组件都能够访问到redux中的数据。</p><pre><code class="hljs jsx"><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Provider</span> <span class="hljs-attr">store</span>=<span class="hljs-string">&#123;store&#125;</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">Provider</span>&gt;</span></span>,  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;root&quot;</span>))</code></pre><h4 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h4><p>首先，它的使用是这样子的：</p><pre><code class="hljs js"><span class="hljs-title function_">connect</span>(mapStateToProps, mapDispatchToProps)(component)</code></pre><p><strong>mapStateToProps:</strong></p><ul><li>中文意思: 把state映射到props中。</li><li>映射状态，返回值是一个对象</li></ul><pre><code class="hljs jsx"><span class="hljs-comment">// 容器组件：</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">mapStateToProps</span>(<span class="hljs-params">state</span>) &#123;  <span class="hljs-comment">// 比如 state = &#123; a:123 &#125;</span>  <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">foo</span>: state.<span class="hljs-property">a</span> &#125;&#125;<span class="hljs-comment">//  UI组件：</span><span class="hljs-title function_">render</span>(<span class="hljs-params"></span>)&#123; <span class="hljs-keyword">return</span> (  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123; this.props.foo &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>  <span class="hljs-comment">// 123</span> )&#125;</code></pre><p><strong>mapDispatchToProps：</strong></p><ul><li>中文意思:把各种dispatch也映射到props中的供你使用</li><li>映射操作状态的方法，返回值是一个对象</li></ul><pre><code class="hljs jsx"><span class="hljs-comment">// 容器组件：</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">mapDispatchToProps</span>(<span class="hljs-params">dispatch</span>) &#123;  <span class="hljs-keyword">return</span> &#123;     <span class="hljs-attr">add</span>: <span class="hljs-function"><span class="hljs-params">number</span> =&gt;</span> <span class="hljs-title function_">dispatch</span>(&#123;<span class="hljs-attr">type</span>:<span class="hljs-string">&quot;increment&quot;</span>&#125;,number),  &#125;&#125;<span class="hljs-comment">//  UI组件：</span>&lt;button onClick=&#123;<span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>)&#125;&gt; + &lt;/button&gt;</code></pre>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
      <category>Redux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
      <tag>Redux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>虚拟DOM和diff算法以及关于key的问题（学习总结）</title>
    <link href="/2021/01/26/48-%E8%99%9A%E6%8B%9FDOM/"/>
    <url>/2021/01/26/48-%E8%99%9A%E6%8B%9FDOM/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我为了了解虚拟DOM，是为了更好的学习React和Vue。</p><h2 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h2><p><strong>先说说虚拟DOM的优点：</strong></p><ol><li>减少DOM操作次数</li></ol><p>虚拟DOM可以把多次操作DOM合并为一次操作， 比如：你需要添加100个元素节点，原生操作的话只能一个一个的添加， 但使用虚拟DOM，它可以把这些操作合并为一个操作，最后一次性的添加到DOM中。</p><ol start="2"><li>减少DOM操作范围</li></ol><p>虚拟 DOM 借助 DOM diff 可以把多余的操作省掉，比如你添加 100 个元素节点，其实只有 10 个是新增的，如果用原生来操作，你还是需要一个一个添加进去，而虚拟DOM会根据diff算法来判断只需要添加那些改变的元素节点添加进去即可。</p><h2 id="如何创建虚拟DOM"><a href="#如何创建虚拟DOM" class="headerlink" title="如何创建虚拟DOM"></a>如何创建虚拟DOM</h2><h3 id="1-用React举例：-用React-createElement"><a href="#1-用React举例：-用React-createElement" class="headerlink" title="1. 用React举例：(用React.createElement)"></a>1. 用React举例：(用React.createElement)</h3><pre><code class="hljs js"><span class="hljs-title class_">React</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>,&#123;<span class="hljs-attr">className</span>:<span class="hljs-string">&#x27;red&#x27;</span>,<span class="hljs-attr">onClick</span>:<span class="hljs-function">()=&gt;</span> &#123;&#125;&#125;,[    <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;span&#x27;</span>, &#123;&#125;, <span class="hljs-string">&#x27;span1&#x27;</span>),    <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;span&#x27;</span>, &#123;&#125;, <span class="hljs-string">&#x27;span2&#x27;</span>)  ])</code></pre><p>简写即：（React JSX    ）</p><pre><code class="hljs jsx">&lt;div className=<span class="hljs-string">&quot;red&quot;</span> onClick=<span class="hljs-string">&quot;&#123;()=&gt; &#123;&#125;&#125;&quot;</span>&gt;    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>span1<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>span2<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span>&lt;/div&gt;</code></pre><p><strong>简写方法最后会通过 babel 转为 createElement 形式</strong></p><h3 id="2-用Vue举例：-只能在-render-函数里得到-h"><a href="#2-用Vue举例：-只能在-render-函数里得到-h" class="headerlink" title="2. 用Vue举例：(只能在 render 函数里得到 h)"></a>2. 用Vue举例：(只能在 render 函数里得到 h)</h3><pre><code class="hljs js"><span class="hljs-title function_">h</span>(<span class="hljs-string">&#x27;div&#x27;</span>, &#123;  <span class="hljs-attr">class</span>: <span class="hljs-string">&#x27;red&#x27;</span>,  <span class="hljs-attr">on</span>: &#123;    <span class="hljs-attr">click</span>: <span class="hljs-function">() =&gt;</span> &#123; &#125;  &#125;,&#125;, [<span class="hljs-title function_">h</span>(<span class="hljs-string">&#x27;span&#x27;</span>,&#123;&#125;,<span class="hljs-string">&#x27;span1&#x27;</span>), <span class="hljs-title function_">h</span>(<span class="hljs-string">&#x27;span&#x27;</span>, &#123;&#125;, <span class="hljs-string">&#x27;span2&#x27;</span>])</code></pre><p>简写即： (Vue Template)</p><pre><code class="hljs Vue">&lt;div class=&quot;red&quot; @click=&quot;fn&quot;&gt;  &lt;span&gt;span1&lt;/span&gt;  &lt;span&gt;span2&lt;/span&gt;&lt;/div&gt;</code></pre><p><strong>简写方法最后会通过 vue-loader 转为 h 形式</strong></p><h3 id="虚拟DOM到底是什么"><a href="#虚拟DOM到底是什么" class="headerlink" title="虚拟DOM到底是什么"></a>虚拟DOM到底是什么</h3><p>把真实DOM树，变成js对象树，将之前的和新的作比较，通过diff算法，按照不同的地方进行渲染。</p><p>其实刚刚用React，Vue写的就是虚拟DOM</p><p>它是一个能代表DOM树的对象， 一般会含有 <code>标签名 、 标签属性 、 事件监听 、 子元素以及其他属性等</code></p><h3 id="虚拟DOM的缺点"><a href="#虚拟DOM的缺点" class="headerlink" title="虚拟DOM的缺点"></a>虚拟DOM的缺点</h3><ol><li>需要额外的创建函数，如 createElement 或 h，但可以通过 JSX 来简化成 XML 写法</li><li>严重依赖打包工具、需要添加额外的构建过程。</li></ol><h2 id="diff算法"><a href="#diff算法" class="headerlink" title="diff算法"></a>diff算法</h2><p>使用传统的diff算法进行节点的循环遍历，复杂度是 O(n^3)。(不多说它)</p><h3 id="DOM-diff-是什么？"><a href="#DOM-diff-是什么？" class="headerlink" title="DOM diff 是什么？"></a>DOM diff 是什么？</h3><ul><li>就是一个函数，被称之为 <code>patch</code></li><li>patches = patch(oldVNode,newVnode)</li><li>patches 就是要运行的DOM操作，</li></ul><p>通俗说就是：给我俩个虚拟节点，我给你对应的DOM操作，（这个DOM操作目前不会去立马执行，等到全部虚拟节点都更新完毕后，我再去把该操作一次的执行。）</p><h3 id="DOM-diff-的大概逻辑思路："><a href="#DOM-diff-的大概逻辑思路：" class="headerlink" title="DOM diff 的大概逻辑思路："></a>DOM diff 的大概逻辑思路：</h3><ul><li><strong>Tree diff</strong><ul><li>将新旧两棵DOM树逐层对比，找出哪些节点需要更新</li><li>如果节点是<code>组件</code>就看 Component diff</li><li>如果节点是<code>标签或文本</code>就看 Element diff</li></ul></li><li><strong>Component diff</strong><ul><li>如果节点是组件，就先看组件类型</li><li>类型不同直接替换（删除旧的）</li><li><strong>类型相同则只更新属性</strong></li><li>然后深入组件做 Tree diff（递归）</li></ul></li><li><strong>Element diff</strong><ul><li>如果节点是原生标签，则看标签名</li><li>标签名不同直接替换，<strong>相同则只更新属性</strong></li><li>然后进入标签后代做 Tree diff（递归）</li></ul></li></ul><p>但是，它有个缺点：同级节点对比存在 bug （关于key 的问题）</p><h2 id="key的问题"><a href="#key的问题" class="headerlink" title="key的问题"></a>key的问题</h2><h3 id="面试题：-react-vue（虚拟DOM）中的key有什么作用？-（key的内部实现原理是什么？）"><a href="#面试题：-react-vue（虚拟DOM）中的key有什么作用？-（key的内部实现原理是什么？）" class="headerlink" title="面试题： react/vue（虚拟DOM）中的key有什么作用？ （key的内部实现原理是什么？）"></a>面试题： react/vue（虚拟DOM）中的key有什么作用？ （key的内部实现原理是什么？）</h3><ol><li><p>简单说： key是虚拟DOM对象的标识，在更新显示时key起着重要的作用</p></li><li><p>详细说： 当状态中的数据发生改变时，react/vuew 会根据<code>新数据</code>生成<code>新的虚拟DOM</code>，随后react/vue会进行<code>新虚拟DOM</code>与<code>旧虚拟DOM</code>的diff比较， 比较规则如下：</p><ul><li><code> 新虚拟DOM</code> 中找到了与 <code>旧虚拟DOM</code> 相同<code>key</code><ol><li>若虚拟DOM中内容没变，直接使用之前的真实DOM</li><li>若虚拟DOM中内容发送改变了，则生成新的真实的DOM，随后替换掉页面中之前的真实DOM</li></ol></li><li><code> 新虚拟DOM</code> 中没有找到了与 <code>旧虚拟DOM</code> 相同<code>key</code><ol><li>跟新数据创建新的真实DOM，随后替换到页面</li></ol></li></ul></li></ol><h3 id="面试题：-为什么遍历列表时，key最好不要用index（索引值）？"><a href="#面试题：-为什么遍历列表时，key最好不要用index（索引值）？" class="headerlink" title="面试题： 为什么遍历列表时，key最好不要用index（索引值）？"></a>面试题： 为什么遍历列表时，key最好不要用index（索引值）？</h3><p>用index（索引值）作为key可能会引发的问题：</p><ol><li>若数据进行：<strong>逆序添加、逆序删除等破坏顺序操作</strong><ul><li>会产生没有必要的真实DOM更新 ==&gt; 页面效果虽然没有问题，但是效率低。</li></ul></li><li>如果结构中还包含输入类的DOM：<ul><li>会产生错误DOM更新 ==&gt; 页面渲染会有问题</li></ul></li><li>当然如果只是为了 渲染列表，只展示而已， 那用 index 作为key 是没问题的。</li></ol><p>（我这里没有解释，只是给出了结论，如果想看到底为什么，可看推荐文章）</p><p> 关于key问题的文章推荐：<a href="https://www.zhihu.com/question/61064119/answer/766607894">Vue2.0 v-for 中 :key 到底有什么用？</a></p>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
      <category>Vuejs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
      <tag>Vuejs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React之生命周期</title>
    <link href="/2021/01/26/47-React%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%BA%8C/"/>
    <url>/2021/01/26/47-React%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="React-生命周期（旧）"><a href="#React-生命周期（旧）" class="headerlink" title="React 生命周期（旧）"></a>React 生命周期（旧）</h2><p>先来看图</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/186a79477d02438d9bc5349b6a0ce7d1~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="生命周期（旧）"></p><h3 id="React组件初始化阶段"><a href="#React组件初始化阶段" class="headerlink" title="React组件初始化阶段:"></a>React组件初始化阶段:</h3><p>初始化阶段：由ReactDOM.render()触发 — 初次渲染</p><h4 id="第一步-constructor"><a href="#第一步-constructor" class="headerlink" title="第一步 constructor()"></a>第一步 constructor()</h4><p>用来初始化属性状态<br> <pre><code class="hljs jsx"> <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-variable language_">super</span>()<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;constructor--count组件构造器&#x27;</span>);<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;  <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,  <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;我想要吃的&#x27;</span>&#125;</code></pre></p><h4 id="第二步-componentWillMount"><a href="#第二步-componentWillMount" class="headerlink" title="第二步 componentWillMount()"></a>第二步 componentWillMount()</h4><p>组件将要被挂载阶段 （在组件挂载之前触发）</p><pre><code class="hljs jsx">  <span class="hljs-title function_">componentWillMount</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;componentWillMount--count组件将要被挂载&#x27;</span>);&#125;</code></pre><h4 id="第三步-render"><a href="#第三步-render" class="headerlink" title="第三步 - render()"></a>第三步 - render()</h4><p>组件渲染在页面上</p><pre><code class="hljs jsx"><span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;render--count组件渲染&#x27;</span>);  <span class="hljs-keyword">const</span> &#123; count &#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>  <span class="hljs-keyword">return</span> (    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;count&quot;</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.add&#125;</span>&gt;</span>+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.force&#125;</span>&gt;</span>强制更新，不改变任何数据状态<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>我是Count组件<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.changeMessage&#125;</span>&gt;</span>更换子组件信息<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">CountSon</span> <span class="hljs-attr">message</span>=<span class="hljs-string">&#123;this.state.message&#125;</span> /&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>  )&#125;</code></pre><h4 id="第四步-componentDidMount"><a href="#第四步-componentDidMount" class="headerlink" title="第四步  componentDidMount()"></a>第四步  componentDidMount()</h4><p>组件挂载完毕后 （在组件挂载之后，只会执行一次）</p><pre><code class="hljs jsx">  <span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;componentDidMount--count组件挂载完毕后&#x27;</span>);&#125;</code></pre><p>这个钩子很常用，我们经常会在这个钩子中做一些初始化的操作，比如：开启定时器，发送网络请求，订阅消息等。</p><h3 id="React组件更新阶段："><a href="#React组件更新阶段：" class="headerlink" title="React组件更新阶段："></a>React组件更新阶段：</h3><p><strong>由组件内部的this.setState()或者父组件的render触发</strong></p><h4 id="第一步-componentWillReceiveProps"><a href="#第一步-componentWillReceiveProps" class="headerlink" title="第一步     componentWillReceiveProps()"></a>第一步     componentWillReceiveProps()</h4><p><strong>组件将要接收参数</strong></p><p>组件收到新的属性对象时调用，首次渲染不会触发</p><p>一般是父组件向子组件传props时，当子组件更新了props中的数据，就会触发（第一次传过去时，不会触发）</p><pre><code class="hljs jsx">  <span class="hljs-title function_">componentWillReceiveProps</span>(<span class="hljs-params">props</span>) &#123;  <span class="hljs-comment">// 注意， 第一渲染不算， 第二次才触发</span>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;componentWillReceiveProps--Count的子组件&#x27;</span>, props);&#125;</code></pre><h4 id="第二步：-shouldComponentUpdate"><a href="#第二步：-shouldComponentUpdate" class="headerlink" title="第二步：  shouldComponentUpdate()"></a>第二步：  shouldComponentUpdate()</h4><p>组件是否应该被更新—-控制组件更新的“阀门”</p><p>如果为true就会按照图中所示往下走，如果为false，则将“阀门”关闭，不能往下走了。</p><pre><code class="hljs jsx"><span class="hljs-title function_">shouldComponentUpdate</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;shouldComponentUpdate--count组件是否应该被更新&#x27;</span>);<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>  **&#125;**</code></pre><h4 id="第三步：-componentWillUpdate"><a href="#第三步：-componentWillUpdate" class="headerlink" title="第三步： componentWillUpdate()"></a>第三步： componentWillUpdate()</h4><p>组件将要更新</p><pre><code class="hljs jsx">  <span class="hljs-title function_">componentWillUpdate</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;componentWillUpdate--count组件将要更新&#x27;</span>);&#125;</code></pre><h4 id="第四步：render"><a href="#第四步：render" class="headerlink" title="第四步：render()"></a>第四步：render()</h4><p>会跟新新的属性对象重新渲染组件</p><h4 id="第五步-componentDidUpdate"><a href="#第五步-componentDidUpdate" class="headerlink" title="第五步:    componentDidUpdate()"></a>第五步:    componentDidUpdate()</h4><p>组件更新完毕后触发</p><p>它接收参数（1.props更新前的，2.state更新前的，3.快照值，（在新的生命周期中会提到））</p><pre><code class="hljs jsx"> <span class="hljs-title function_">componentDidUpdate</span>(<span class="hljs-params">preProps, preState, snapShotValue</span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;componentDidUpdate--count组件更新完毕后&#x27;</span>, preProps, preState, snapShotValue);&#125;</code></pre><h3 id="卸载组件阶段"><a href="#卸载组件阶段" class="headerlink" title="卸载组件阶段"></a>卸载组件阶段</h3><p>由ReactDOM.unmountComponentAtNode()触发</p><h4 id="componentWillUnmount"><a href="#componentWillUnmount" class="headerlink" title="componentWillUnmount()"></a>componentWillUnmount()</h4><p>组件将要被卸载时触发,</p><p>一般经常在这个钩子中做一些收尾的操作：比如：关闭定时器，取消订阅消息等。</p><h3 id="（旧）生命周期代码测试"><a href="#（旧）生命周期代码测试" class="headerlink" title="（旧）生命周期代码测试"></a>（旧）生命周期代码测试</h3><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; <span class="hljs-title class_">Component</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Count</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">super</span>()    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;constructor--count组件构造器&#x27;</span>);    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;      <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,      <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;我想要吃的&#x27;</span>    &#125;  &#125;  <span class="hljs-comment">//组件将要被挂载</span>  <span class="hljs-title function_">componentWillMount</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;componentWillMount--count组件将要被挂载&#x27;</span>);  &#125;  <span class="hljs-comment">//组件挂载完毕后</span>  <span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;componentDidMount--count组件挂载完毕后&#x27;</span>);  &#125;  <span class="hljs-comment">// 控制组件更新的“阀门”</span>  <span class="hljs-title function_">shouldComponentUpdate</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;shouldComponentUpdate--count组件是否应该被更新&#x27;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>  &#125;  <span class="hljs-comment">// 组件将要更新</span>  <span class="hljs-title function_">componentWillUpdate</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;componentWillUpdate--count组件将要更新&#x27;</span>);  &#125;  <span class="hljs-comment">//组件更新完毕后</span>  <span class="hljs-title function_">componentDidUpdate</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;componentDidUpdate--count组件更新完毕后&#x27;</span>);  &#125;  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;render--count组件渲染&#x27;</span>);    <span class="hljs-keyword">const</span> &#123; count &#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>    <span class="hljs-keyword">return</span> (      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;count&quot;</span>&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.add&#125;</span>&gt;</span>+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.force&#125;</span>&gt;</span>强制更新，不改变任何数据状态<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>我是Count组件<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span></span><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.changeMessage&#125;</span>&gt;</span>更换子组件信息<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">CountSon</span> <span class="hljs-attr">message</span>=<span class="hljs-string">&#123;this.state.message&#125;</span> /&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>    )  &#125;  add = <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-keyword">const</span> &#123; count &#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;      <span class="hljs-attr">count</span>: count + <span class="hljs-number">1</span>    &#125;)  &#125;  force = <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">forceUpdate</span>()  &#125;  changeMessage = <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-comment">// const &#123; message &#125; = this.state</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;      <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;我想要喝的&quot;</span>    &#125;)  &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">CountSon</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span> &#123;  <span class="hljs-comment">// 组件将要接收参数 </span>  <span class="hljs-title function_">componentWillReceiveProps</span>(<span class="hljs-params">props</span>) &#123;    <span class="hljs-comment">// 注意， 第一渲染不算， 第二次才触发</span>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;componentWillReceiveProps--Count的子组件&#x27;</span>, props);  &#125;  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> (      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>我是Count的子组件<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>我收到父组件的信息：&#123;this.props.message&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>    )  &#125;&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Count</span></code></pre><h2 id="生命周期（新）"><a href="#生命周期（新）" class="headerlink" title="生命周期（新）"></a>生命周期（新）</h2><p>先看图</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/97418c38332b4b61b21847bf700547cb~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="生命周期（新）"></p><h3 id="对比-（旧）生命周期"><a href="#对比-（旧）生命周期" class="headerlink" title="对比 （旧）生命周期"></a>对比 （旧）生命周期</h3><p>对比俩张图发现，旧版的废弃了三个”will”,引来了俩个”get”</p><p><strong>废弃：</strong></p><ul><li>componentWillMount</li><li>componentWillReceiveProps</li><li>componentWillUpdate</li></ul><p><strong>新增：</strong></p><ul><li>getDerivedStateFromProps</li><li>getSnapshotbeforeUpdate</li></ul><h3 id="getDerivedStateFromProps"><a href="#getDerivedStateFromProps" class="headerlink" title="getDerivedStateFromProps"></a>getDerivedStateFromProps</h3><ol><li>是个静态方法，需要在前面加个<code>static</code>，否则会报错，如下：</li></ol><p><code>Lifecycle method should be static: getDerivedStateFromProps</code></p><ol start="2"><li>必须返回属性对象或者null，否则报错，如下：</li></ol><p><code> A valid state object (or null) must be returned. You have returned undefined.</code></p><ol start="3"><li>可以传参数<br><code>参数：新的属性对象(内部数据state)，旧的状态对象（外部数据props）</code></li></ol><p>官网也提出了，这个钩子不建议使用， 因为 派生状态会导致代码冗余，并使组件难以维护。在这里不过多学习它了。</p><h3 id="getDerivedStateFromProps-1"><a href="#getDerivedStateFromProps-1" class="headerlink" title="getDerivedStateFromProps"></a>getDerivedStateFromProps</h3><p>在更新之前获取快照</p><ol><li>有这个钩子必须也要有 componentDidUpdate 这个钩子，需要和它搭配使用</li><li>必须有返回值，返回值 可以是 值，也可以是<code>null</code></li></ol><pre><code class="hljs jsx">  <span class="hljs-title function_">getSnapshotBeforeUpdate</span>(<span class="hljs-params"></span>)&#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;getSnapshotBeforeUpdate--count&#x27;</span>)  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Wangpf&#x27;</span>  &#125;<span class="hljs-title function_">componentDidUpdate</span>(<span class="hljs-params">preProps, preState, snapShotValue</span>)&#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;componentDidUpdate--count组件更新完毕后&#x27;</span>, preProps, preState, snapShotValue);  <span class="hljs-comment">// preProps 外部数据更新前的值</span>  <span class="hljs-comment">// preState 内部数据更新前的值</span>  <span class="hljs-comment">// snapShotValue 是在getDerivedStateFromProps钩子函数中所返回的值</span>&#125;</code></pre><h3 id="getSnapshotBeforeUpdate"><a href="#getSnapshotBeforeUpdate" class="headerlink" title="getSnapshotBeforeUpdate"></a>getSnapshotBeforeUpdate</h3><p>获取更新前的快照值，</p><p>举个例子：</p><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; <span class="hljs-title class_">Component</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./News.css&#x27;</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">News</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span> &#123;  state = &#123;    <span class="hljs-attr">newsArr</span>: []  &#125;  <span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;      <span class="hljs-keyword">const</span> &#123; newsArr &#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>      <span class="hljs-keyword">const</span> news = <span class="hljs-string">`新闻<span class="hljs-subst">$&#123;newsArr.length + <span class="hljs-number">1</span>&#125;</span>`</span>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;        <span class="hljs-attr">newsArr</span>: [news, ...newsArr]      &#125;)    &#125;, <span class="hljs-number">1000</span>)  &#125;  <span class="hljs-title function_">getSnapshotBeforeUpdate</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">listHeight</span>.<span class="hljs-property">scrollHeight</span>  &#125;  <span class="hljs-title function_">componentDidUpdate</span>(<span class="hljs-params">preProps, preState, height</span>) &#123;    <span class="hljs-comment">// 用更新之后的高度 减去 更新之前的高度 再 += 给 更新之后的所在的值 </span>    <span class="hljs-comment">// 这样旧能一直处于最底下了</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">listHeight</span>.<span class="hljs-property">scrollTop</span> += <span class="hljs-variable language_">this</span>.<span class="hljs-property">listHeight</span>.<span class="hljs-property">scrollHeight</span> - height  &#125;  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">const</span> &#123; newsArr &#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>    <span class="hljs-keyword">return</span> (      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;list&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;c</span> =&gt;</span> this.listHeight = c&#125;&gt;</span><span class="language-xml">        &#123;newsArr.map((item, index) =&gt; &#123;</span><span class="language-xml">          return <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;index&#125;</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#x27;news&#x27;</span>&gt;</span>&#123;item&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">        &#125;)&#125;</span><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>    )  &#125;&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">News</span></code></pre><p>上述例子描述的是 ， 可以使用 该钩子来获取更新之前的 scroll 高度， 然后到它一直在滚动时，我希望它一直显示某个位置，而不是随之滚动，一直显示顶部。<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e452b039392a4c89aa66c8d79c09cd82~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="getSnapshotBeforeUpdate"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>记住较为重要的几个钩子</strong></p><ol><li>render : 初始化渲染或者更新渲染时调用的</li><li>componentDidMount：组件挂载完毕后调用，用途如： 开启监听，发送ajax请求</li><li>componentWillUnmount： 组件将要卸载时调用， 用途如： 做一些收尾的工作，如清理定时器，取消订阅等。</li></ol><p><strong>废弃的钩子</strong></p><ol><li>componentWillMount</li><li>componentWillReceiveProps</li><li>componentWillUpdate</li></ol><p>目前版本17.0.1，目前使用的话，会出现警告，需要加上 前缀 UNSAFE_ 才行， 但官方说了在未来18版本之后很可能彻底废弃，因此不建议使用。</p>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React学习总结（一）：组件</title>
    <link href="/2021/01/24/46-React%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B8%80/"/>
    <url>/2021/01/24/46-React%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<h2 id="前言，"><a href="#前言，" class="headerlink" title="前言，"></a>前言，</h2><p>好久没学习了，现在正式开始学习React啦~</p><p>之前有大概了解过React，了解过React的实现原理，所以我打算直接从 <code>组件</code> 来开始我的React学习之旅</p><h2 id="元素与组件"><a href="#元素与组件" class="headerlink" title="元素与组件"></a>元素与组件</h2><p><strong>React元素：</strong></p><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> div = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;div&quot;</span>,...)</code></pre><p><strong>React组件：</strong></p><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> <span class="hljs-title function_">Div</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;div&quot;</span>,...)</code></pre><p>元素和组件的区别就在于 组件必须返回的是一个函数，并且命名首字母要大写！</p><h2 id="什么是组件"><a href="#什么是组件" class="headerlink" title="什么是组件"></a>什么是组件</h2><ul><li>用生活中的例子就是：能和其他物件组合在一起的物件就是组件，</li><li>比如Vue中，一个构造选项就可以表示一个组件。</li><li>在React官方中说到，组件的本质就是JavaScript函数</li></ul><h2 id="React的俩种组件：函数组件与-class-组件"><a href="#React的俩种组件：函数组件与-class-组件" class="headerlink" title="React的俩种组件：函数组件与 class 组件"></a>React的俩种组件：函数组件与 class 组件</h2><h3 id="函数组件"><a href="#函数组件" class="headerlink" title="函数组件"></a>函数组件</h3><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Welcome</span>(<span class="hljs-params">props</span>) &#123;  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;&#125;</code></pre><p>使用方法：</p><pre><code class="hljs jsx">&lt;<span class="hljs-title class_">Welcome</span> name=<span class="hljs-string">&quot;Wangpf&quot;</span>/&gt;</code></pre><h3 id="class组件"><a href="#class组件" class="headerlink" title="class组件"></a>class组件</h3><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Welcome</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;  &#125;&#125;</code></pre><p>使用方法：</p><pre><code class="hljs jsx">&lt;<span class="hljs-title class_">Welcome</span> name=<span class="hljs-string">&quot;Wangpf&quot;</span>/&gt;</code></pre><p>上述两个组件在 React 里是等效的。</p><h2 id="那么-lt-Welcome-gt-会被翻译为-React-createElement-…"><a href="#那么-lt-Welcome-gt-会被翻译为-React-createElement-…" class="headerlink" title="那么 &lt;Welcome /&gt; 会被翻译为 React.createElement(….)"></a>那么 <code>&lt;Welcome /&gt;</code> 会被翻译为 React.createElement(….)</h2><p>我用 <a href="">babel online</a> 来演示一下</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6d2403f697f743368bb78407ca93aeea~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="div"></p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/07c31ac5fbe244b6af0067981296c440~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="&lt;Welcome /&gt;"></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d1b77403eae0408ea6cb176db8a0adbc~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="&lt;Welcome /&gt;"></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/47683cc38e314d7fb7717ff5ebe1e423~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="&lt;Welcome /&gt;"></p><p>总结：</p><ol><li>如果传入的是一个<code>字符串</code>：比如 “div”，则会去创建一个div</li><li>如果传入的是一个<code>函数</code>，则会去调用该函数，<code>获取其返回值</code></li><li>如果传入的是一个<code>类</code>，则会在类前面加个 new（这会导致执行constructor），获取一个组件对象，然后调用对象的render方法，<code>获取其返回值</code></li></ol><h2 id="小试牛刀"><a href="#小试牛刀" class="headerlink" title="小试牛刀"></a>小试牛刀</h2><p><strong>分别用俩种组件方式来写props(外部数据，传参)、state（内部数据）：</strong></p><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;./style.css&quot;</span>;<span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">return</span> (    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;App&quot;</span>&gt;</span></span><span class="language-xml">      父组件</span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Son</span> <span class="hljs-attr">messageForSon</span>=<span class="hljs-string">&quot;我是你的老大&quot;</span> /&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>  );&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">super</span>()    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;      <span class="hljs-attr">n</span>: <span class="hljs-number">0</span>    &#125;  &#125;  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> (      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;Son&quot;</span>&gt;</span></span><span class="language-xml">        子组件</span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span> n: &#123;this.state.n&#125; <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123; this.add() &#125;&#125;&gt; +1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是子组件，父组件对我说：&#123;this.props.messageForSon&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Grandson</span> <span class="hljs-attr">messageForGrandson</span>=<span class="hljs-string">&quot;我是你的老大,你是我老大的孙子&quot;</span> /&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>    )  &#125;  <span class="hljs-title function_">add</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-comment">// this.setState(&#123;</span>    <span class="hljs-comment">//   n: this.state.n + 1</span>    <span class="hljs-comment">// &#125;)</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(<span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> &#123;      <span class="hljs-keyword">const</span> n = state.<span class="hljs-property">n</span> + <span class="hljs-number">1</span>      <span class="hljs-comment">// console.log(n);</span>      <span class="hljs-keyword">return</span> &#123; n &#125;    &#125;)  &#125; &#125;<span class="hljs-keyword">const</span> <span class="hljs-title function_">Grandson</span> = (<span class="hljs-params">props</span>) =&gt; &#123;  <span class="hljs-keyword">const</span> [n, setN] = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>)  <span class="hljs-keyword">return</span> (    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;Grandson&quot;</span>&gt;</span></span><span class="language-xml">      孙组件</span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span> n : &#123;n&#125; <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123; setN(n + 1) &#125;&#125;&gt; +1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是孙组件，子组件对我说：&#123;props.messageForGrandson&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>  )&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span></code></pre><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/edfe90e98e6d482baad5706cf115978e~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="俩种组件的书写方式"></p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p><strong>使用props（外部数据）</strong></p><ul><li>类组件 会直接读取<code>属性</code> this.props.xxx</li><li>函数组件 会直接读取<code>参数</code> props.xxx</li></ul><p><strong>使用state（内部数据）</strong></p><ul><li>类组件 用 this.state 读，  this.setState 写</li><li>函数组件 用 useState 返回数组，第一项是读， 第二项是写<ul><li>const [n, setN] = React.useState(0) </li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>node.js中使用nodemailer插件发送邮件 (学习总结)</title>
    <link href="/2021/01/09/45-Docker%20%E5%AE%89%E8%A3%85/"/>
    <url>/2021/01/09/45-Docker%20%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>我使用是的window10系统</strong></p><p>由于学Node.js ，刚刚接触到数据库， 需要Docker来搭配。 </p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol><li>首先要去Docker官网注册一个账号-&gt;<a href="https://hub.docker.com/">注册地址</a></li><li>下载 Docker Desktop for Windows -&gt; <a href="https://hub.docker.com/editions/community/docker-ce-desktop-windows/">下载地址</a></li><li>傻瓜式安装即可</li></ol><h2 id="坑1"><a href="#坑1" class="headerlink" title="坑1"></a>坑1</h2><p>下载完成后必须要重启， 可我重启后点开时，发现报错<br>忘记截图了， 就找到响应的错误报告：</p><p><code>Docker for Windows error: “Hardware assisted virtualization and data execution protection must be enabled in the BIOS”</code></p><p>找了半天解决方法，</p><p>原因在于</p><p><strong>在确保hyper-v组件已经开启情况下，我没有开启 虚拟化</strong></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c7bb4253daed4a6288c1348c0ff03bc4~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="虚拟化"></p><p>开启虚拟化链接 -&gt; <a href="https://jingyan.baidu.com/article/ab0b56305f2882c15afa7dda.html">在BOIS开启虚拟化方法</a></p><h2 id="坑2"><a href="#坑2" class="headerlink" title="坑2"></a>坑2</h2><p>终于解决掉坑一了， 可是当我启动 docker desktop 但是小鲸鱼图标红色，显示启动失败。<br>哎，怎么又报错啊。</p><p>报错如下（网上找到报错图，但和我报错一样）：<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e622853cb5d3439591259cb7075385aa~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="WSL"></p><p>又经过一段时间的查找资料，<strong>意思就是说 WSL 版本低，需要去重新更新一下</strong>。</p><p>于是 我又去 微软官网下载最新版的wsl2 安装后发现，终于可以打开了！</p><h2 id="配置国内镜像"><a href="#配置国内镜像" class="headerlink" title="配置国内镜像"></a>配置国内镜像</h2><p>我用的是阿里云的镜像服务</p><p><strong>可去阿里云注册一个账号，然后搜索容器镜像服务，找到镜像加速器</strong>，有自己的加速器地址，下边也有相关的文档。<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/09786d85f1ed403cabee8d1cd2c42010~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="容器镜像服务"></p><p><strong>复制完地址后，在Docker设置中添上属于你的地址即可</strong></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dcb14fea69ac4ecb8e2b6c9c4f9afa50~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="配置国内镜像"></p><h3 id="试一试是否成功"><a href="#试一试是否成功" class="headerlink" title="试一试是否成功"></a>试一试是否成功</h3><p>打开命令行输入 docker –version 可查看版本号</p><p>输入 docker run hello-world 会使用刚刚配置的国内镜像去下载一个包，然后并返回 Hello from Docker!</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/90510e399dab42a68be7553894e44562~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="docker run hello-world"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上是我安装Docker时踩过的坑， 记录一下，防止以后重新安装时又手忙脚乱的。</p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在Node.js上做一个使用命令行操作todo</title>
    <link href="/2021/01/05/44-%E5%9C%A8Node.js%E4%B8%8A%E5%81%9A%E4%B8%80%E4%B8%AA%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9Ctodo/"/>
    <url>/2021/01/05/44-%E5%9C%A8Node.js%E4%B8%8A%E5%81%9A%E4%B8%80%E4%B8%AA%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9Ctodo/</url>
    
    <content type="html"><![CDATA[<blockquote><p>源代码链接：<a href="https://github.com/wangpf1129/pf-node-todo">https://github.com/wangpf1129/pf-node-todo</a></p></blockquote><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>下载npm包：</p><pre><code class="hljs bash">npm install -g pf-node-todo// 或者yarn global add pf-node-todo</code></pre><p>下载后可查看版本：</p><pre><code class="hljs bash">todo --version</code></pre><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><ol><li>todo   查看所有任务列表<ul><li>能够操作所有增删改查</li></ul></li><li>todo add <taskName> 添加一个任务</li><li>todo clear 清空所有任务</li></ol><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>用来测试 读文件 和  写文件</p><pre><code class="hljs bash">yarn <span class="hljs-built_in">test</span> // 或者npm run <span class="hljs-built_in">test</span></code></pre><h3 id="项目效果演示"><a href="#项目效果演示" class="headerlink" title="项目效果演示"></a>项目效果演示</h3><p><strong>查看版本号：</strong></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bab9bb41e5204dd4b9ed6fa2c7bd76c2~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="查看版本号"></p><p><strong>添加任务：</strong></p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/780644345fff4376a24a2f5593346e22~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="添加任务"></p><p><strong>查看所有任务以及其他操作：</strong></p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/733c3370922943fa93a209d7d7ea37fe~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="查看所有任务以及其他操作"></p><p><strong>清除所有任务：</strong></p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a95f298a56ad4452a95faff64507d472~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="清除所有任务"></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
      <category>Nodejs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nodejs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TypeScript 学习总结之 泛型</title>
    <link href="/2020/12/30/43.TypeScript%E7%B3%BB%E5%88%975/"/>
    <url>/2020/12/30/43.TypeScript%E7%B3%BB%E5%88%975/</url>
    
    <content type="html"><![CDATA[<p>​<br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/408cfbc308734bd8bcbb8a36c40135d0~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="TypeScript"></p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>在像C#和Java这样的语言中，可以使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。</p><pre><code class="hljs ts"><span class="hljs-comment">// T : 泛型变量 | 类型变量</span><span class="hljs-keyword">function</span> identity&lt;T&gt;(<span class="hljs-attr">arg</span>: T): T &#123;  <span class="hljs-keyword">return</span> arg;&#125;<span class="hljs-title function_">identity</span>(<span class="hljs-number">123</span>)<span class="hljs-title function_">identity</span>(<span class="hljs-string">&#x27;123&#x27;</span>)</code></pre><p>代码中 <strong>T 代表 「Type」</strong>，在定义泛型时通常用作第一个类型变量名称。但实际上 T 可以用任何有效名称代替。</p><p>由于我们操作的是数组，所以.length属性是应该存在的。 我们可以像创建其它数组一样创建这个数组：</p><pre><code class="hljs ts"><span class="hljs-keyword">function</span> loggingIdentity&lt;T&gt;(<span class="hljs-attr">arg</span>: T[]): T[] &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arg.<span class="hljs-property">length</span>);  <span class="hljs-comment">// Array has a .length, so no more error</span>  <span class="hljs-keyword">return</span> arg;&#125;</code></pre><p>其实并不是只能定义一个类型变量，我们可以引入希望定义的任何数量的类型变量。比如我们引入一个新的类型变量 <code>U</code>，用于扩展我们定义的 <code>identity</code> 函数：</p><pre><code class="hljs ts"><span class="hljs-keyword">function</span> identity&lt;T, U&gt;(<span class="hljs-attr">value</span>: T, <span class="hljs-attr">message</span>: U): T &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message);  <span class="hljs-keyword">return</span> value;&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">identity</span>(<span class="hljs-number">666</span>, <span class="hljs-string">&quot;jack is cool!&quot;</span>));</code></pre><h2 id="泛型类型-amp-amp-泛型接口"><a href="#泛型类型-amp-amp-泛型接口" class="headerlink" title="泛型类型 &amp;&amp; 泛型接口"></a>泛型类型 &amp;&amp; 泛型接口</h2><p>泛型类型不同的注解方式:</p><ol><li>函数泛型的注解方式</li><li>对象字面量的方式来定义泛型类型</li><li>泛型接口的定义方式<pre><code class="hljs ts"><span class="hljs-comment">//  泛型类型的不同方式</span><span class="hljs-keyword">function</span> identity&lt;T&gt;(<span class="hljs-attr">arg</span>: T): T &#123;  <span class="hljs-keyword">return</span> arg;&#125;<span class="hljs-comment">// 1. 函数泛型的注解方式：</span><span class="hljs-keyword">let</span> <span class="hljs-attr">a</span>: &lt;T&gt;<span class="hljs-function">(<span class="hljs-params">arg: T</span>) =&gt;</span> T = identity<span class="hljs-comment">// 2. 对象字面量的方式来定义泛型类型</span><span class="hljs-keyword">let</span> <span class="hljs-attr">b</span>: &#123; &lt;T&gt;(<span class="hljs-attr">arg</span>: T): T &#125; = identity<span class="hljs-comment">// 3. 泛型接口的定义方式</span><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IdentityInterface</span> &#123;  &lt;T&gt;(<span class="hljs-attr">arg</span>: T): T&#125;<span class="hljs-keyword">let</span> <span class="hljs-attr">c</span>: <span class="hljs-title class_">IdentityInterface</span> = identity</code></pre></li></ol><h2 id="泛型类-amp-泛型约束"><a href="#泛型类-amp-泛型约束" class="headerlink" title="泛型类 &amp; 泛型约束"></a>泛型类 &amp; 泛型约束</h2><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><p>泛型类看上去与泛型接口差不多，我们只需要在类名后面，使用 &lt;T, …&gt; 的语法定义任意多个类型变量，具体示例如下：</p><pre><code class="hljs ts"><span class="hljs-comment">// 泛型类</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinClass</span>&lt;T&gt;&#123;  <span class="hljs-keyword">public</span> <span class="hljs-attr">list</span>: T[] = []  <span class="hljs-title function_">add</span>(<span class="hljs-params">num: T</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span>.<span class="hljs-title function_">push</span>(num)  &#125;  <span class="hljs-title function_">min</span>(): T &#123;    <span class="hljs-keyword">let</span> minNum = <span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span>[<span class="hljs-number">0</span>]    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span>.<span class="hljs-property">length</span>; i++) &#123;      <span class="hljs-keyword">if</span> (minNum &gt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span>[i]) &#123;        minNum = <span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span>[i]      &#125;    &#125;    <span class="hljs-keyword">return</span> minNum  &#125;&#125;</code></pre><p>我们在什么时候需要使用泛型呢？通常在决定是否使用泛型时，我们有以下两个参考标准：</p><ul><li>当你的函数、接口或类将处理多种数据类型时；</li><li>当函数、接口或类在多个地方使用该数据类型时。</li></ul><h3 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h3><p><strong>有时我们可能希望限制每个类型变量接受的类型数量，这就是泛型约束的作用。</strong></p><p>以官方文档例子为例：</p><p>我们需要去定义一个接口来描述约束条件。</p><p>创建一个包含 .length属性的接口，使用这个接口和extends关键字来实现约束：</p><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">LengthInterface</span> &#123;  <span class="hljs-attr">length</span>: <span class="hljs-built_in">number</span>&#125;<span class="hljs-keyword">function</span> loggingIdentity&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">LengthInterface</span>&gt;(<span class="hljs-attr">arg</span>: T): T &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arg.<span class="hljs-property">length</span>);  <span class="hljs-keyword">return</span> arg;&#125;</code></pre><p>其中,<strong>泛型约束用的是： extends 继承接口的方式（不一定非要是接口）</strong> 、<code>T extends LengthInterface </code>用于告诉编译器，我们支持已经实现 Length 接口的任何类型</p><p>另外， 泛型约束并不一定用接口方式， 比如 我们可以把以上代码 接口 换成 类型别名 ,<br>如下例子：<br>// 以类型别名的方式依然可以</p><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">LengthType</span> = <span class="hljs-built_in">string</span><span class="hljs-keyword">function</span> loggingIdentity&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">LengthType</span>&gt;(<span class="hljs-attr">arg</span>: T): T &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arg.<span class="hljs-property">length</span>);  <span class="hljs-keyword">return</span> arg;&#125;</code></pre><h4 id="keyof-操作符"><a href="#keyof-操作符" class="headerlink" title="keyof 操作符"></a>keyof 操作符</h4><p><strong>keyof操作符可以用于获取某种类型的所有键，其返回类型是联合类型。</strong></p><pre><code class="hljs ts"><span class="hljs-comment">// keyof 操作符</span><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> &#123;  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;  <span class="hljs-attr">location</span>: <span class="hljs-built_in">string</span>;&#125;<span class="hljs-keyword">type</span> <span class="hljs-variable constant_">K1</span> = keyof <span class="hljs-title class_">Person</span>; <span class="hljs-comment">// &quot;name&quot; | &quot;age&quot; | &quot;location&quot;</span><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">K2</span> = keyof <span class="hljs-title class_">Person</span>[];  <span class="hljs-comment">// number | &quot;length&quot; | &quot;push&quot; | &quot;concat&quot; | ...</span><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">K3</span> = keyof &#123; [<span class="hljs-attr">x</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-title class_">Person</span> &#125;;  <span class="hljs-comment">// string | number</span></code></pre><p>可以看出， k1,k2,k3其实是键名</p><h4 id="在泛型约束中使用类型参数"><a href="#在泛型约束中使用类型参数" class="headerlink" title="在泛型约束中使用类型参数"></a>在泛型约束中使用类型参数</h4><p>当我们理解了 keyof 操作符时， 看下面代码就很好理解了</p><pre><code class="hljs ts"><span class="hljs-keyword">function</span> getProperty&lt;T, K <span class="hljs-keyword">extends</span> keyof T&gt;(<span class="hljs-attr">obj</span>: T, <span class="hljs-attr">key</span>: K) &#123;  <span class="hljs-keyword">return</span> obj[key];&#125;<span class="hljs-keyword">let</span> x = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">d</span>: <span class="hljs-number">4</span> &#125;;<span class="hljs-title function_">getProperty</span>(x, <span class="hljs-string">&quot;a&quot;</span>); <span class="hljs-comment">// okay</span><span class="hljs-title function_">getProperty</span>(x, <span class="hljs-string">&quot;m&quot;</span>); <span class="hljs-comment">// error: Argument of type &#x27;m&#x27; isn&#x27;t assignable to &#x27;a&#x27; | &#x27;b&#x27; | &#x27;c&#x27; | &#x27;d&#x27;.</span></code></pre><p>**而 K 就是指  ‘a’ , ‘b’ , ‘c’ , ‘d’ **</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c050952b0be44d5bd16b959967b04ac~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="K"></p><p>很明显通过使用泛型约束，在编译阶段我们就可以提前发现错误，大大提高了程序的健壮性和稳定性。</p><h3 id="多重泛型约束-amp-交叉类型"><a href="#多重泛型约束-amp-交叉类型" class="headerlink" title="多重泛型约束 &amp;  交叉类型"></a>多重泛型约束 &amp;  交叉类型</h3><p>交叉类型是将多个类型合并为一个类型。 这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。</p><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> extend&lt;T, U&gt;(<span class="hljs-attr">first</span>: T, <span class="hljs-attr">second</span>: U): T &amp; U &#123;  <span class="hljs-keyword">let</span> result = &lt;T &amp; U&gt;&#123;&#125;;  // 断言， 表示 result 包含 T  U 俩种类型  for (let id in first) &#123;      (&lt;any&gt;result)[id] = (&lt;any&gt;first)[id];   // 将 first 中所有属性 给 result  &#125;  for (let id in second) &#123;    if (!result.hasOwnProperty(id)) &#123;      (&lt;any&gt;result)[id] = (&lt;any&gt;second)[id];        // 将 second 中所有属性 给 result, 前提是result 没有该属性时    &#125;  &#125;  return result;   // 返回的 result 就有  first 和 second 的所有属性&#125;class Person &#123;  constructor(public name: string) &#123; &#125;&#125;interface Loggable &#123;  log(): void;&#125;class ConsoleLogger implements Loggable &#123;  log() &#123;    // ...  &#125;&#125;var jim = extend(new Person(&quot;Jim&quot;), new ConsoleLogger());var n = jim.name;jim.log();</code></pre><p>再举个简单例子：</p><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Sentence</span> &#123;  <span class="hljs-attr">content</span>: <span class="hljs-built_in">string</span>  <span class="hljs-attr">title</span>: <span class="hljs-built_in">string</span>&#125;<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Music</span> &#123;  <span class="hljs-attr">url</span>: <span class="hljs-built_in">string</span>&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Sentence</span> &amp; <span class="hljs-title class_">Music</span>&gt;&#123;  <span class="hljs-attr">props</span>: T  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> arg: T</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span> = arg  &#125;  <span class="hljs-title function_">info</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> &#123;    <span class="hljs-comment">// 这里可以 this.props.xxx 的原因是因为 arg 符合 T类型， 而T 又继承了上面俩个接口的属性。</span>      <span class="hljs-attr">content</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">content</span>,      <span class="hljs-attr">title</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">title</span>,      <span class="hljs-attr">url</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">url</span>    &#125;  &#125;&#125;</code></pre><h3 id="泛型中的类类型"><a href="#泛型中的类类型" class="headerlink" title="泛型中的类类型"></a>泛型中的类类型</h3><p><strong>泛型中的类类型 目的是 约束或者更好的推论</strong></p><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BeeKeeper</span> &#123;  <span class="hljs-attr">hasMask</span>: <span class="hljs-built_in">boolean</span>;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">ZooKeeper</span> &#123;  <span class="hljs-attr">nametag</span>: <span class="hljs-built_in">string</span>;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;  <span class="hljs-attr">numLegs</span>: <span class="hljs-built_in">number</span>;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Bee</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span> &#123;  <span class="hljs-attr">keeper</span>: <span class="hljs-title class_">BeeKeeper</span>;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Lion</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span> &#123;  <span class="hljs-attr">keeper</span>: <span class="hljs-title class_">ZooKeeper</span>;&#125;<span class="hljs-keyword">function</span> createInstance&lt;A <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>&gt;(<span class="hljs-attr">c</span>: <span class="hljs-keyword">new</span> () =&gt; A): A &#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">c</span>();&#125;<span class="hljs-title function_">createInstance</span>(<span class="hljs-title class_">Lion</span>).<span class="hljs-property">keeper</span>.<span class="hljs-property">nametag</span>;  <span class="hljs-comment">// typechecks!</span><span class="hljs-title function_">createInstance</span>(<span class="hljs-title class_">Bee</span>).<span class="hljs-property">keeper</span>.<span class="hljs-property">hasMask</span>;   <span class="hljs-comment">// typechecks!</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>typescript</category>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>typescript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TypeScript 学习总结之 接口</title>
    <link href="/2020/12/29/42.TypeScript%E7%B3%BB%E5%88%974/"/>
    <url>/2020/12/29/42.TypeScript%E7%B3%BB%E5%88%974/</url>
    
    <content type="html"><![CDATA[<p>​<br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/408cfbc308734bd8bcbb8a36c40135d0~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="TypeScript"></p><h2 id="接口-interface"><a href="#接口-interface" class="headerlink" title="接口 interface"></a>接口 interface</h2><blockquote><p>在 TypeScript 学习总结之基础类型 那一章节中，我稍微学习了一下 接口 interface， 对它有了初步了解， 接下来总结的是 TS文档接口这一章节。</p></blockquote><h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h3><p>以官方文档代码为例， 我分析了几种函数注解的方式：</p><p><strong>方式一:</strong></p><p>（最常见的）</p><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">SearchFunc</span> &#123;  (<span class="hljs-attr">source</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">subString</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">boolean</span>;&#125;<span class="hljs-keyword">let</span> <span class="hljs-attr">mySearch</span>: <span class="hljs-title class_">SearchFunc</span>;mySearch = <span class="hljs-keyword">function</span> (<span class="hljs-params">source: <span class="hljs-built_in">string</span>, subString: <span class="hljs-built_in">string</span></span>) &#123;  <span class="hljs-keyword">let</span> result = source.<span class="hljs-title function_">search</span>(subString);  <span class="hljs-keyword">return</span> result &gt; -<span class="hljs-number">1</span>;&#125;</code></pre><p><strong>方式二:</strong></p><p>// 这种注解方式， 你会发现它同样把函数的实现方式也给实现了。 这样做不太好</p><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">SearchFunc</span> &#123;  (<span class="hljs-attr">source</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">subString</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">boolean</span>;&#125;<span class="hljs-comment">// let mySearch: SearchFunc;</span><span class="hljs-comment">// mySearch = function (source: string, subString: string) &#123;</span><span class="hljs-comment">//   let result = source.search(subString);</span><span class="hljs-comment">//   return result &gt; -1;</span><span class="hljs-comment">// &#125;</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">mySearch</span>(<span class="hljs-params">source: <span class="hljs-built_in">string</span>, subString: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">boolean</span> &#123;  <span class="hljs-keyword">let</span> result = source.<span class="hljs-title function_">search</span>(subString);  <span class="hljs-keyword">return</span> result &gt; -<span class="hljs-number">1</span>;&#125;</code></pre><p><strong>方式三：</strong></p><p>// 通过 表达式的方式   你会发现 代码会显得特别长</p><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">SearchFunc</span> &#123;  (<span class="hljs-attr">source</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">subString</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">boolean</span>;&#125;<span class="hljs-keyword">let</span> <span class="hljs-attr">mySearch</span>: <span class="hljs-function">(<span class="hljs-params">source: <span class="hljs-built_in">string</span>, subString: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">boolean</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">source: <span class="hljs-built_in">string</span>, subString: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">boolean</span> &#123;  <span class="hljs-keyword">let</span> result = source.<span class="hljs-title function_">search</span>(subString);  <span class="hljs-keyword">return</span> result &gt; -<span class="hljs-number">1</span>&#125;</code></pre><p><strong>方式四：</strong></p><p> 把方式三  给抽离出来看看 </p><ol><li>使用类型别名：   </li><li>使用 接口 interface （这个和方式一 就一模一样了）)</li></ol><p>// 1.类型别名 方式</p><pre><code class="hljs ts"><span class="hljs-comment">// 类型别名 方式</span><span class="hljs-keyword">type</span> <span class="hljs-title class_">SearchFunc</span> = <span class="hljs-function">(<span class="hljs-params">source: <span class="hljs-built_in">string</span>, subString: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">boolean</span><span class="hljs-keyword">let</span> <span class="hljs-attr">mySearch</span>: <span class="hljs-title class_">SearchFunc</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">source: <span class="hljs-built_in">string</span>, subString: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">boolean</span> &#123;  <span class="hljs-keyword">let</span> result = source.<span class="hljs-title function_">search</span>(subString);  <span class="hljs-keyword">return</span> result &gt; -<span class="hljs-number">1</span>&#125;</code></pre><p>// 2.接口 interface方式 （最常见的）</p><pre><code class="hljs ts"><span class="hljs-comment">// 接口 interface</span><span class="hljs-keyword">interface</span> <span class="hljs-title class_">SearchFunc</span> &#123;  (<span class="hljs-attr">source</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">subString</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">boolean</span>&#125;<span class="hljs-keyword">let</span> <span class="hljs-attr">mySearch</span>: <span class="hljs-title class_">SearchFunc</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">source: <span class="hljs-built_in">string</span>, subString: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">boolean</span> &#123;  <span class="hljs-keyword">let</span> result = source.<span class="hljs-title function_">search</span>(subString);  <span class="hljs-keyword">return</span> result &gt; -<span class="hljs-number">1</span>&#125;</code></pre><h3 id="可索引的类型-接口"><a href="#可索引的类型-接口" class="headerlink" title="可索引的类型 接口"></a>可索引的类型 接口</h3><blockquote><p>可索引的类型的接口   指的就是 数组类型的接口</p></blockquote><p>可索引类型具有一个 索引签名，它描述了对象索引的类型，还有相应的索引返回值类型。</p><p>TypeScript支持两种索引签名：字符串和数字。 可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。 </p><p>示例：</p><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">NumberArray</span> &#123;  [<span class="hljs-attr">index</span>: <span class="hljs-built_in">number</span>]: <span class="hljs-built_in">number</span>&#125;<span class="hljs-keyword">let</span> <span class="hljs-attr">obj</span>: <span class="hljs-title class_">NumberArray</span> = &#123;  <span class="hljs-number">0</span>: <span class="hljs-number">1</span>,   <span class="hljs-comment">// 其实这个索引值 0 1 2 都是字符串 虽然定义的是数字， 但终究会转换成string</span>  <span class="hljs-number">1</span>: <span class="hljs-number">2</span>,  <span class="hljs-number">2</span>: <span class="hljs-number">3</span>&#125;<span class="hljs-keyword">let</span> <span class="hljs-attr">arr</span>: <span class="hljs-title class_">NumberArray</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]</code></pre><p>因为当使用 number来索引时， JavaScript终究会将它转换成string 然后再去索引对象。</p><p><strong>由此可知：在索引签名中， string是包含着number的</strong></p><p>再举个例子:</p><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span> &#123;  <span class="hljs-attr">breed</span>: <span class="hljs-built_in">string</span>;&#125;<span class="hljs-comment">// 错误：使用数值型的字符串索引，有时会得到完全不同的Animal!</span><span class="hljs-comment">// interface NotOkay &#123;</span><span class="hljs-comment">//   [x: number]: Animal;</span><span class="hljs-comment">//   [x: string]: Dog;</span><span class="hljs-comment">// &#125;</span><span class="hljs-comment">// success</span><span class="hljs-keyword">interface</span> <span class="hljs-title class_">NotOkay</span> &#123;  [<span class="hljs-attr">x</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-title class_">Animal</span>;<span class="hljs-comment">//因为Animal是父类，只能是string</span>  [<span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>]: <span class="hljs-title class_">Dog</span>; <span class="hljs-comment">// Dog继承了Animal 但索引又想和Animal一样，那么把它换成number即可</span>&#125;</code></pre><hr><p>再看看 索引的返回值， 索引签名中 规定是什么类型就是什么类型， </p><p>因为 对象中key 一定是字符串，但value 不一定是</p><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">NumberDictionary</span> &#123;  [<span class="hljs-attr">index</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">number</span>;  <span class="hljs-attr">length</span>: <span class="hljs-built_in">number</span>;    <span class="hljs-comment">// 可以，length是number类型</span>  <span class="hljs-comment">// name: string       // 错误，`name`的类型与索引类型返回值的类型不匹配</span>  <span class="hljs-attr">name</span>:<span class="hljs-built_in">number</span>  <span class="hljs-comment">// OK</span>&#125;</code></pre><h3 id="类-类型接口"><a href="#类-类型接口" class="headerlink" title="类 类型接口"></a>类 类型接口</h3><blockquote><p>对 类 的一部分行为进行抽象；</p></blockquote><blockquote><p>类实现所有接口中的属性和方法 &amp;&amp; 对比 对象类： 抽象方法需要实现</p></blockquote><p>与C#或Java里接口的基本作用一样，TypeScript也能够用它来明确的强制一个类去符合某种契约。</p><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ClockInterface</span> &#123;  <span class="hljs-attr">currentTime</span>: <span class="hljs-title class_">Date</span>;<span class="hljs-comment">// 定义属性</span>  <span class="hljs-title function_">setTime</span>(<span class="hljs-attr">d</span>: <span class="hljs-title class_">Date</span>): <span class="hljs-built_in">void</span>   <span class="hljs-comment">// 定义方法</span>&#125;<span class="hljs-comment">// implements  实现   专门用来实现接口</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Clock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ClockInterface</span> &#123;   currentTime = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<span class="hljs-comment">// 实现实现</span>   <span class="hljs-title function_">setTime</span>(<span class="hljs-params"></span>) &#123;   <span class="hljs-comment">// 实现方法</span>  &#125;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">h: <span class="hljs-built_in">number</span>, m: <span class="hljs-built_in">number</span></span>) &#123; &#125;&#125;</code></pre><p><strong>类继承+类类型接口 示例：</strong></p><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Alarm</span> &#123;   <span class="hljs-comment">//  警告器</span>  <span class="hljs-title function_">alert</span>(): <span class="hljs-built_in">void</span>&#125;<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Light</span> &#123;   <span class="hljs-comment">//  车灯</span>  <span class="hljs-attr">color</span>: <span class="hljs-built_in">string</span>  <span class="hljs-title function_">lightOn</span>(): <span class="hljs-built_in">void</span>  <span class="hljs-title function_">lightOff</span>(): <span class="hljs-built_in">void</span>&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Door</span> &#123;&#125;<span class="hljs-comment">// 继承 Door （门） 这个类  然后实现   Alarm  接口</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">securityDoor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Door</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Alarm</span> &#123;  <span class="hljs-title function_">alert</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;咚咚咚&#x27;</span>);  &#125;&#125;<span class="hljs-comment">// car 要实现 这个俩个接口的方法和属性</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">car</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Alarm</span>, <span class="hljs-title class_">Light</span> &#123;  color = <span class="hljs-string">&#x27;red&#x27;</span>  <span class="hljs-title function_">alert</span>(<span class="hljs-params"></span>) &#123; &#125;  <span class="hljs-title function_">lightOn</span>(<span class="hljs-params"></span>) &#123; &#125;  <span class="hljs-title function_">lightOff</span>(<span class="hljs-params"></span>) &#123; &#125;&#125;</code></pre><h3 id="类静态部分与实例部分的区别"><a href="#类静态部分与实例部分的区别" class="headerlink" title="类静态部分与实例部分的区别"></a>类静态部分与实例部分的区别</h3><p>类是具有两个类型的：静态部分的类型和实例的类型</p><p>而constructor 存在于类的静态部分， 所以不再检查的范围内</p><p>因此，类静态部分和实例部分需要单独分开来做</p><p>示例：</p><pre><code class="hljs ts"><span class="hljs-comment">// 定于一个  闹钟接口</span><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ClockInterface</span> &#123;  <span class="hljs-attr">currentTime</span>: <span class="hljs-title class_">Date</span>  <span class="hljs-title function_">getTime</span>(<span class="hljs-attr">hour</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">mins</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">any</span>&#125;<span class="hljs-comment">// 定于一个  闹钟构造函数接口</span><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ClockConstructor</span> &#123;  <span class="hljs-title function_">new</span>(<span class="hljs-attr">hour</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">mins</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">any</span>&#125;<span class="hljs-comment">// Clock 去实现 闹钟接口ClockInterface</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Clock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ClockInterface</span> &#123;  currentTime = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()  <span class="hljs-title function_">getTime</span>(<span class="hljs-params"></span>) &#123;  &#125;&#125;<span class="hljs-comment">// 定义一个构造函数 createClock 通过构造函数检查构造函数的方式 去 new 一个C</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">createClock</span>(<span class="hljs-params">C: ClockConstructor, hour: <span class="hljs-built_in">number</span>, mins: <span class="hljs-built_in">number</span></span>) &#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">C</span>(hour, mins)&#125;<span class="hljs-comment">// 实例化</span><span class="hljs-keyword">let</span> clock = <span class="hljs-title function_">createClock</span>(<span class="hljs-title class_">Clock</span>, <span class="hljs-number">12</span>, <span class="hljs-number">12</span>)</code></pre><h3 id="接口继承接口"><a href="#接口继承接口" class="headerlink" title="接口继承接口"></a>接口继承接口</h3><p>因为 接口是对对象的形状进行描述； 所以接口可以继承接口，</p><p>和类一样，接口也可以相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。</p><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Shape</span> &#123;  <span class="hljs-attr">color</span>: <span class="hljs-built_in">string</span>;&#125;<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Square</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Shape</span> &#123;  <span class="hljs-attr">sideLength</span>: <span class="hljs-built_in">number</span>;&#125;<span class="hljs-comment">// 类型断言</span><span class="hljs-comment">// let square = &lt;Square&gt;&#123;&#125;;</span><span class="hljs-keyword">let</span> square = &#123;&#125; <span class="hljs-keyword">as</span> <span class="hljs-title class_">Square</span>square.<span class="hljs-property">color</span> = <span class="hljs-string">&quot;blue&quot;</span>;square.<span class="hljs-property">sideLength</span> = <span class="hljs-number">10</span>;</code></pre><h3 id="混合类型"><a href="#混合类型" class="headerlink" title="混合类型"></a>混合类型</h3><p>函数类型的interface ，添加属性的方式来实现 对象的interface</p><p>相当于 函数类型的interface + 对象类型的 interface</p><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Counter</span> &#123;  (<span class="hljs-attr">start</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">string</span>;   <span class="hljs-comment">// 有点像构造函数</span>  <span class="hljs-attr">interval</span>: <span class="hljs-built_in">number</span>;  <span class="hljs-title function_">reset</span>(): <span class="hljs-built_in">void</span>;&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">getCounter</span>(<span class="hljs-params"></span>): <span class="hljs-title class_">Counter</span> &#123;  <span class="hljs-keyword">let</span> counter = &lt;<span class="hljs-title class_">Counter</span>&gt;<span class="hljs-keyword">function</span> (<span class="hljs-params">start: <span class="hljs-built_in">number</span></span>) &#123; &#125;;  <span class="hljs-comment">// 断言   可以理解为 给 counter 初始值</span>  counter.<span class="hljs-property">interval</span> = <span class="hljs-number">123</span>;  counter.<span class="hljs-property">reset</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; &#125;;  <span class="hljs-keyword">return</span> counter;&#125;<span class="hljs-keyword">let</span> c = <span class="hljs-title function_">getCounter</span>();<span class="hljs-title function_">c</span>(<span class="hljs-number">10</span>);c.<span class="hljs-title function_">reset</span>();c.<span class="hljs-property">interval</span> = <span class="hljs-number">5.0</span>;</code></pre><h3 id="接口继承类"><a href="#接口继承类" class="headerlink" title="接口继承类"></a>接口继承类</h3><ol><li>接口可以接触接口</li><li>接口可以继承类</li><li>类可以实现接口</li></ol><pre><code class="hljs ts"><span class="hljs-comment">//   定义 类</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Control</span> &#123;  <span class="hljs-keyword">private</span> <span class="hljs-attr">state</span>: <span class="hljs-built_in">any</span>;&#125;<span class="hljs-comment">//  接口继承类</span><span class="hljs-keyword">interface</span> <span class="hljs-title class_">SelectableControl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Control</span> &#123;  <span class="hljs-title function_">select</span>(): <span class="hljs-built_in">void</span>;&#125;<span class="hljs-comment">//   类继承类然后实现接口</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Button</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Control</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">SelectableControl</span> &#123;  <span class="hljs-title function_">select</span>(<span class="hljs-params"></span>) &#123; &#125;&#125;<span class="hljs-comment">//  类继承接口</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">TextBox</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Control</span> &#123;  <span class="hljs-title function_">select</span>(<span class="hljs-params"></span>) &#123; &#125;&#125;<span class="hljs-comment">// 错误：“Image”类型缺少“state”属性。</span><span class="hljs-comment">// class Images implements SelectableControl &#123;</span><span class="hljs-comment">//   select() &#123; &#125;</span><span class="hljs-comment">// &#125;</span></code></pre><p>最后，看了俩遍文档还是有点迷。。。。。 以后多练习练习</p>]]></content>
    
    
    <categories>
      
      <category>typescript</category>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>typescript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TypeScript 学习总结之 类</title>
    <link href="/2020/12/29/41.TypeScript%E7%B3%BB%E5%88%973/"/>
    <url>/2020/12/29/41.TypeScript%E7%B3%BB%E5%88%973/</url>
    
    <content type="html"><![CDATA[<p>​<br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/408cfbc308734bd8bcbb8a36c40135d0~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="TypeScript"></p><h2 id="类的注解方式"><a href="#类的注解方式" class="headerlink" title="类的注解方式"></a>类的注解方式</h2><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">theName: <span class="hljs-built_in">string</span></span>) &#123; <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = theName; &#125;  <span class="hljs-title function_">move</span>(<span class="hljs-params">distanceInMeters: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span> moved <span class="hljs-subst">$&#123;distanceInMeters&#125;</span>m.`</span>);  &#125;&#125;</code></pre><h3 id="继承中super"><a href="#继承中super" class="headerlink" title="继承中super"></a>继承中super</h3><p><strong>// 注意这个super， 如果在constructor内就是默认指 构造函数 。</strong></p><p><strong>// 如果在constructor外部（除了constructor），这个super 就是指的 父类 （Animal）。</strong></p><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Snake</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) &#123; <span class="hljs-variable language_">super</span>(name); &#125;  <span class="hljs-comment">// 这里的super  =&gt; constructor Animal(theName: string) : Animal</span>  <span class="hljs-title function_">move</span>(<span class="hljs-params">distanceInMeters = <span class="hljs-number">5</span></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Slithering...&quot;</span>);    <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">move</span>(distanceInMeters);  <span class="hljs-comment">// 这里的 super =&gt; 父类 Animal</span>  &#125;&#125;</code></pre><h2 id="类的修饰符"><a href="#类的修饰符" class="headerlink" title="类的修饰符"></a>类的修饰符</h2><blockquote><p>三大类成员修饰符: public / private  / protected</p></blockquote><h3 id="public"><a href="#public" class="headerlink" title="public"></a>public</h3><p>// 在TypeScript里，成员都默认为 public。</p><p>// 如果类默认不写, 就是public </p><p><strong>public : 公共成员属性</strong></p><ul><li>自身类可以调用</li><li>子类可以调用</li><li>实例可以调用</li></ul><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;  <span class="hljs-keyword">public</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;  <span class="hljs-keyword">public</span> <span class="hljs-title function_">constructor</span>(<span class="hljs-params">theName: <span class="hljs-built_in">string</span></span>) &#123; <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = theName; &#125;  <span class="hljs-keyword">public</span> <span class="hljs-title function_">move</span>(<span class="hljs-params">distanceInMeters: <span class="hljs-built_in">number</span></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span> moved <span class="hljs-subst">$&#123;distanceInMeters&#125;</span>m.`</span>);  &#125;&#125;</code></pre><h3 id="private"><a href="#private" class="headerlink" title="private"></a>private</h3><p>// private : 私有属性</p><ul><li>只能自身调用</li></ul><p>// 当我把 Animal 类中的 构造函数变成私有, 如下:</p><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;  <span class="hljs-keyword">public</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;  <span class="hljs-keyword">private</span> <span class="hljs-title function_">constructor</span>(<span class="hljs-params">theName: <span class="hljs-built_in">string</span></span>) &#123; <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = theName; &#125;  <span class="hljs-keyword">public</span> <span class="hljs-title function_">move</span>(<span class="hljs-params">distanceInMeters: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span> moved <span class="hljs-subst">$&#123;distanceInMeters&#125;</span>m.`</span>);  &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Snake</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) &#123; <span class="hljs-variable language_">super</span>(name); &#125;  <span class="hljs-title function_">move</span>(<span class="hljs-params">distanceInMeters = <span class="hljs-number">5</span></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Slithering...&quot;</span>);    <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">move</span>(distanceInMeters);  &#125;&#125;<span class="hljs-keyword">let</span> sam = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Snake</span>(<span class="hljs-string">&quot;Sammy the Python&quot;</span>);sam.<span class="hljs-title function_">move</span>();</code></pre><p>当我把 构造函数变成私有属性时, 编辑器会提示说  我子类(Snake)继承不了<br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13dfba4196e34680b9a27f352ae5cc92~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="private"></p><p>// 当我把 Animal 中的 move 方法设为 private 时, 会出现如下报错:<br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72ed13d2a70c4aa780b40af21f168732~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="private"></p><p><strong>因此 , 可证明  private  只能自身调用,  子类和实例不能调用.</strong></p><h3 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h3><blockquote><p>protected修饰符与 private修饰符的行为很相似，但有一点不同， protected成员在派生类中仍然可以访问。</p></blockquote><p>也就是说 protected 可以自身调用,也可以子类调用.</p><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;  <span class="hljs-keyword">public</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;  <span class="hljs-keyword">public</span> <span class="hljs-title function_">constructor</span>(<span class="hljs-params">theName: <span class="hljs-built_in">string</span></span>) &#123; <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = theName; &#125;  <span class="hljs-keyword">protected</span> <span class="hljs-title function_">move</span>(<span class="hljs-params">distanceInMeters: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span> moved <span class="hljs-subst">$&#123;distanceInMeters&#125;</span>m.`</span>);  &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Snake</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) &#123; <span class="hljs-variable language_">super</span>(name); &#125;  <span class="hljs-title function_">move</span>(<span class="hljs-params">distanceInMeters = <span class="hljs-number">5</span></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Slithering...&quot;</span>);    <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">move</span>(distanceInMeters);  &#125;&#125;<span class="hljs-keyword">let</span> jack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>(<span class="hljs-string">&#x27;jack&#x27;</span>)jack.<span class="hljs-title function_">move</span>()   <span class="hljs-comment">// 报错,</span></code></pre><p>这时,在编辑器上, 实例调用move方法会报错,<br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7baff8b10ad1472189dc44c3a19325ec~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="protected"> </p><h3 id="readonly-只读-修饰符"><a href="#readonly-只读-修饰符" class="headerlink" title="readonly(只读)修饰符"></a>readonly(只读)修饰符</h3><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Octopus</span> &#123;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;   <span class="hljs-comment">// readonly 要放在 public 这种访问属性修饰符 后面</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> <span class="hljs-attr">numberOfLegs</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">8</span>;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">theName: <span class="hljs-built_in">string</span></span>) &#123;       <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = theName;  &#125;  <span class="hljs-keyword">readonly</span> <span class="hljs-title function_">say</span>(<span class="hljs-params"></span>) &#123;   <span class="hljs-comment">// 错误 : 修饰符仅可出现在属性声明或索引签名中</span>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hi&#x27;</span>);  &#125;&#125;<span class="hljs-keyword">let</span> dad = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Octopus</span>(<span class="hljs-string">&quot;Man with the 8 strong legs&quot;</span>);dad.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Man with the 3-piece suit&quot;</span>; <span class="hljs-comment">// 错误! name 是只读的.</span></code></pre><p>readonly 注意事项:</p><ul><li><strong>顺序:  要放在 public/private/protected  之后</strong></li><li><strong>是否可写: 加上 readonly  表示 只读,不可写</strong></li><li><strong>不能修饰成员方法.</strong></li></ul><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5cb3ac948e30435391cd2b9cd516036b~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="readonly"></p><h3 id="参数属性"><a href="#参数属性" class="headerlink" title="参数属性"></a>参数属性</h3><blockquote><p>简写写法</p></blockquote><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal1</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> name: <span class="hljs-built_in">string</span></span>) &#123; &#125;  <span class="hljs-title function_">move</span>(<span class="hljs-params">distanceInMeters: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span> moved <span class="hljs-subst">$&#123;distanceInMeters&#125;</span>m.`</span>);  &#125;&#125;<span class="hljs-comment">// 等价于</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal2</span> &#123;  <span class="hljs-keyword">private</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) &#123; <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name &#125;  <span class="hljs-title function_">move</span>(<span class="hljs-params">distanceInMeters: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span> moved <span class="hljs-subst">$&#123;distanceInMeters&#125;</span>m.`</span>);  &#125;&#125;</code></pre><h3 id="存取器"><a href="#存取器" class="headerlink" title="存取器"></a>存取器</h3><blockquote><p>大概看了一下,  其实就是 getter 和 setter</p></blockquote><pre><code class="hljs ts"><span class="hljs-keyword">let</span> passcode = <span class="hljs-string">&quot;secret passcode&quot;</span>;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span> &#123;  <span class="hljs-keyword">private</span> <span class="hljs-attr">_fullName</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;jack&#x27;</span>;  <span class="hljs-keyword">get</span> <span class="hljs-title function_">fullName</span>(): <span class="hljs-built_in">string</span> &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_fullName</span>;  &#125;  <span class="hljs-keyword">set</span> <span class="hljs-title function_">fullName</span>(<span class="hljs-params">newName: <span class="hljs-built_in">string</span></span>) &#123;    <span class="hljs-keyword">if</span> (passcode &amp;&amp; passcode == <span class="hljs-string">&quot;secret passcode&quot;</span>) &#123;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">_fullName</span> = newName;    &#125;    <span class="hljs-keyword">else</span> &#123;      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Error: Unauthorized update of employee!&quot;</span>);    &#125;  &#125;&#125;<span class="hljs-keyword">let</span> employee = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>();<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(employee.<span class="hljs-property">fullName</span>);  <span class="hljs-comment">// jack</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(employee.<span class="hljs-property">fullName</span> = <span class="hljs-string">&#x27;new jack&#x27;</span>);  <span class="hljs-comment">// new jack</span></code></pre><h3 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h3><blockquote><p>这个也是 不属于 TS 新有的知识,   学到这里,我发现其实我们大都是还是在复习JS, 要学好TS前提是JS基础一定要好啊</p></blockquote><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Grid</span> &#123;    <span class="hljs-keyword">static</span> origin = &#123;<span class="hljs-attr">x</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">0</span>&#125;;    <span class="hljs-title function_">calculateDistanceFromOrigin</span>(<span class="hljs-params">point: &#123;x: <span class="hljs-built_in">number</span>; y: <span class="hljs-built_in">number</span>;&#125;</span>) &#123;        <span class="hljs-keyword">let</span> xDist = (point.<span class="hljs-property">x</span> - <span class="hljs-title class_">Grid</span>.<span class="hljs-property">origin</span>.<span class="hljs-property">x</span>);        <span class="hljs-keyword">let</span> yDist = (point.<span class="hljs-property">y</span> - <span class="hljs-title class_">Grid</span>.<span class="hljs-property">origin</span>.<span class="hljs-property">y</span>);        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sqrt</span>(xDist * xDist + yDist * yDist) / <span class="hljs-variable language_">this</span>.<span class="hljs-property">scale</span>;    &#125;    <span class="hljs-title function_">constructor</span> (<span class="hljs-keyword">public</span> <span class="hljs-attr">scale</span>: <span class="hljs-built_in">number</span>) &#123; &#125;&#125;<span class="hljs-keyword">let</span> grid1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Grid</span>(<span class="hljs-number">1.0</span>);  <span class="hljs-comment">// 1x scale</span><span class="hljs-keyword">let</span> grid2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Grid</span>(<span class="hljs-number">5.0</span>);  <span class="hljs-comment">// 5x scale</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(grid1.<span class="hljs-title function_">calculateDistanceFromOrigin</span>(&#123;<span class="hljs-attr">x</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">10</span>&#125;));<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(grid2.<span class="hljs-title function_">calculateDistanceFromOrigin</span>(&#123;<span class="hljs-attr">x</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">10</span>&#125;));</code></pre><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><blockquote><p>抽象类: 能够提供其他类的基类  , 它们一般不会直接被实例化</p></blockquote><p>抽象类:</p><ol><li>无法创建实例</li><li>在抽象类中 抽象方法一定要实现  (这一点和接口很像)</li></ol><pre><code class="hljs ts"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;  <span class="hljs-keyword">abstract</span> <span class="hljs-title function_">makeSound</span>(): <span class="hljs-built_in">void</span>;  <span class="hljs-title function_">move</span>(): <span class="hljs-built_in">void</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我在移动&#x27;</span>);  &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span> &#123;  <span class="hljs-title function_">makeSound</span>(<span class="hljs-params"></span>) &#123;   <span class="hljs-comment">// 一定要去定义这个方法，  因为抽象类中包含这个抽象方法</span>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;汪汪汪&#x27;</span>);  &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span> &#123;  <span class="hljs-title function_">makeSound</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;喵喵喵&#x27;</span>);  &#125;&#125;</code></pre><h3 id="高阶技巧"><a href="#高阶技巧" class="headerlink" title="高阶技巧"></a>高阶技巧</h3><ol><li>定义类的时候, 定义了一个类型;</li><li>定义类的时候, 定义了一个构造函数;</li></ol><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Greeter</span> &#123;  <span class="hljs-keyword">static</span> standardGreeting = <span class="hljs-string">&quot;Hello, there&quot;</span>;  <span class="hljs-comment">// 静态属性</span>  <span class="hljs-attr">greeting</span>: <span class="hljs-built_in">string</span>;  <span class="hljs-title function_">greet</span>(<span class="hljs-params"></span>) &#123;      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">greeting</span>) &#123;          <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello, &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">greeting</span>;      &#125;      <span class="hljs-keyword">else</span> &#123;          <span class="hljs-keyword">return</span> <span class="hljs-title class_">Greeter</span>.<span class="hljs-property">standardGreeting</span>;      &#125;  &#125;&#125;<span class="hljs-keyword">let</span> <span class="hljs-attr">greeter1</span>: <span class="hljs-title class_">Greeter</span>;   <span class="hljs-comment">// 定义类型</span>greeter1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Greeter</span>();   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(greeter1.<span class="hljs-title function_">greet</span>());<span class="hljs-keyword">let</span> <span class="hljs-attr">greeterMaker</span>: <span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Greeter</span> = <span class="hljs-title class_">Greeter</span>;    <span class="hljs-comment">// 定义类型</span>greeterMaker.<span class="hljs-property">standardGreeting</span> = <span class="hljs-string">&quot;Hey there!&quot;</span>;  <span class="hljs-keyword">let</span> <span class="hljs-attr">greeter2</span>: <span class="hljs-title class_">Greeter</span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_">greeterMaker</span>();  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(greeter2.<span class="hljs-title function_">greet</span>());</code></pre><ol start="3"><li>把类当做接口使用</li></ol><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123;    <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;    <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>;&#125;<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Point3</span>d <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Point</span> &#123;    <span class="hljs-attr">z</span>: <span class="hljs-built_in">number</span>;&#125;<span class="hljs-keyword">let</span> <span class="hljs-attr">point3d</span>: <span class="hljs-title class_">Point3</span>d = &#123;<span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">z</span>: <span class="hljs-number">3</span>&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>typescript</category>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>typescript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TypeScript学习总结之函数</title>
    <link href="/2020/12/27/40.TypeScript%E7%B3%BB%E5%88%972/"/>
    <url>/2020/12/27/40.TypeScript%E7%B3%BB%E5%88%972/</url>
    
    <content type="html"><![CDATA[<p>​<br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/408cfbc308734bd8bcbb8a36c40135d0~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="TypeScript"></p><h2 id="函数的注解方式"><a href="#函数的注解方式" class="headerlink" title="函数的注解方式"></a>函数的注解方式</h2><h3 id="函数声明的注解方式"><a href="#函数声明的注解方式" class="headerlink" title="函数声明的注解方式"></a>函数声明的注解方式</h3><blockquote><p>注解 参数和返回值</p></blockquote><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> &#123;  <span class="hljs-keyword">return</span> a + b&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">test1</span>(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">void</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a + b);&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">test2</span>(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">never</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a + b);  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>()&#125;</code></pre><h3 id="函数表达式的注解方式"><a href="#函数表达式的注解方式" class="headerlink" title="函数表达式的注解方式"></a>函数表达式的注解方式</h3><p>// 不用给 function 后边写注解， 因为会根据前边的注解来做类型推断</p><pre><code class="hljs ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">test</span>: <span class="hljs-function">(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">number</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) &#123;  <span class="hljs-keyword">return</span> a + b&#125;<span class="hljs-keyword">let</span> <span class="hljs-attr">test1</span>: <span class="hljs-function">(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">void</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a + b);&#125;<span class="hljs-keyword">let</span> <span class="hljs-attr">test2</span>: <span class="hljs-function">(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">never</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a + b);  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>()&#125;</code></pre><h3 id="可选参数和默认参数"><a href="#可选参数和默认参数" class="headerlink" title="可选参数和默认参数"></a>可选参数和默认参数</h3><p><strong>// 默认：传递给一个函数的参数个数必须与函数期望的参数个数一致。</strong></p><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">buildName</span>(<span class="hljs-params">firstName: <span class="hljs-built_in">string</span>, lastName: <span class="hljs-built_in">string</span></span>) &#123;  <span class="hljs-keyword">return</span> firstName + <span class="hljs-string">&quot; &quot;</span> + lastName;&#125;<span class="hljs-keyword">let</span> result1 = <span class="hljs-title function_">buildName</span>(<span class="hljs-string">&quot;Bob&quot;</span>);          <span class="hljs-comment">// 少一个参数        // error, too few parameters</span><span class="hljs-keyword">let</span> result2 = <span class="hljs-title function_">buildName</span>(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;Adams&quot;</span>, <span class="hljs-string">&quot;Sr.&quot;</span>);  <span class="hljs-comment">// 多一个参数  // error, too many parameters</span><span class="hljs-keyword">let</span> result3 = <span class="hljs-title function_">buildName</span>(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;Adams&quot;</span>);         <span class="hljs-comment">// ah, just right</span></code></pre><h4 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h4><p><strong>// 注意：可选参数必须要放在必选参数的后边，否则会报错。</strong></p><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">buildName</span>(<span class="hljs-params">firstName: <span class="hljs-built_in">string</span>, lastName?: <span class="hljs-built_in">string</span></span>) &#123;  <span class="hljs-keyword">if</span> (lastName)      <span class="hljs-keyword">return</span> firstName + <span class="hljs-string">&quot; &quot;</span> + lastName;  <span class="hljs-keyword">else</span>      <span class="hljs-keyword">return</span> firstName;&#125;<span class="hljs-keyword">let</span> result1 = <span class="hljs-title function_">buildName</span>(<span class="hljs-string">&quot;Bob&quot;</span>);  <span class="hljs-comment">// is OK</span><span class="hljs-keyword">let</span> result2 = <span class="hljs-title function_">buildName</span>(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;Adams&quot;</span>, <span class="hljs-string">&quot;Sr.&quot;</span>);  <span class="hljs-comment">// 错误，多个一参数</span><span class="hljs-keyword">let</span> result3 = <span class="hljs-title function_">buildName</span>(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;Adams&quot;</span>);  <span class="hljs-comment">//  is OK</span></code></pre><h4 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h4><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">buildName</span>(<span class="hljs-params">firstName: <span class="hljs-built_in">string</span>, lastName = <span class="hljs-string">&quot;Smith&quot;</span></span>) &#123;  <span class="hljs-keyword">return</span> firstName + <span class="hljs-string">&quot; &quot;</span> + lastName;&#125;<span class="hljs-keyword">let</span> result1 = <span class="hljs-title function_">buildName</span>(<span class="hljs-string">&quot;Bob&quot;</span>);                  <span class="hljs-comment">// works correctly now, returns &quot;Bob Smith&quot;</span><span class="hljs-keyword">let</span> result2 = <span class="hljs-title function_">buildName</span>(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-literal">undefined</span>);       <span class="hljs-comment">// still works, also returns &quot;Bob Smith&quot;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result1, result2);  <span class="hljs-comment">//  Bob Smith Bob Smith</span></code></pre><h4 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h4><p><strong>// …restOfName: string[] 一定要放在最后边，和ES6的扩展运算符一样</strong></p><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">buildName</span>(<span class="hljs-params">firstName: <span class="hljs-built_in">string</span>, lastName = <span class="hljs-string">&#x27;Smith&#x27;</span>, ...restOfName: <span class="hljs-built_in">string</span>[]</span>) &#123;  <span class="hljs-keyword">return</span> firstName + <span class="hljs-string">&quot; &quot;</span> + lastName + restOfName.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot; &quot;</span>);&#125;<span class="hljs-keyword">let</span> employeeName = <span class="hljs-title function_">buildName</span>(<span class="hljs-string">&quot;Joseph&quot;</span>, <span class="hljs-string">&quot;Samuel&quot;</span>, <span class="hljs-string">&quot;Lucas&quot;</span>);</code></pre><h4 id="解构赋值在TS中的使用"><a href="#解构赋值在TS中的使用" class="headerlink" title="解构赋值在TS中的使用"></a>解构赋值在TS中的使用</h4><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span><span class="hljs-params">  &#123; a, b &#125;: &#123; a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">number</span> &#125; = &#123; a: <span class="hljs-number">1</span>, b: <span class="hljs-number">2</span> &#125;</span><span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">return</span> a + b&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">test</span>());  <span class="hljs-comment">//  3</span></code></pre><h3 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h3><p>有时候我我们需要在函数中使用this来去指定那个示例对象, TS提供俩种方式</p><p><strong>方式一： 使用箭头函数 + 配置noImplicitThis = true (不配置 this是any)</strong></p><pre><code class="hljs ts"><span class="hljs-keyword">let</span> deck = &#123;  <span class="hljs-attr">suits</span>: [<span class="hljs-string">&quot;hearts&quot;</span>, <span class="hljs-string">&quot;spades&quot;</span>, <span class="hljs-string">&quot;clubs&quot;</span>, <span class="hljs-string">&quot;diamonds&quot;</span>],  <span class="hljs-attr">cards</span>: <span class="hljs-title class_">Array</span>(<span class="hljs-number">52</span>),  <span class="hljs-attr">createCardPicker</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;      <span class="hljs-keyword">let</span> pickedCard = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">52</span>);      <span class="hljs-keyword">let</span> pickedSuit = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(pickedCard / <span class="hljs-number">13</span>);      <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">suit</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">suits</span>[pickedSuit], <span class="hljs-attr">card</span>: pickedCard % <span class="hljs-number">13</span> &#125;;    &#125;  &#125;&#125;<span class="hljs-keyword">let</span> cardPicker = deck.<span class="hljs-title function_">createCardPicker</span>();<span class="hljs-keyword">let</span> pickedCard = <span class="hljs-title function_">cardPicker</span>();<span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;card: &quot;</span> + pickedCard.<span class="hljs-property">card</span> + <span class="hljs-string">&quot; of &quot;</span> + pickedCard.<span class="hljs-property">suit</span>);</code></pre><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/765e95cadcb24e5486c3d171087d1fc0~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="this"></p><p><strong>方式二：使用 interface</strong></p><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Card</span> &#123;  <span class="hljs-attr">suit</span>: <span class="hljs-built_in">string</span>  <span class="hljs-attr">card</span>: <span class="hljs-built_in">number</span>&#125;<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Deck</span> &#123;  <span class="hljs-attr">suits</span>: <span class="hljs-built_in">string</span>[]  <span class="hljs-attr">cards</span>: <span class="hljs-built_in">number</span>[]  <span class="hljs-title function_">createCardPicker</span>(<span class="hljs-attr">this</span>: <span class="hljs-title class_">Deck</span>): <span class="hljs-function">() =&gt;</span> <span class="hljs-title class_">Card</span>&#125;<span class="hljs-keyword">let</span> <span class="hljs-attr">deck</span>: <span class="hljs-title class_">Deck</span> = &#123;   <span class="hljs-attr">suits</span>: [<span class="hljs-string">&quot;hearts&quot;</span>, <span class="hljs-string">&quot;spades&quot;</span>, <span class="hljs-string">&quot;clubs&quot;</span>, <span class="hljs-string">&quot;diamonds&quot;</span>],  <span class="hljs-attr">cards</span>: <span class="hljs-title class_">Array</span>(<span class="hljs-number">52</span>),  <span class="hljs-attr">createCardPicker</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;      <span class="hljs-keyword">let</span> pickedCard = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">52</span>);      <span class="hljs-keyword">let</span> pickedSuit = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(pickedCard / <span class="hljs-number">13</span>);      <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">suit</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">suits</span>[pickedSuit], <span class="hljs-attr">card</span>: pickedCard % <span class="hljs-number">13</span> &#125;;    &#125;  &#125;&#125;<span class="hljs-keyword">let</span> cardPicker = deck.<span class="hljs-title function_">createCardPicker</span>();<span class="hljs-keyword">let</span> pickedCard = <span class="hljs-title function_">cardPicker</span>();<span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;card: &quot;</span> + pickedCard.<span class="hljs-property">card</span> + <span class="hljs-string">&quot; of &quot;</span> + pickedCard.<span class="hljs-property">suit</span>);</code></pre><p>这样 this 就会指向 Deck</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f923f0409cc48988fc79821dc1b35f7~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="this指向"></p><h3 id="函数的重载"><a href="#函数的重载" class="headerlink" title="函数的重载"></a>函数的重载</h3><p>// 官网的例子太麻烦了， 我以 翻转字符串或者数字来举例</p><pre><code class="hljs ts"><span class="hljs-comment">// 翻转 字符串或者数字</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">reverse</span>(<span class="hljs-params">foo: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">string</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">reverse</span>(<span class="hljs-params">foo: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">reverse</span>(<span class="hljs-params">foo: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span></span>) &#123;  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> foo === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;    <span class="hljs-keyword">return</span> foo.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;&#x27;</span>).<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;&#x27;</span>)  &#125;  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> foo === <span class="hljs-string">&#x27;number&#x27;</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Number</span>(foo.<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;&#x27;</span>).<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;&#x27;</span>))  &#125;&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">reverse</span>(‘<span class="hljs-number">123456</span>’));  <span class="hljs-comment">// 字符串类型的 &#x27;654321&#x27;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">reverse</span>(<span class="hljs-number">123456</span>));  <span class="hljs-comment">// 数字类型的 654321</span></code></pre><p>看着是不是好像没什么太大的区别?</p><p><strong>// 其实 typescript 重载的意义在于 表意更清楚</strong></p>]]></content>
    
    
    <categories>
      
      <category>typescript</category>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>typescript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TypeScript学习总结之基础类型</title>
    <link href="/2020/12/26/39.TypeScript%E7%B3%BB%E5%88%971/"/>
    <url>/2020/12/26/39.TypeScript%E7%B3%BB%E5%88%971/</url>
    
    <content type="html"><![CDATA[<p>​<br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/408cfbc308734bd8bcbb8a36c40135d0~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="TypeScript"></p><h2 id="对TypeScript-的认识"><a href="#对TypeScript-的认识" class="headerlink" title="对TypeScript 的认识"></a>对TypeScript 的认识</h2><p>TypeScript  是什么？</p><ol><li><p>TypeScript  是 JavaScript类型的超集，它可以编译纯JavaScript  ， 是由 微软开发的开源的编程语言。</p></li><li><p>TypeScript  可以在任何浏览器，任何计算机和任何操作系统上运行。</p></li><li><p>TypeScript  是开发大型应用的基石。</p></li><li><p>TypeScript   提供了更丰富的语法提示，  在编写阶段能够检查错误。</p></li></ol><p>  <strong>与JavaScript的区别</strong></p><p>TypeScript   是静态类型， JavaScript是动态类型</p><ol><li>在TypeScript   中 类型是确定好的。（一旦给类型赋值后就不能更改其类型）</li></ol><h3 id="TypeScript-数据类型"><a href="#TypeScript-数据类型" class="headerlink" title="TypeScript 数据类型"></a>TypeScript 数据类型</h3><blockquote><p>为了让程序有价值，我们需要能够处理最简单的数据单元：数字，字符串，结构体，布尔值等。 TypeScript支持与JavaScript几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用。</p></blockquote><h4 id="JavaScript-的基本数据类型："><a href="#JavaScript-的基本数据类型：" class="headerlink" title="JavaScript 的基本数据类型："></a>JavaScript 的基本数据类型：</h4><p>原始数据类型：string、number、boolean、null、undefined、symbol</p><p>引用数据类型：object</p><p>TypeScript 的基本数据类型：</p><p>包含JavaScript所有的基本数据之外，额外新增了几种新的数据类型（大概的写一下）：</p><ol><li>any(任意类型)、</li><li>never （<code>never</code>类型表示的是那些永不存在的值的类型） 、 </li><li>void（<code>void</code>类型像是与<code>any</code>类型相反、只能为它赋予<code>undefined</code>和<code>null</code>）</li><li>针对于对象类型的： interface</li><li>针对于数组的：number[] 、string[] 、boolean[] 等， 泛型的写法：Array&lt;元素类型&gt; (Array<number>) </li><li>函数的注解</li></ol><h4 id="TypeScript-原始数据的注解"><a href="#TypeScript-原始数据的注解" class="headerlink" title="TypeScript 原始数据的注解"></a>TypeScript 原始数据的注解</h4><h5 id="布尔值的注解-："><a href="#布尔值的注解-：" class="headerlink" title="布尔值的注解  ："></a>布尔值的注解  ：</h5><pre><code class="hljs ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">isDone</span>: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">false</span>;</code></pre><p>//注意boolean 首字母不能大写，</p><p>注解：Boolean 指的是如下：<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/12c8d64a47724d5ca52e85bcaaae69b2~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="Boolean"></p><h5 id="数字的注解："><a href="#数字的注解：" class="headerlink" title="数字的注解："></a>数字的注解：</h5><pre><code class="hljs ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">decLiteral</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">6</span>;</code></pre><h5 id="字符串的注解："><a href="#字符串的注解：" class="headerlink" title="字符串的注解："></a>字符串的注解：</h5><pre><code class="hljs ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">myName</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;bob&quot;</span>;myName = <span class="hljs-string">&quot;smith&quot;</span>;<span class="hljs-keyword">let</span> <span class="hljs-attr">sentence</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">`Hello, my name is <span class="hljs-subst">$&#123; myName &#125;</span>.</span></code></pre><p>// 注意这点不能用 name来命名</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/167bcf4d02ac47d0ad6f0066a8432024~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="不能name来命名"></p><h5 id="any-数据类型：-任意数据类型；"><a href="#any-数据类型：-任意数据类型；" class="headerlink" title="any 数据类型： 任意数据类型；"></a>any 数据类型： 任意数据类型；</h5><ol><li><p><strong>如果是不同变量的话，可以是任意的数据类型</strong></p><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">notSure</span>: <span class="hljs-built_in">any</span> = <span class="hljs-number">4</span>;notSure = <span class="hljs-string">&quot;maybe a string instead&quot;</span>;notSure = <span class="hljs-literal">false</span>; <span class="hljs-comment">// okay, definitely a boolean</span></code></pre></li><li><p><strong>如果是对象的话， any 是不能够提示原型上的共有属性和方法的。</strong></p>  <pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">notSure</span>: <span class="hljs-built_in">any</span> = <span class="hljs-number">4</span>;notSure.<span class="hljs-title function_">ifItExists</span>(); <span class="hljs-comment">// okay, ifItExists might exist at runtime</span>notSure.<span class="hljs-title function_">toFixed</span>(); <span class="hljs-comment">// okay, toFixed exists (but the compiler doesn&#x27;t check)</span></code></pre><p>  相反，如果是 Object的话，它就会提示使用Object类型上的属性</p>  <pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">prettySure</span>: <span class="hljs-title class_">Object</span> = <span class="hljs-number">4</span>;prettySure.<span class="hljs-title function_">toFixed</span>(); <span class="hljs-comment">// Error: Property &#x27;toFixed&#x27; doesn&#x27;t exist on type &#x27;Object&#x27;.</span>prettySure.<span class="hljs-title function_">toString</span>()  <span class="hljs-comment">// OK</span></code></pre><p>  如下图<br>  <img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/84e70431681d4d4b94cd4e3a2ca04ee7~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif"></p></li><li><p><strong>未给初始值的变量类型 为 any 类型</strong></p> <pre><code class="hljs ts"><span class="hljs-keyword">let</span> aa = <span class="hljs-string">&#x27;123&#x27;</span>a = <span class="hljs-number">123</span></code></pre><p>  <img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f571820298be45b88dffb6c0602f0e86~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt=" any 类型"></p><h5 id="void"><a href="#void" class="headerlink" title="void"></a>void</h5></li></ol><blockquote><p> void<code>类型像是与</code>any<code>类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 </code>void</p></blockquote><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">warnUser</span>(<span class="hljs-params"></span>): <span class="hljs-built_in">void</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;This is my warning message&quot;</span>);  <span class="hljs-comment">//相当于 return undefined  </span>&#125;</code></pre><h5 id="null-amp-undefined"><a href="#null-amp-undefined" class="headerlink" title="null &amp; undefined"></a>null &amp; undefined</h5><blockquote><p> 默认情况下null和undefined是所有类型的子类型</p></blockquote><p>在tsconfig.json 中配置 strictNullChecks = false 时，<br>就可证明null和undefined是所有类型的子类型 </p><pre><code class="hljs ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">u</span>: <span class="hljs-built_in">number</span> = <span class="hljs-literal">undefined</span>;  <span class="hljs-comment">// strictNullChecks = false 时， 不报错</span></code></pre><blockquote><p>但官方建议让我们 strictNullChecks = true ，但在配置中这个标记是关闭的。</p></blockquote><h5 id="Never"><a href="#Never" class="headerlink" title="Never"></a>Never</h5><p> <code>never</code>类型表示的是那些永不存在的值的类型, 例如， <code>never</code>类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 <code>never</code>类型，当它们被永不为真的类型保护所约束时。</p><p> （目前我接触的这种实际情景不多，以后遇到了我再去单独了解）</p><h5 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h5><p> object表示非原始类型，也就是除number，string，boolean，symbol，null或undefined之外的类型。</p><pre><code class="hljs ts"><span class="hljs-keyword">declare</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">create</span>(<span class="hljs-params">o: <span class="hljs-built_in">object</span> | <span class="hljs-literal">null</span></span>): <span class="hljs-built_in">void</span>;<span class="hljs-title function_">create</span>(&#123; <span class="hljs-attr">prop</span>: <span class="hljs-number">0</span> &#125;); <span class="hljs-comment">// OK</span><span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>); <span class="hljs-comment">// OK</span><span class="hljs-title function_">create</span>(<span class="hljs-number">42</span>); <span class="hljs-comment">// Error</span><span class="hljs-title function_">create</span>(<span class="hljs-string">&quot;string&quot;</span>); <span class="hljs-comment">// Error</span><span class="hljs-title function_">create</span>(<span class="hljs-literal">false</span>); <span class="hljs-comment">// Error</span><span class="hljs-title function_">create</span>(<span class="hljs-literal">undefined</span>); <span class="hljs-comment">// Error</span></code></pre><p>以上是官网的例子， 上面代码说明了 object 不能是去使用 原始类型 ， 比如<code>create(function()&#123;&#125;)</code>、 <code>create([])</code> 这些是可以OK的。</p><h3 id="类型注解-amp-类型推论-amp-联合类型"><a href="#类型注解-amp-类型推论-amp-联合类型" class="headerlink" title="类型注解 &amp; 类型推论 &amp; 联合类型"></a>类型注解 &amp; 类型推论 &amp; 联合类型</h3><p>在我们定义变量时，而这个变量是原始数据，那么，我们不需要对它进行类型注解，它也能推论出该变量属于什么类型的。  </p><p>如下图： 类型推论</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/39eec58dbd7a44658964fc4fb0ceec41~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="类型推论"></p><p><strong>所以正常情况下，能够做出类型推论的话，我们专门去对它注解，会显得有些繁琐了。</strong></p><p>但是肯定有别的情况需要我们去做类型注解，</p><p>比如：当我们定义一个方式， 它会提示我们去进行类型注解</p><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">a, b</span>) &#123;  <span class="hljs-comment">// 在编辑器中会提示你要做类型注解</span>  <span class="hljs-keyword">return</span> a + b&#125; <span class="hljs-title function_">test</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)</code></pre><p>做类型注解：</p><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">a:<span class="hljs-built_in">number</span>, b:<span class="hljs-built_in">number</span></span>) &#123;  <span class="hljs-keyword">return</span> a + b&#125; <span class="hljs-title function_">test</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)</code></pre><p><strong>联合类型：</strong>  多个类型当中，我们可以选择其中类型的一种</p><pre><code class="hljs ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">union</span>: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>union= <span class="hljs-string">&#x27;123&#x27;</span>  <span class="hljs-comment">// is OK</span>union= <span class="hljs-number">123</span>    <span class="hljs-comment">// is OK</span></code></pre><p>而当我们去定义一个函数时：</p><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">a: <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span></span>) &#123;  <span class="hljs-keyword">return</span> a.<span class="hljs-title function_">toString</span>()   <span class="hljs-comment">// 共有属性， OK</span>  <span class="hljs-comment">//  return  a.split()  // 这个是 String 独有的属性，不能联合起来使用</span>&#125;<span class="hljs-title function_">test</span>(<span class="hljs-number">1</span>)</code></pre><p>因此，我们要注意，</p><ol><li><p>联合类型的共有属性不会报错， </p><p>但不要用 联合类型中其中一种类型的独有属性 比如 String 中的 split 方法， Number是没有此属性的， 因此会报错   </p></li><li><p>在赋值的时候要确认类型</p></li></ol><h3 id="初识-interface"><a href="#初识-interface" class="headerlink" title="初识 interface"></a>初识 interface</h3><blockquote><p>接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。</p></blockquote><ol><li>对对象的形状进行描述；</li><li>对类的一部分行为的抽象；</li></ol><p>简单使用：(对 对象的形状进行描述)</p><p><strong>// interface默认不能多属性也不能少属性</strong></p><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> &#123;  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>&#125;<span class="hljs-keyword">let</span> <span class="hljs-attr">preson</span>: <span class="hljs-title class_">Person</span> = &#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;wpf&#x27;</span>,  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>&#125;</code></pre><ul><li><strong>可选属性：如果偏偏少属性呢？  就在属性后边加<code>?</code>即可。 如果想多属性呢，</strong></li><li><strong>任意/多选 属性<code>[propName:string]:any</code></strong></li><li><strong>只读属性: <code>readonly</code>后面加属性</strong><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> &#123;   <span class="hljs-keyword">readonly</span> <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span>,    <span class="hljs-comment">// 只读属性</span>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>  age?: <span class="hljs-built_in">number</span>  <span class="hljs-comment">// 可选属性</span>  [<span class="hljs-attr">propName</span>:<span class="hljs-built_in">string</span>]:<span class="hljs-built_in">any</span>   <span class="hljs-comment">// 任意属性</span>&#125;<span class="hljs-keyword">let</span> <span class="hljs-attr">preson</span>: <span class="hljs-title class_">Person</span> = &#123;  <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>,  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;wpf&#x27;</span>,  <span class="hljs-attr">male</span>: <span class="hljs-string">&#x27;男&#x27;</span>&#125;</code></pre></li></ul><h3 id="数组注解"><a href="#数组注解" class="headerlink" title="数组注解"></a>数组注解</h3><p>定义数组的方式有三种：</p><ol><li>类型[]   如： number[] </li><li>数组泛型  Array&lt;类型&gt;  如： Array<number></li><li>interface 方式</li></ol><p><strong>类型[]</strong></p><pre><code class="hljs ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">list</span>: <span class="hljs-built_in">number</span>[] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];  <span class="hljs-comment">// 默认不写，会类型推论 推出来</span><span class="hljs-keyword">let</span> <span class="hljs-attr">list1</span>: (<span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>)[] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;1&#x27;</span>]  <span class="hljs-comment">// 联合类型</span></code></pre><p><strong>Array&lt;类型&gt;</strong></p><pre><code class="hljs ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">list</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">number</span>&gt; = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];</code></pre><p><strong>interface 方式</strong></p><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">List</span> &#123;  [<span class="hljs-attr">index</span>: <span class="hljs-built_in">number</span>]: <span class="hljs-built_in">number</span>&#125;<span class="hljs-keyword">let</span> <span class="hljs-attr">list</span>: <span class="hljs-title class_">List</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]</code></pre><pre><code class="hljs ts"><span class="hljs-comment">// 联合类型</span><span class="hljs-keyword">interface</span> <span class="hljs-title class_">List</span> &#123;  [<span class="hljs-attr">index</span>: <span class="hljs-built_in">number</span>]: <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span>&#125;<span class="hljs-keyword">let</span> <span class="hljs-attr">list</span>: <span class="hljs-title class_">List</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-string">&#x27;6&#x27;</span>]</code></pre><p><strong>类数组</strong></p><p>// args 就是个类数组</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd2eaf920d594d9f8cadcb5b680bf873~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="类数组"></p>]]></content>
    
    
    <categories>
      
      <category>typescript</category>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>typescript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>node.js中使用nodemailer插件发送邮件 (学习总结)</title>
    <link href="/2020/12/21/38.nodejs%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81/"/>
    <url>/2020/12/21/38.nodejs%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81/</url>
    
    <content type="html"><![CDATA[<p>​## 前言</p><blockquote><p>在做毕业设计时， 我需要在注册时 有一个给用户发送邮件的功能的需求。</p></blockquote><h2 id="需要设置smtp服务"><a href="#需要设置smtp服务" class="headerlink" title="需要设置smtp服务"></a>需要设置smtp服务</h2><p>我以QQ邮箱举例：<br>在 <strong>设置 -&gt; 账户</strong> 找到 <strong>POP3/IMAP/SMTP/Exchange/CardDAV/CalDAV服务</strong><br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b22d89de9c0a49ab8edd101dc4bff089~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="开启SMTP服务"></p><p><strong>一定要记住你的授权码，待会会用到。</strong></p><h2 id="node-引入-nodemailer"><a href="#node-引入-nodemailer" class="headerlink" title="node 引入 nodemailer"></a>node 引入 nodemailer</h2><p><strong>首先 ，你需要下载这个插件</strong></p><pre><code class="hljs bash">$ npm install nodemailer --save</code></pre><p><strong>配置 nodemailer</strong></p><pre><code class="hljs js"><span class="hljs-comment">// 引用发送邮件插件</span><span class="hljs-keyword">const</span> nodeMailer = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;nodemailer&#x27;</span>)<span class="hljs-comment">// 引入证书文件  (获取我的授权码和qq邮箱民)</span><span class="hljs-keyword">const</span> credential = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;../config/credentials&#x27;</span>)<span class="hljs-comment">// 创建传输方式</span><span class="hljs-keyword">const</span> transporter = nodeMailer.<span class="hljs-title function_">createTransport</span>(&#123;  <span class="hljs-attr">service</span>: <span class="hljs-string">&#x27;qq&#x27;</span>,  <span class="hljs-attr">auth</span>: &#123;    <span class="hljs-attr">user</span>: credential.<span class="hljs-property">qq</span>.<span class="hljs-property">user</span>,      <span class="hljs-attr">pass</span>: credential.<span class="hljs-property">qq</span>.<span class="hljs-property">pass</span>   <span class="hljs-comment">// 这个需要你的授权码！！！</span>  &#125;&#125;)<span class="hljs-comment">// 注册发送邮件给用户</span><span class="hljs-built_in">exports</span>.<span class="hljs-property">emailSignUp</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">email, res</span>) &#123;  <span class="hljs-comment">// 发送信息的内容</span>  <span class="hljs-keyword">let</span> options = &#123;    <span class="hljs-attr">from</span>: <span class="hljs-string">&#x27;xxxxxxx@qq.com&#x27;</span>,  <span class="hljs-comment">// 这里是你开启SMTP服务的QQ邮箱号</span>    <span class="hljs-attr">to</span>: email,  <span class="hljs-comment">// 这个是前端注册页面输入的邮箱号</span>    <span class="hljs-attr">subject</span>: <span class="hljs-string">&#x27;感谢您在xxxx注册&#x27;</span>,    <span class="hljs-attr">html</span>: <span class="hljs-string">`&lt;span&gt;xxxx欢迎您的加入！&lt;/span&gt;</span><span class="hljs-string">           &lt;a href=&quot;http://localhost:8080/&quot;&gt;点击&lt;/a&gt;`</span>  &#125;  <span class="hljs-comment">// 发送邮件</span>  transporter.<span class="hljs-title function_">sendMail</span>(options, <span class="hljs-keyword">function</span> (<span class="hljs-params">err, msg</span>) &#123;    <span class="hljs-keyword">if</span> (err) &#123;      res.<span class="hljs-title function_">send</span>(err)      <span class="hljs-comment">// console.log(err)</span>    &#125; <span class="hljs-keyword">else</span> &#123;      res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;邮箱发送成功!&#x27;</span>)      <span class="hljs-comment">// console.log(&#x27;邮箱发送成功&#x27;)</span>    &#125;  &#125;)&#125;</code></pre><p><strong>比如我访问/email就获取</strong></p><p>// 注意这里需要下载body-parser 插件才能使用post获取body内容</p><pre><code class="hljs js">router.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/mail&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">req,res</span>)=&gt;</span>&#123;    <span class="hljs-keyword">let</span> mail = req.<span class="hljs-property">body</span>.<span class="hljs-property">mail</span>    <span class="hljs-comment">// console.log(mail)</span>    emialserve.<span class="hljs-title function_">emailSignUp</span>(mail,res)    <span class="hljs-comment">// res.send(mail)</span>  &#125;)</code></pre><p><strong>前端代码请求： (使用的uni-app框架)</strong></p><pre><code class="hljs js">uni.<span class="hljs-title function_">request</span>(&#123;        <span class="hljs-attr">url</span>: <span class="hljs-string">&quot;http://10.200.120.197:3000/mail&quot;</span>,        <span class="hljs-attr">data</span>: &#123;  <span class="hljs-attr">mail</span>:<span class="hljs-variable language_">this</span>.<span class="hljs-property">user</span>  &#125;,        <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,        <span class="hljs-attr">success</span>: <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data)        &#125;      &#125;)</code></pre>]]></content>
    
    
    <categories>
      
      <category>Nodejs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nodejs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vu sync修饰符</title>
    <link href="/2020/12/21/37.vue%E4%BF%AE%E9%A5%B0%E7%AC%A6/"/>
    <url>/2020/12/21/37.vue%E4%BF%AE%E9%A5%B0%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<p>​</p><h2 id="sync修饰符"><a href="#sync修饰符" class="headerlink" title=".sync修饰符"></a>.sync修饰符</h2><p>在某些情况下，我们可能需要对一个 prop 进行“双向绑定”。</p><p>简单的方法是 <strong>子组件向父组件发送一个事件，父组件监听该事件，然后更新prop</strong></p><h3 id="简单的栗子：父子组件通信"><a href="#简单的栗子：父子组件通信" class="headerlink" title="简单的栗子：父子组件通信"></a>简单的栗子：父子组件通信</h3><p><strong>父组件：</strong></p><pre><code class="hljs js">&lt;template&gt;  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;FatherCom&quot;</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>我是父组件<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;show&quot;</span>&gt;</span>能看得见我吗？<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">ChildCom</span> <span class="hljs-attr">:show</span>=<span class="hljs-string">&quot;show&quot;</span> @<span class="hljs-attr">update:show</span>=<span class="hljs-string">&quot;update_show&quot;</span>/&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">import</span> <span class="hljs-title class_">ChildCom</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./ChildCom&#x27;</span></span></span><span class="language-javascript"><span class="language-xml"></span></span><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;FatherCom&#x27;</span>,</span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">components</span>: &#123;</span></span><span class="language-javascript"><span class="language-xml">      <span class="hljs-title class_">ChildCom</span></span></span><span class="language-javascript"><span class="language-xml">    &#125;,</span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span></span><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">return</span> &#123;</span></span><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">show</span>: <span class="hljs-literal">true</span></span></span><span class="language-javascript"><span class="language-xml">      &#125;</span></span><span class="language-javascript"><span class="language-xml">    &#125;,</span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">methods</span>: &#123;</span></span><span class="language-javascript"><span class="language-xml">      <span class="hljs-title function_">update_show</span>(<span class="hljs-params">val</span>) &#123;</span></span><span class="language-javascript"><span class="language-xml">        <span class="hljs-variable language_">this</span>.<span class="hljs-property">show</span> = val</span></span><span class="language-javascript"><span class="language-xml">      &#125;</span></span><span class="language-javascript"><span class="language-xml">    &#125;</span></span><span class="language-javascript"><span class="language-xml">  &#125;</span></span><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span></code></pre><p><strong>子组件：</strong></p><pre><code class="hljs js">&lt;template&gt;  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;ChildCom&quot;</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>我是子组件<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;handle&quot;</span> &gt;</span>显示/隐藏<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>&lt;/template&gt;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;ChildCom&#x27;</span>,</span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">props</span>:[<span class="hljs-string">&#x27;show&#x27;</span>],</span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">methods</span>:&#123;</span></span><span class="language-javascript"><span class="language-xml">      <span class="hljs-title function_">handle</span>(<span class="hljs-params"></span>)&#123;</span></span><span class="language-javascript"><span class="language-xml">        <span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&#x27;update:show&#x27;</span>,!<span class="hljs-variable language_">this</span>.<span class="hljs-property">show</span>)</span></span><span class="language-javascript"><span class="language-xml">      &#125;</span></span><span class="language-javascript"><span class="language-xml">    &#125;</span></span><span class="language-javascript"><span class="language-xml">  &#125;</span></span><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span></code></pre><p>但是以上父组件定义 自定义事件的步骤过于繁琐了。</p><p>可以通过 .sync修饰符简化父组件的代码：</p><ul><li>在子组件内触发的事件名要以 <code>update:myPropName</code> 方式命名(尤雨溪要求的)，</li><li>父组件 <code>:show:show</code> 加上.sync修饰符， 即 <code>:show.sync:show</code></li></ul><p>这样设置父组件就不再需要单独再去绑定@update:show事件了 。</p><p><strong>修改代码:</strong></p><pre><code class="hljs js">&lt;template&gt;  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;FatherCom&quot;</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>我是父组件<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;show&quot;</span>&gt;</span>能看得见我吗？<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span></span><span class="language-xml">    <span class="hljs-comment">&lt;!--&lt;ChildCom :show=&quot;show&quot; @update:show=&quot;update_show&quot;/&gt;--&gt;</span></span><span class="language-xml">     <span class="hljs-tag">&lt;<span class="hljs-name">ChildCom</span> <span class="hljs-attr">:show.sync</span>=<span class="hljs-string">&quot;show&quot;</span> /&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span></code></pre><pre><code class="hljs js"><span class="hljs-title function_">handle</span>(<span class="hljs-params"></span>)&#123;      <span class="hljs-comment">// 这里要求用 `update:myPropName` 方式命名</span>       <span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&#x27;update:show&#x27;</span>,!<span class="hljs-variable language_">this</span>.<span class="hljs-property">show</span>)     &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue 里 computed  和 watch 的区别</title>
    <link href="/2020/12/20/36-vue/"/>
    <url>/2020/12/20/36-vue/</url>
    
    <content type="html"><![CDATA[<p>​<br>​</p><h2 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h2><blockquote><p> 计算属性 ， computed 是用来计算出一个值，这个值在调用的时候会根据依赖的数据显示新的计算结果并自动缓存。 如果依赖不变，computed中的值就不会重新计算。 注意 ：不需要加(),</p></blockquote><h3 id="什么是计算属性，为什么要使用它"><a href="#什么是计算属性，为什么要使用它" class="headerlink" title="什么是计算属性，为什么要使用它"></a>什么是计算属性，为什么要使用它</h3><p><strong>模板内的表达式非常便利，但是设计它们的初衷是用于简单运算的。在模板中放入太多的逻辑会让模板过重且难以维护,例如：</strong></p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;example&quot;</span>&gt;</span>  &#123;&#123; message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><p><strong>在这个地方，模板不再是简单的声明式逻辑，你必须看一段时间才能意识到，这里是想要显示变量 <code>message</code> 的翻转字符串，当你想要在模板中多次引用此处的翻转字符串时，就会更加难以处理。</strong></p><ul><li>使用 方法 methods</li><li>使用 计算属性 compute</li></ul><h3 id="计算属性和方法的区别"><a href="#计算属性和方法的区别" class="headerlink" title="计算属性和方法的区别"></a>计算属性和方法的区别</h3><ul><li>计算属性是基于他们的响应式依赖进行缓存的，只在相关响应式依赖发生改变时，才会重新求值（也就是说，计算属性会把数据进行缓存）</li><li>而方法不会把数据进行缓存， 所以用计算属性效率会更高点</li></ul><p><strong>所以，对于任何复杂逻辑，都应该使用计算属性</strong></p><ul><li>在某些情况，我们可能需要对数据进行一些转化后再显示，或者需要将多个数据结合起来进行显示<ul><li><p>比如我们有firstName和lastName两个变量，我们需要显示完整的名称。</p></li><li><p>但是如果多个地方都需要显示完整的名称，我们就需要写多个 </p><pre><code class="hljs js"> &lt;body&gt;  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123;firstName + &#x27; &#x27; + lastName&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123;firstName&#125;&#125; &#123;&#123;lastName&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123;getFullName()&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123;fullName&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>&lt;/body&gt;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,</span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">data</span>: &#123;</span></span><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">firstName</span>: <span class="hljs-string">&#x27;Lron&#x27;</span>,</span></span><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">lastName</span>: <span class="hljs-string">&#x27;Man&#x27;</span></span></span><span class="language-javascript"><span class="language-xml">    &#125;,</span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 推荐使用计算属性来操作，因为它会将这些数据进行缓存， 无论打印多少次，它只会调用一次</span></span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">computed</span>: &#123;</span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">//  计算属性   注意 : 计算的是 属性, </span></span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 所以这里面的属性 看成一个 对象(用名词形式来表达), 调用时候不用加小括号</span></span></span><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">fullName</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span></span><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span> + <span class="hljs-string">&#x27; &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastName</span></span></span><span class="language-javascript"><span class="language-xml"></span></span><span class="language-javascript"><span class="language-xml">      &#125;</span></span><span class="language-javascript"><span class="language-xml">    &#125;,</span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">methods</span>: &#123;</span></span><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">//  不会缓存， 所以有多少次就调用多少次，  没有 computed 划算</span></span></span><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">getFullName</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span></span><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span> + <span class="hljs-string">&#x27; &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastName</span></span></span><span class="language-javascript"><span class="language-xml">      &#125;</span></span><span class="language-javascript"><span class="language-xml">    &#125;</span></span><span class="language-javascript"><span class="language-xml">  &#125;)</span></span><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span></code></pre></li></ul></li></ul><h2 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h2><p>参考文档：<a href="https://cn.vuejs.org/v2/api/#watch">vue官方文档：watch</a></p><blockquote><p>监听， 如果某个属性依赖变化了就执行回调。  它有俩个属性 1. immediate  表示数据是否在第一次渲染的时候立即执行该函数。    2. deep , 如果我们监听一个对象（不包括数组），是否要看对象里面的属性的变化。</p></blockquote><h3 id="什么是watch-为什么要使用它"><a href="#什么是watch-为什么要使用它" class="headerlink" title="什么是watch 为什么要使用它"></a>什么是watch 为什么要使用它</h3><p>watch监听的<strong>数据</strong>可以是一个 <strong>字符串、函数、数组、对象</strong></p><p>一个对象，键是需要观察的表达式（<strong>data内的数据</strong>），值是对应回调函数。值也可以是方法名，或者包含选项的对象。</p><p>当数据发生改变时，会执行一个回调，它有俩个参数， newVal 和 oldVal</p><p>wtach有俩个属性：</p><ul><li>immediate 是否在第一次渲染时执行这个函数，会在监听开始之后就立即本调用。</li><li>deep 是否要看这个对象里面的属性变化。</li></ul><p><strong>this.$watch 和 watch 用法一致，只不过写法有些不同，这里不详细说明</strong></p><p>案例：</p><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;  <span class="hljs-attr">data</span>: &#123;    <span class="hljs-attr">n</span>: <span class="hljs-number">0</span>,    <span class="hljs-attr">obj</span>: &#123;      <span class="hljs-attr">a</span>: <span class="hljs-string">&quot;a&quot;</span>    &#125;  &#125;,  <span class="hljs-attr">template</span>: <span class="hljs-string">`</span><span class="hljs-string">    &lt;div&gt;</span><span class="hljs-string">      &lt;button @click=&quot;n += 1&quot;&gt;n+1&lt;/button&gt;</span><span class="hljs-string">      &lt;button @click=&quot;obj.a += &#x27;hi&#x27;&quot;&gt;obj.a + &#x27;hi&#x27;&lt;/button&gt;</span><span class="hljs-string">      &lt;button @click=&quot;obj = &#123;a:&#x27;a&#x27;&#125;&quot;&gt;obj = 新对象&lt;/button&gt;</span><span class="hljs-string">    &lt;/div&gt;</span><span class="hljs-string">  `</span>,  <span class="hljs-attr">watch</span>: &#123;    <span class="hljs-title function_">n</span>(<span class="hljs-params"></span>) &#123;      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;n 变了&quot;</span>);    &#125;,    <span class="hljs-attr">obj</span>:&#123;      <span class="hljs-attr">handler</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">val, oldVal</span>) &#123;       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;obj 变了&quot;</span>)    &#125;,      <span class="hljs-attr">deep</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">// 该属性设定在任何被侦听的对象的 property 改变时都要执行 handler 的回调，不论其被嵌套多深</span>    &#125;,    <span class="hljs-string">&quot;obj.a&quot;</span>:&#123;      <span class="hljs-attr">handler</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">val, oldVal</span>) &#123;       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;obj.a 变了&quot;</span>)    &#125;,      <span class="hljs-attr">immediate</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">// 该属性设定该回调将会在侦听开始之后被立即调用</span>    &#125;  &#125;&#125;).$mount(<span class="hljs-string">&quot;#app&quot;</span>);</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>如果一个数据需要经过复杂计算就用 computed</li><li>如果一个数据需要在发生变化时做一些操作就用 watch</li></ol>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue俩个版本：runtime-compiler和 runtime-only 的区别</title>
    <link href="/2020/12/20/35-Vue%E4%BF%A9%E4%B8%AA%E7%89%88%E6%9C%AC/"/>
    <url>/2020/12/20/35-Vue%E4%BF%A9%E4%B8%AA%E7%89%88%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<blockquote><p>参考vue文档链接： <a href="https://cn.vuejs.org/v2/guide/installation.html#%E5%BC%80%E5%8F%91%E7%89%88%E6%9C%AC">https://cn.vuejs.org/v2/guide/installation.html#%E5%BC%80%E5%8F%91%E7%89%88%E6%9C%AC</a></p></blockquote><h2 id="runtime-Compiler-和-runtime-only在main-js文件的区别"><a href="#runtime-Compiler-和-runtime-only在main-js文件的区别" class="headerlink" title="runtime-Compiler 和 runtime-only在main.js文件的区别"></a>runtime-Compiler 和 runtime-only在main.js文件的区别</h2><pre><code class="hljs js"><span class="hljs-comment">//（1） Runtime-Compiler</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;  <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,  <span class="hljs-attr">components</span>: &#123; <span class="hljs-title class_">App</span> &#125;,  <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;&lt;App/&gt;&#x27;</span>&#125;) <span class="hljs-comment">// （2）Runtime-only</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;  <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,  <span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> <span class="hljs-title function_">h</span>(<span class="hljs-title class_">App</span>)&#125;)</code></pre><p>在上述代码块中可以看出最大的区别在于 ：</p><p><strong>runtime-Compiler 中的参数是 components 和  template</strong> 。而<strong>runtime-only版本中的参数是 render 函数</strong>。</p><h2 id="runtime-only-版本-不能有-template"><a href="#runtime-only-版本-不能有-template" class="headerlink" title="runtime-only 版本 不能有 template"></a>runtime-only 版本 不能有 template</h2><p>在这个vue不完整版，需要借助webpack的 <strong>vue-loader</strong>加载器 <strong>把vue文件编译成js</strong>。</p><p>webpack使用vue-loader将vuew文件编译js的过程中会<strong>将组件的template模板编译位render函数</strong>，所以我们得到的是render函数就如上图所示。</p><p>所以，该版本只会包含运行时的vue代码，对于template这种需要编译，只交给webpack即可。</p><p>这会使得该版本代码的体积小。</p><h2 id="runtime-complier版本-可以有template"><a href="#runtime-complier版本-可以有template" class="headerlink" title="runtime-complier版本 可以有template"></a>runtime-complier版本 可以有template</h2><p>如果写了template，那么就会在运行时直接编译成render函数， 而不是依靠webpack来帮助编译，这不仅仅使得该版本体积变大，而且在编译过程也会对性能有一定的损耗。</p><h2 id="runtime-complier-解析过程："><a href="#runtime-complier-解析过程：" class="headerlink" title="runtime-complier 解析过程："></a>runtime-complier 解析过程：</h2><ul><li>第一步：将template模板转换成抽象语法树（ast）;</li><li>第二步：通过render函数将抽象语法树转换成虚拟DOM（vdom）;</li><li>第三步：将虚拟DOM转换成真正的DOM；</li></ul><p><strong>template =&gt; 抽象语法树(ast) =&gt; render() =&gt; 虚拟DOM(vdom) =&gt; 页面</strong></p><h2 id="runtime-only-解析过程："><a href="#runtime-only-解析过程：" class="headerlink" title="runtime-only 解析过程："></a>runtime-only 解析过程：</h2><ul><li>第一步：vue-template-compiler插件直接将组件转换成 render函数；</li><li>第二步：将render函数返回的虚拟DOM转换成页面；</li></ul><p><strong>render() =&gt; 虚拟DOM(vdom) =&gt; 页面；</strong> </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table><thead><tr><th></th><th>vue完整版（runtime-compiler）</th><th>vue非完整版（runtime-only）</th><th>评价</th></tr></thead><tbody><tr><td>特点</td><td>有compiler</td><td>没有compiler</td><td>compiler 占40%体积</td></tr><tr><td>视图</td><td>写在HTML里或者写在template选项</td><td>写在render函数里用h来创建标签</td><td></td></tr><tr><td>cdn引入</td><td>vue.js</td><td>vue.runtime.js</td><td>文件名不同</td></tr><tr><td>webpack引入</td><td>需要额外配置alias</td><td>默认使用此版本</td><td></td></tr><tr><td>@vue/cli 引入</td><td>需要额外配置</td><td>默认使用此版本</td><td></td></tr></tbody></table><p>因此推荐使用 vue非完整版（<strong>runtime-only</strong>）。</p><p><strong>优点:</strong></p><ul><li>保证用户体验，用户下载的JS文件体积更小，但支持h函数（render函数中的h）。</li><li>保证开发体验，开发者可以直接在vue文件里写html标签，而不写h函数</li><li>累活都让loader做，vue-loader把vue文件里的html转为h函数。</li></ul>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Webpack入门配置总结</title>
    <link href="/2020/12/18/34-Webpack%E5%85%A5%E9%97%A8%E9%85%8D%E7%BD%AE%E6%80%BB%E7%BB%93/"/>
    <url>/2020/12/18/34-Webpack%E5%85%A5%E9%97%A8%E9%85%8D%E7%BD%AE%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> 我的配置版本号如下:</p> <pre><code class="hljs json"><span class="hljs-attr">&quot;devDependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>   <span class="hljs-attr">&quot;css-loader&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^3.2.0&quot;</span><span class="hljs-punctuation">,</span>   <span class="hljs-attr">&quot;dart-sass&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^1.23.7&quot;</span><span class="hljs-punctuation">,</span>   <span class="hljs-attr">&quot;file-loader&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^5.0.2&quot;</span><span class="hljs-punctuation">,</span>   <span class="hljs-attr">&quot;html-webpack-plugin&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^3.2.0&quot;</span><span class="hljs-punctuation">,</span>   <span class="hljs-attr">&quot;less&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^3.10.3&quot;</span><span class="hljs-punctuation">,</span>   <span class="hljs-attr">&quot;less-loader&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^5.0.0&quot;</span><span class="hljs-punctuation">,</span>   <span class="hljs-attr">&quot;mini-css-extract-plugin&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^0.8.0&quot;</span><span class="hljs-punctuation">,</span>   <span class="hljs-attr">&quot;sass-loader&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^8.0.0&quot;</span><span class="hljs-punctuation">,</span>   <span class="hljs-attr">&quot;style-loader&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^1.0.1&quot;</span><span class="hljs-punctuation">,</span>   <span class="hljs-attr">&quot;webpack&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^4.41.2&quot;</span><span class="hljs-punctuation">,</span>   <span class="hljs-attr">&quot;webpack-cli&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^3.3.10&quot;</span><span class="hljs-punctuation">,</span>   <span class="hljs-attr">&quot;webpack-dev-server&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^3.9.0&quot;</span> <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span></code></pre><blockquote><p> 参考文档：webpack官方文档 , 在配置每一部分时候我会把链接发在里面</p></blockquote><h2 id="package-json中配置build"><a href="#package-json中配置build" class="headerlink" title="package.json中配置build"></a>package.json中配置build</h2> <pre><code class="hljs json"><span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>  <span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;rm -rf dist &amp;&amp; webpack&quot;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span></code></pre><h2 id="初始化-webpack-config-js"><a href="#初始化-webpack-config-js" class="headerlink" title="初始化 webpack.config.js"></a>初始化 webpack.config.js</h2><h3 id="模式的区别："><a href="#模式的区别：" class="headerlink" title="模式的区别："></a>模式的区别：</h3> <pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;  <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;development&#x27;</span>  <span class="hljs-comment">// 开发者模式  注意去观察 dist/main.js  会发现有许多注释并没有被压缩</span>&#125;;</code></pre> <pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;  <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;production&#x27;</span>  <span class="hljs-comment">// 生产模式  去观察 dist/main.js  代码都被压缩了，</span>&#125;;</code></pre><h3 id="入口文件和出口文件配置："><a href="#入口文件和出口文件配置：" class="headerlink" title="入口文件和出口文件配置："></a>入口文件和出口文件配置：</h3> <pre><code class="hljs js"><span class="hljs-keyword">var</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;  <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;development&#x27;</span>,   <span class="hljs-comment">// 开发者模式</span>  <span class="hljs-attr">entry</span>: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,  <span class="hljs-comment">// 打包的入口文件</span>  <span class="hljs-attr">output</span>: &#123;    <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>),  <span class="hljs-comment">// 可用不用写，默认是dist文件</span>       <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;index.[contenthash].js&#x27;</span>  <span class="hljs-comment">// 打包出口文件名， 以 index.20位随机数/字母.js以文件名</span>  &#125;&#125;;</code></pre><h2 id="webpack插件自动生成HTML："><a href="#webpack插件自动生成HTML：" class="headerlink" title="webpack插件自动生成HTML："></a>webpack插件自动生成HTML：</h2><blockquote><p> webpack文档链接 ：<a href="https://webpack.js.org/plugins/html-webpack-plugin/">https://webpack.js.org/plugins/html-webpack-plugin/</a>   和 <a href="https://github.com/jantimon/html-webpack-plugin#options">https://github.com/jantimon/html-webpack-plugin#options</a></p></blockquote><p>  这样就会在 dist文件中生成一个 index.html</p> <pre><code class="hljs bash">npm install --save-dev html-webpack-plugin</code></pre> <pre><code class="hljs js"><span class="hljs-keyword">var</span> <span class="hljs-title class_">HtmlWebpackPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;html-webpack-plugin&#x27;</span>);<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;  <span class="hljs-attr">plugins</span>: [<span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>()]  &#125;;</code></pre><p> 配置内容：</p> <pre><code class="hljs js"><span class="hljs-attr">plugins</span>: [<span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>(&#123;    <span class="hljs-comment">// 可以不写filename这个属性，也默认生成index.html</span>   <span class="hljs-comment">// 在这里配置title 要在template中的html文件内的title标签配置 &lt;%= htmlWebpackPlugin.options.title %&gt;</span>   <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Wang-pf&#x27;</span>,   <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;src/assets/index.html&#x27;</span> <span class="hljs-comment">// 生成模板是哪个</span> &#125;)]</code></pre><h2 id="webpack引入CSS："><a href="#webpack引入CSS：" class="headerlink" title="webpack引入CSS："></a>webpack引入CSS：</h2><h3 id="方法一：-用JS来生成style"><a href="#方法一：-用JS来生成style" class="headerlink" title="方法一： 用JS来生成style"></a>方法一： 用JS来生成style</h3><blockquote><p>webpack文档链接: <a href="https://webpack.docschina.org/loaders/css-loader/#getting-started">https://webpack.docschina.org/loaders/css-loader/#getting-started</a></p></blockquote><p> 先安装依赖插件， 必须要安装style-loader 。</p> <pre><code class="hljs bash">npm install --save-dev  style-loader css-loader</code></pre><p> <strong>原理是 webpack默认要把 以.css结尾的放到style标签中。</strong></p> <pre><code class="hljs js"><span class="hljs-attr">module</span>: &#123;   <span class="hljs-attr">rules</span>: [&#123;     <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/i</span>, <span class="hljs-comment">// 以 .css 结尾的</span>     <span class="hljs-attr">use</span>: [<span class="hljs-string">&quot;style-loader&quot;</span>, <span class="hljs-string">&quot;css-loader&quot;</span>], <span class="hljs-comment">// 依赖插件</span>     &#125;, ], &#125;</code></pre><h3 id="方法二：-把CSS抽成文件"><a href="#方法二：-把CSS抽成文件" class="headerlink" title="方法二： 把CSS抽成文件"></a>方法二： 把CSS抽成文件</h3><p> 先安装依赖，</p> <pre><code class="hljs bash">npm install --save-dev mini-css-extract-plugin</code></pre><p> 配置</p> <pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">MiniCssExtractPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;mini-css-extract-plugin&#x27;</span>);<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;  <span class="hljs-attr">plugins</span>: [     <span class="hljs-keyword">new</span> <span class="hljs-title class_">MiniCssExtractPlugin</span>(&#123;      <span class="hljs-comment">// 类似于 webpackOptions.output 中的选项</span>      <span class="hljs-comment">// 所有选项都是可选的</span>      <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;[name].[contenthash].css&#x27;</span>,      <span class="hljs-attr">chunkFilename</span>: <span class="hljs-string">&#x27;[id].[contenthash].css&#x27;</span>,      <span class="hljs-attr">ignoreOrder</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 忽略有关顺序冲突的警告</span>    &#125;),  ],  <span class="hljs-attr">module</span>: &#123;    <span class="hljs-attr">rules</span>: [      &#123;        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/</span>,       <span class="hljs-attr">use</span>: [&#123;          <span class="hljs-attr">loader</span>: <span class="hljs-title class_">MiniCssExtractPlugin</span>.<span class="hljs-property">loader</span>,          <span class="hljs-attr">options</span>: &#123;            <span class="hljs-comment">// 你可以在这里指定特定的 publicPath</span>            <span class="hljs-comment">// 默认情况下使用 webpackOptions.output 中的 publicPath</span>            <span class="hljs-attr">publicPath</span>: <span class="hljs-string">&#x27;../&#x27;</span>,          &#125;,        &#125;,        <span class="hljs-string">&#x27;css-loader&#x27;</span>,      ],      &#125;,    ],  &#125;,&#125;;</code></pre><h2 id="webpack-dev-server-的使用"><a href="#webpack-dev-server-的使用" class="headerlink" title="webpack dev-server 的使用"></a>webpack dev-server 的使用</h2><blockquote><p>webpack dev-server文档链接：<a href="https://www.webpackjs.com/guides/development/">https://www.webpackjs.com/guides/development/</a>    </p></blockquote><ol><li><p>安装插件</p><pre><code class="hljs bash">npm install --save-dev webpack-dev-server</code></pre></li><li><p>webpack.config.js 配置</p><pre><code class="hljs js"><span class="hljs-attr">devServer</span>: &#123;<span class="hljs-attr">contentBase</span>: <span class="hljs-string">&#x27;./dist&#x27;</span>&#125;,</code></pre></li><li><p>在package.json 配置以下 start</p><pre><code class="hljs bash"><span class="hljs-string">&quot;start&quot;</span>: <span class="hljs-string">&quot;webpack-dev-server --open&quot;</span>,</code></pre><p>在 npm start 的时候发现 报错， 报错原因是：<a href="https://stackoverflow.com/questions/59611597/error-cannot-find-module-webpack-cli-bin-config-yargs">Error: Cannot find module ‘webpack-cli/bin/config-yargs’</a></p><p>解决方法是：把版本号改一下  如下：</p><pre><code class="hljs json"><span class="hljs-attr">&quot;webpack&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^4.41.2&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;webpack-cli&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^3.3.10&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;webpack-dev-server&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^3.9.0&quot;</span></code></pre><h2 id="不同模式使用不同的-webpack-config"><a href="#不同模式使用不同的-webpack-config" class="headerlink" title="不同模式使用不同的 webpack  config"></a>不同模式使用不同的 webpack  config</h2><blockquote><p>我们已经知道模式有 开发者模式(development) 和 生产模式(production)  ,那么我们应该在不同模式中选用不同的插件来使用。</p><p>比如： 在生产模式production中，引入CSS方法使用style， 因为这样不同生成一个CSS文件，使得效率变高。如果是开发者模式 ，那么我们就需要把CSS抽成文件。</p></blockquote><p>创建一个webpack配置文件：webpack.config.prod.js  用在生产模式时使用。</p><p>创建一个webpack配置文件： webpack.config.base.js  用于开发和生产模式的共同属性</p><p>并在package.json文件中重新配置build。</p><pre><code class="hljs json"><span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;rm -rf dist &amp;&amp; webpack --config webpack.config.prod.js&quot;</span></code></pre><h2 id="webpack-loader-和-webpack-plugin-的区别"><a href="#webpack-loader-和-webpack-plugin-的区别" class="headerlink" title="webpack loader   和 webpack  plugin 的区别"></a>webpack loader   和 webpack  plugin 的区别</h2></li></ol><ul><li><p>loader （加载器） ： 用于加载某些文件，比如加载JS文件，可以把JS转换为低版本支持的js, 又比如CSS,使用相应的loder加载，可以把CSS放到页面上style标签中或者其他处理。也可以用来加载图片，可以对图片进行优化。</p></li><li><p>plugin （插件）： 扩展webpack功能的，比如使用 HtmlWebpackPlugin 插件用来生成html文件， 使用 miniCssExtractPlugin 插件用来生成CSS文件等。</p><h2 id="引入-sass"><a href="#引入-sass" class="headerlink" title="引入 sass"></a>引入 sass</h2><blockquote><p>参考链接：<a href="https://webpack.docschina.org/loaders/sass-loader/">https://webpack.docschina.org/loaders/sass-loader/</a></p></blockquote><p>这里使用 datr-sass  不使用node-sass（已过时）</p><pre><code class="hljs bash">npm install sass-loader dart-sass --save-dev</code></pre><p>webpakc.config配置：</p><pre><code class="hljs js"><span class="hljs-attr">rules</span>: [&#123;     <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.scss$/i</span>,     <span class="hljs-attr">use</span>: [       <span class="hljs-string">&quot;style-loader&quot;</span>,       <span class="hljs-string">&quot;css-loader&quot;</span>,       &#123;         <span class="hljs-attr">loader</span>: <span class="hljs-string">&quot;sass-loader&quot;</span>,         <span class="hljs-attr">options</span>: &#123;           <span class="hljs-comment">// `dart-sass` 是首选</span>           <span class="hljs-attr">implementation</span>: <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;dart-sass&quot;</span>),         &#125;,       &#125;,     ],&#125;, ],</code></pre><p>把css文件改为scss文件即可使用。</p><h2 id="引入less"><a href="#引入less" class="headerlink" title="引入less"></a>引入less</h2><blockquote><p>文档链接：<a href="https://webpack.js.org/loaders/less-loader/">https://webpack.js.org/loaders/less-loader/</a></p></blockquote><p>安装loader</p><pre><code class="hljs bash">npm install less less-loader --save-dev</code></pre><pre><code class="hljs js">&#123;    <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.less$/</span>,    <span class="hljs-attr">loader</span>: [<span class="hljs-string">&quot;style-loader&quot;</span>,<span class="hljs-string">&quot;css-loader&quot;</span>,<span class="hljs-string">&quot;less-loader&quot;</span>], <span class="hljs-comment">// compiles Less to CSS</span>  &#125;,</code></pre><p>stylus  和 引入less 方法一致，不再写了。</p><h2 id="使用-file-loader-引入图片"><a href="#使用-file-loader-引入图片" class="headerlink" title="使用 file-loader 引入图片"></a>使用 file-loader 引入图片</h2><blockquote><p>参考文档: <a href="https://webpack.js.org/loaders/file-loader/">https://webpack.js.org/loaders/file-loader/</a></p></blockquote><p>安装</p><pre><code class="hljs bash">npm install file-loader --save-dev</code></pre><p>我的版本号：</p><pre><code class="hljs json"><span class="hljs-attr">&quot;file-loader&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^5.0.2&quot;</span><span class="hljs-punctuation">,</span></code></pre><p>webpack.config配置：</p><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;  <span class="hljs-attr">module</span>: &#123;    <span class="hljs-attr">rules</span>: [      &#123;        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(png|jpe?g|gif)$/i</span>,        <span class="hljs-attr">use</span>: [          &#123;            <span class="hljs-attr">loader</span>: <span class="hljs-string">&#x27;file-loader&#x27;</span>,          &#125;,        ],      &#125;,    ],  &#125;,&#125;;</code></pre><p>然后在html页面中引入就可以了。</p><h2 id="webpack-impor-懒加载"><a href="#webpack-impor-懒加载" class="headerlink" title="webpack impor()  懒加载"></a>webpack impor()  懒加载</h2><p>不多说看代码</p><p>inedx.js</p><pre><code class="hljs js"><span class="hljs-comment">// index.js</span><span class="hljs-keyword">const</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;button&#x27;</span>)btn.<span class="hljs-property">innerText</span> = <span class="hljs-string">&#x27;懒加载&#x27;</span>btn.<span class="hljs-property">onclick</span> = <span class="hljs-function">()=&gt;</span>&#123; <span class="hljs-keyword">const</span> promise = <span class="hljs-title function_">import</span>(<span class="hljs-string">&#x27;./lazy.js&#x27;</span>)  promise.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params"><span class="hljs-variable language_">module</span></span>)=&gt;</span>&#123;    <span class="hljs-keyword">const</span> fn = <span class="hljs-variable language_">module</span>.<span class="hljs-property">default</span>    <span class="hljs-title function_">fn</span>()  &#125;,<span class="hljs-function">()=&gt;</span>&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;懒加载模块加载失败&#x27;</span>)  &#125;)&#125;div.<span class="hljs-title function_">appendChild</span>(btn)</code></pre><p>lazy.js</p><pre><code class="hljs js"><span class="hljs-keyword">export</span>  <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">lazy</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我是懒加载陌客&#x27;</span>)&#125;</code></pre><p>上面就是如何使用 import() 来实现懒加载</p><p>用 import()  去加载文件 ，然后得到一个 promise  ， 在成功之后 使用 module.default() 调用 lazy.js 文件</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>webpack</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript中的MVC</title>
    <link href="/2020/12/17/33-MVC/"/>
    <url>/2020/12/17/33-MVC/</url>
    
    <content type="html"><![CDATA[<h2 id="MVC三类对象"><a href="#MVC三类对象" class="headerlink" title="MVC三类对象"></a>MVC三类对象</h2><p>MVC模式（Model-view-controller） 是一种设计模式（软件架构）。</p><p>MVC包括三类对象，将它们分离以提高灵活性和复用性。</p><ul><li><strong>模型（Model）</strong> ： 同于数据管理， 一旦模型的数据发生改变，Model将通知有关的视图。</li><li><strong>视图(View)</strong> ： 负责用户界面，HTML渲染。 描绘的是Model的当前状态，当模型的数据发生改变，View就会刷新自己。</li><li><strong>控制（Controller）</strong> : 控制器， Controll 控制其他所有流程。 负责监听并处理视图(View)的事件。更新和调用Model。也负责监听Model的变化，并更新View。</li></ul><h2 id="MVC-for-JAVASCRIPT"><a href="#MVC-for-JAVASCRIPT" class="headerlink" title="MVC for JAVASCRIPT"></a>MVC for JAVASCRIPT</h2><pre><code class="hljs js"><span class="hljs-comment">//数据Model</span><span class="hljs-keyword">const</span> model = &#123;  <span class="hljs-comment">// 数据</span>  <span class="hljs-attr">data</span>: &#123;&#125;,  <span class="hljs-comment">// 对数据处理的一些方法</span>  <span class="hljs-title function_">create</span>(<span class="hljs-params"></span>) &#123;&#125;,  <span class="hljs-title function_">delete</span>(<span class="hljs-params"></span>) &#123;&#125;,  <span class="hljs-title function_">update</span>(<span class="hljs-params"></span>) &#123;&#125;,  <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;&#125;&#125;<span class="hljs-comment">//视图View</span><span class="hljs-keyword">const</span> view = &#123;  <span class="hljs-comment">//1、一个空容器，以后就是装html的容器</span>  <span class="hljs-attr">el</span>: <span class="hljs-literal">null</span>,  <span class="hljs-comment">//2、要添加的html</span>  <span class="hljs-attr">html</span>: <span class="hljs-string">`&lt;div&gt;123&lt;/div&gt;....`</span>,  <span class="hljs-comment">//3、初始化容器函数，参数是我们给的要当容器的元素（应该是index.html里就有的元素）</span>  <span class="hljs-title function_">init</span>(<span class="hljs-params">container</span>) &#123;v.<span class="hljs-property">el</span> = $(container);&#125;,  <span class="hljs-comment">//4、渲染函数，参数将是数据。也就是视图全都是对数据渲染 view = render(data)</span>  <span class="hljs-title function_">render</span>(<span class="hljs-params">x</span>) &#123;&#125;&#125;<span class="hljs-comment">// 控制Controller  </span><span class="hljs-comment">// 处理数据的事件，并把结果渲染到视图View上</span><span class="hljs-keyword">const</span> c = &#123;  <span class="hljs-comment">//1.总初始化函数。</span>  <span class="hljs-title function_">init</span>(<span class="hljs-params">container</span>) &#123;&#125;,  <span class="hljs-comment">// 事件</span>  <span class="hljs-attr">events</span>: &#123;&#125;,  <span class="hljs-comment">//事件要执行的函数</span>  <span class="hljs-title function_">add</span>(<span class="hljs-params"></span>) &#123;&#125;,  <span class="hljs-title function_">minus</span>(<span class="hljs-params"></span>) &#123;&#125;,  <span class="hljs-title function_">mul</span>(<span class="hljs-params"></span>) &#123;&#125;,  <span class="hljs-title function_">div</span>(<span class="hljs-params"></span>) &#123;&#125;,&#125;</code></pre><h2 id="EventBus"><a href="#EventBus" class="headerlink" title="EventBus"></a>EventBus</h2><p><strong>EventBus的实现方法：</strong></p><ul><li>比如用vue， new一个新的vue，它是一个实例对象。</li><li>但是最重要的在于它原型上有我们用到的$on(监听)、$off（解绑）、$emit（触发）等API 。</li></ul><p><strong>EventBus作用:</strong></p><ul><li>EventBus 主要用于对象间的通信，</li><li>使用 EventBus 可以满足最小知识原则，model和view互相不知道对方的细节，但是却可用调用对方的功能。</li></ul><h2 id="表驱动编程"><a href="#表驱动编程" class="headerlink" title="表驱动编程"></a>表驱动编程</h2><p>当我们需要判断 3 种以上的情况，做出相应的事情，往往需要写很多很多的 if else，这样的代码可读性不强。</p><p>为了增强代码的可读性，我们可以用表驱动编程，把用来做 if 条件判断的值存进一个哈希表，然后从表里取值。</p><p>而这种做法的意义就在于： <strong>逻辑和数据是分离的</strong></p><p>举个例子，比如国家简写转换，给一个国家全名，转换成国家简写，用if else语法来写:</p><pre><code class="hljs js"><span class="hljs-comment">//  伪代码</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">contry</span>(<span class="hljs-params">国家名</span>)&#123;<span class="hljs-keyword">if</span>(中国)&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;CHN&quot;</span>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(日本)&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;JPN&quot;</span>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(美国)&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;USA&quot;</span>    &#125;<span class="hljs-keyword">else</span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;OTHER&quot;</span>    &#125;&#125;</code></pre><p>用 if else语句这样做，如果我再增加一个国家，那么就要写一个if else语句。等于又增加了一条逻辑。</p><p>那么我们为何不用 表数据编程 把 数据和逻辑分离开实现呢。</p><p>毕竟，<strong>数据</strong>的添加是<strong>简单，低成本和低风险</strong>的。 而<strong>逻辑</strong>的添加是<strong>负责，高成本和高风险</strong>的。</p><p>表驱动编程做法：</p><pre><code class="hljs js">伪代码<span class="hljs-keyword">function</span> <span class="hljs-title function_">contry</span>(<span class="hljs-params">国家名</span>)&#123;<span class="hljs-keyword">const</span> 国家列表 = [    <span class="hljs-string">&quot;中国&quot;</span>  = <span class="hljs-string">&quot;CHN&quot;</span>    <span class="hljs-string">&quot;日本&quot;</span>  = <span class="hljs-string">&quot;JPN&quot;</span>    <span class="hljs-string">&quot;美国&quot;</span>  = <span class="hljs-string">&quot;USA&quot;</span>    ]   国家简写转换：<span class="hljs-title function_">funciton</span>(<span class="hljs-params"></span>)&#123;   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> 国家名 <span class="hljs-keyword">in</span> 国家列表)&#123;    <span class="hljs-keyword">return</span> 国家列表[国家名]  <span class="hljs-comment">// 返回的就是 国家简写</span>    &#125;   &#125;&#125;</code></pre><p>你瞧这样做，如果你再添加一个国家名（数据），那么我们只需国家列表(数组)中添加一项即可。逻辑方面的我们一点都不需要更改，更别说去考虑逻辑了。</p><p><strong>这样，我们就脱离了数据与逻辑的关系了。</strong></p><p>参考文章:<a href="https://www.zhihu.com/question/37943171/answer/119525120">用表驱动编程重构if-else的意义</a></p><h2 id="自我理解的模块化"><a href="#自我理解的模块化" class="headerlink" title="自我理解的模块化"></a>自我理解的模块化</h2><p>将一个复杂的程序依据一定的规则（规范）封装成几个块（文件）并进行组合。</p><p>模块的内部数据的实现是私有的，只是向外部暴露一些接口（方法）与外部其他模块通信。这则就是模块化。</p><p><strong>模块化的好处：</strong></p><ul><li>降低代码耦合度</li><li>减少重复代码</li><li>提高代码重用性</li><li>在项目结构上更加清晰，便于维护。</li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>MVC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>跨域</title>
    <link href="/2020/12/12/32-%E8%B7%A8%E5%9F%9F/"/>
    <url>/2020/12/12/32-%E8%B7%A8%E5%9F%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><blockquote><p>同源策略（Same-Origin-Policy） 最早是由 Netscape 公司提出，是浏览器的一种安全策略。</p></blockquote><p><strong>即 不同源的页面之间，不准互相访问数据</strong></p><ul><li>window.origin 或 location.origin 可以得到当前源。</li><li>同源：协议，域名，端口号，必须完全相同。</li><li>违背同源策略就是跨域</li><li>ajax默认是遵循同源策略的。</li></ul><p>举个栗子：</p><ul><li><a href="https://qq.com/">https://qq.com</a>  、 <a href="https://wwww.baidu.com/">https://wwww.baidu.com</a>   不同源</li><li><a href="https://baidu.com/">https://baidu.com</a> 、 <a href="https://www.baidu.com/">https://www.baidu.com</a>  不同源</li><li>协议，域名，端口号，必须完全相同才叫同源</li></ul><h2 id="CORS-实现跨域"><a href="#CORS-实现跨域" class="headerlink" title="CORS 实现跨域"></a>CORS 实现跨域</h2><p>CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。</p><p>它允许浏览器向跨源服务器，发出<code>XMLHttpRequest</code>请求，从而克服了AJAX只能<code>同源</code>使用的限制。</p><p>但是IE10以下是不支持的。</p><h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><p>因为CORS与AJAX没有什么差别，只不过浏览器发现是AJAX请求跨源，就会在请求中自动添加一些附加的头信息。因此我们只需要以此判断是否可以跨域，在响应头中加入一些信息即可。</p><p>所以，CORS跨域的关键是在服务器，只要服务器实现了CORS接口，即可跨源通信。</p><p>简单请求：</p><pre><code class="hljs js">response.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="hljs-string">&#x27;http://wangpf.com:9990&#x27;</span>)</code></pre><p>注意：它的值要么是请求时Origin字段的值（<strong>协议 + 域名 + 端口</strong>），要么是一个<code>*</code>，表示接受任意域名的请求。</p><p><strong>AJAX 和服务器代码展示：</strong></p><p><code>http://wangpf.com:9990中的js内容：</code></p><pre><code class="hljs js"><span class="hljs-keyword">const</span> req = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>()req.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;http://qq.com:8888/friends.json&#x27;</span>)req.<span class="hljs-title function_">send</span>()req.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-keyword">if</span> (req.<span class="hljs-property">readyState</span> === <span class="hljs-number">4</span>) &#123;    <span class="hljs-keyword">if</span> (req.<span class="hljs-property">status</span> &gt;= <span class="hljs-number">200</span> &amp;&amp; req.<span class="hljs-property">status</span> &lt; <span class="hljs-number">300</span>) &#123;      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(req.<span class="hljs-property">response</span>);    &#125;  &#125;&#125;</code></pre><p><code>http://qq.com:8888 中服务端内容</code></p><pre><code class="hljs js"><span class="hljs-keyword">if</span>(path === <span class="hljs-string">&#x27;friends.json&#x27;</span>)&#123;  response.<span class="hljs-property">statusCode</span> = <span class="hljs-number">200</span>    response.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&#x27;Content-Type&#x27;</span>, <span class="hljs-string">&#x27;text/json;charset=utf-8&#x27;</span>)    <span class="hljs-comment">// console.log(request.headers[&#x27;referer&#x27;]); </span>    response.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="hljs-string">&#x27;http://wangpf.com:9990&#x27;</span>)    response.<span class="hljs-title function_">write</span>(fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&#x27;./public/friends.json&#x27;</span>))    response.<span class="hljs-title function_">end</span>()  &#125;</code></pre><h2 id="JSONP-实现跨域"><a href="#JSONP-实现跨域" class="headerlink" title="JSONP 实现跨域"></a>JSONP 实现跨域</h2><p><strong>什么是JSONP？</strong></p><p> JSONP（JSONP with Padding） 是一大堆牛逼的程序员想出来的跨域方法。</p><p> 当前网站创造一个script标签去请求另一个网站的JS，然后这个JS文件会夹带一些数据，这些数据会在我的网站上调用全局函数运行。</p><p><strong>JSONP是怎么实现的？</strong></p><p>因为我们当前浏览器或者某些条件不支持CORS来实现跨域，所以我们必须要使用另外一种方式来跨域，于是我们就请求JS文件，这个JS文件会执行一个回调，这个回调里面就有我们的数据。</p><p>这个回调名字是可以随机生成的，我们把这个随机数以callback为参数传给后台，后台会把这个函数再次返回给我们并执行</p><p><strong>JSONP的优点和缺点</strong></p><p>优点：</p><ul><li>支持IE</li><li>可以跨域（好像是废话哦。。。）</li></ul><p>缺点：</p><ul><li>由于它是script标签，它不能像AJAX一样，读出（拿到）状态码和响应头，它只知道成功和失败（用onload和onerror来监听）。</li><li>由于它是script标签，它只能发get请求，不支持POST。</li></ul><p><strong>JSONP的原理</strong></p><ul><li>网页有一些标签天生具有跨域的能力，比如：img link iframe script</li><li>JSONP 就是利用 script标签的跨域能力来发送请求的（<strong>这也是jsonp跨域只能用get请求的原因所在</strong>）</li></ul><h3 id="封装一个JSONP函数"><a href="#封装一个JSONP函数" class="headerlink" title="封装一个JSONP函数"></a>封装一个JSONP函数</h3><pre><code class="hljs js"><span class="hljs-comment">//封装JSONP函数  使用JSONP 实现</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">JSONP</span>(<span class="hljs-params">url</span>) &#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;    <span class="hljs-keyword">const</span> random = <span class="hljs-string">&#x27;WangpfCallbackName&#x27;</span> + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>()    <span class="hljs-variable language_">window</span>[random] = <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;      <span class="hljs-title function_">resolve</span>(data)    &#125;    <span class="hljs-keyword">const</span> script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;script&#x27;</span>)    script.<span class="hljs-property">src</span> = <span class="hljs-string">`<span class="hljs-subst">$&#123;url&#125;</span>?callback=<span class="hljs-subst">$&#123;random&#125;</span>`</span>    <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(script)    script.<span class="hljs-property">onload</span> = <span class="hljs-function">() =&gt;</span> &#123;      script.<span class="hljs-title function_">remove</span>()    &#125;    script.<span class="hljs-property">onerror</span> = <span class="hljs-function">() =&gt;</span> &#123;      <span class="hljs-title function_">reject</span>()    &#125;  &#125;)&#125;<span class="hljs-title class_">JSON</span>P(<span class="hljs-string">&#x27;http://qq.com:8888/friends.js&#x27;</span>)  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);  &#125;)</code></pre>]]></content>
    
    
    <categories>
      
      <category>ajax</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AJAX</tag>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DOM事件&amp;事件委托</title>
    <link href="/2020/12/11/31-DOM%E4%BA%8B%E4%BB%B6%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/"/>
    <url>/2020/12/11/31-DOM%E4%BA%8B%E4%BB%B6%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是DOM"><a href="#什么是DOM" class="headerlink" title="什么是DOM"></a>什么是DOM</h2><blockquote><p>文档对象模型（Document Object Model，简称<strong>DOM</strong>），是W3C组织推荐的处理可扩展标记语言（HTML 或者 XML ）的标准<strong>编程接口</strong></p></blockquote><p><strong>简言之，它会将web页面和脚本或程序语言连接起来。</strong></p><h2 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h2><p><strong>事件流</strong>描述的是从页面中接收事件的顺序</p><p><strong>事件</strong>发送时会在元素节点之间按照特定的顺序传播，这个传播过程即<strong>DOM事件流</strong></p><p>比如我们给一个div注册了点击事件：</p><ol><li>捕获阶段</li><li>当前目标阶段</li><li>冒泡阶段</li></ol><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0a7520f235ca4f7bbd57a98f024ce46c~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="DOM事件流"></p><ul><li><strong>事件捕获：</strong> IE最早提出的，事件开始由最具体的元素接受，然后逐级向上传播到DOM最顶层节点的过程。 <ul><li><strong>即：从外向内找监听函数</strong></li></ul></li><li><strong>事件捕获：</strong>  网景公司最早提出的，由DOM最顶层节点开始，然后逐级向下传播到最具体的元素的过程。 <ul><li><strong>即：从内向外找监听函数</strong></li></ul></li></ul><p> <strong>举个栗子:</strong></p><p>我们向水里扔个石头，首先它会有个下降的过程、这个过程可以理解为捕获过程；之后会产生泡泡，然后漂流在水面上，这个过程相当于事件冒泡。</p><p><strong>代码验证:</strong></p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7dec9eb77df04f08ad1659637ebbdfc5~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="代码验证"></p><h3 id="特例"><a href="#特例" class="headerlink" title="特例"></a>特例</h3><p>如果只有一个div被监听了， fn函数分别在捕获节点和冒泡节点监听click事件。</p><pre><code class="hljs js">div.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>,f1)   <span class="hljs-comment">// 冒泡</span>div.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>,f2,<span class="hljs-literal">true</span>)   <span class="hljs-comment">// 捕获</span></code></pre><p>请问，谁先执行？<br>答案： 谁先监听谁先执行。</p><h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><pre><code class="hljs js">eventTarget.<span class="hljs-property">onclick</span> = <span class="hljs-title function_">funciton</span>(<span class="hljs-params">event</span>)&#123;<span class="hljs-comment">// 这个 evnet 就是事件对象，我比较喜欢缩写成 e </span>&#125;eventTarget.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>)&#123;<span class="hljs-comment">// 这个 evnet 就是事件对象，我比较喜欢缩写成 e </span>&#125;)</code></pre><p>这个 event 是个形参，系统会自动帮我们设定改为事件对象，不需要传递实参过去。</p><p>当我们注册事件时，event对象就会被系统自动创建，并依次传递给事件监听器（事件处理函数）</p><h3 id="e-target-和-e-currentTarget-的区别"><a href="#e-target-和-e-currentTarget-的区别" class="headerlink" title="e.target  和 e.currentTarget 的区别"></a>e.target  和 e.currentTarget 的区别</h3><ul><li><p><strong>e.target：</strong> 返回触发事件的对象。 <strong>即用户操作的对象</strong>。（假设：你点击了谁就是谁）</p></li><li><p><strong>e.currentTarget :</strong>  程序员监听的元素， <strong>即你绑定了谁就是谁</strong></p></li><li><p><strong>this就是e.currentTarget</strong></p></li></ul><p><strong>打印一下就知道咯：</strong></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/451d59bd14e3404daa3756da8d2bd884~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt=" e.target  和 e.currentTarget 的区别"></p><h3 id="事件对象阻止默认行为"><a href="#事件对象阻止默认行为" class="headerlink" title="事件对象阻止默认行为"></a>事件对象阻止默认行为</h3><p>捕获是不可以阻止，取消的， 冒泡可以。</p><ul><li><code>e.stopPropagation()</code>  可取消冒泡，浏览器就不再向上走了。</li><li><code>e.preventDefault()</code>可以取消默认事件</li></ul><h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h2><p><strong>原理</strong>：<br><code>不是每个子节点单独设置事件监听器，而是事件监听器设置在其父节点上，然后利用冒泡原理影响设置每个子节点。</code></p><p><strong>举个场景：</strong><br>比如给ul列表注册点击事件，然后利用事件对象的target来找到当前点击的li，因为点击了li，事件就会冒泡到ul身上，又因为ul有注册事件，就会触发事件监听器。</p><p><strong>作用：</strong> 这样我们只操作了一次DOM， <code>省内存、可以监听动态元素</code></p><h3 id="如何监听一个不存在的元素？"><a href="#如何监听一个不存在的元素？" class="headerlink" title="如何监听一个不存在的元素？"></a>如何监听一个不存在的元素？</h3><p>可以利用事件委托，监听的父元素即可。</p><p><strong>代码展示：</strong><br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ccd5af8ac2434fbc98fb6549bcd0dfb9~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="事件委托"></p><h2 id="封装事件委托"><a href="#封装事件委托" class="headerlink" title="封装事件委托"></a>封装事件委托</h2><p><strong>要求：</strong><br>写出一个函数 <code>on(&#39;click&#39;,&#39;#div1&#39;,&#39;button&#39;,fn)</code>   当用户点击<code>#div1</code>的button元素时，调用fn函数。要求用事件委托。</p><p><strong>代码展示：</strong><br><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e552062e345a44c69bcaa5a2774c1710~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif"></p>]]></content>
    
    
    <categories>
      
      <category>DOM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>以jQuery的设计思想封装DOM(总结)</title>
    <link href="/2020/12/09/30-%E4%BB%A5jQuery%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E5%B0%81%E8%A3%85DOM/"/>
    <url>/2020/12/09/30-%E4%BB%A5jQuery%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E5%B0%81%E8%A3%85DOM/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>实现了用JQuery的设计思想去封装DOM。</p><p><strong>源代码链接：</strong> <a href="https://github.com/wangpf1129/jQuery-dom/blob/master/src/jquery.js">https://github.com/wangpf1129/jQuery-dom/blob/master/src/jquery.js</a></p><h2 id="jQuery的思想"><a href="#jQuery的思想" class="headerlink" title="jQuery的思想"></a>jQuery的思想</h2><p>jQuery的基本设计思想就是：<code>选择某个网页元素，对其进行某种操作。</code></p><p>八个字可以概括：<code>选取元素，对其操作。</code></p><h2 id="jQuery获取网页元素思想"><a href="#jQuery获取网页元素思想" class="headerlink" title="jQuery获取网页元素思想"></a>jQuery获取网页元素思想</h2><p>使用jQuery的第一步，就是要得到你选中的元素，放在jQuery()（或者$()）里面。</p><p><strong>实现方法:</strong> 使用重载设计模式获取对应的元素，利用闭包，在调用方法时使用到<code>elements</code></p><p><strong>代码展示：</strong></p><pre><code class="hljs js">winddow.<span class="hljs-property">$</span> = <span class="hljs-variable language_">window</span>.<span class="hljs-property">jQuery</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">selectorOrArray</span>) &#123;  <span class="hljs-keyword">let</span> elements = <span class="hljs-literal">null</span>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> selectorOrArray === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;    elements = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(selectorOrArray)  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (selectorOrArray <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span>) &#123;    elements = selectorOrArray  &#125;  <span class="hljs-keyword">let</span> api = &#123;    <span class="hljs-title function_">find</span>(<span class="hljs-params">selector</span>) &#123;      <span class="hljs-keyword">let</span> array = [];      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; elements.<span class="hljs-property">length</span>; i++) &#123;        <span class="hljs-keyword">const</span> elements2 = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(elements[i].<span class="hljs-title function_">querySelectorAll</span>(selector));        array.<span class="hljs-title function_">push</span>(...elements2);      &#125;      array.<span class="hljs-property">oldThis</span> = <span class="hljs-variable language_">this</span>;       <span class="hljs-keyword">return</span> <span class="hljs-title function_">jQuery</span>(array);    &#125;,    <span class="hljs-title function_">addClass</span>(<span class="hljs-params">className</span>) &#123;&#125;,  &#125;;  <span class="hljs-keyword">return</span> api;&#125;;</code></pre><h2 id="jQuery的链式操作实现思想"><a href="#jQuery的链式操作实现思想" class="headerlink" title="jQuery的链式操作实现思想"></a>jQuery的链式操作实现思想</h2><p><strong>链式操作</strong>: 选中网页元素以后，可以对它进行一系列操作，并且所有操作可以连接在一起，以链条的形式写出来.</p><pre><code class="hljs js">$(<span class="hljs-string">&#x27;div&#x27;</span>).<span class="hljs-title function_">find</span>(<span class="hljs-string">&#x27;h3&#x27;</span>).<span class="hljs-title function_">eq</span>(<span class="hljs-number">2</span>).<span class="hljs-title function_">html</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>);</code></pre><p><strong>实现思想：</strong> 原理在于于每一步的jQuery操作，返回的都是一个新的jQuery对象。</p><p><strong>代码展示（以find方法举例）：</strong></p><pre><code class="hljs js"><span class="hljs-title function_">find</span>(<span class="hljs-params">selector</span>) &#123;  <span class="hljs-keyword">let</span> array = []  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">elements</span>.<span class="hljs-property">length</span>; i++) &#123;    <span class="hljs-keyword">const</span> elements2 = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">elements</span>[i]      .<span class="hljs-title function_">querySelectorAll</span>(selector))    array = array.<span class="hljs-title function_">concat</span>(elements2)  &#125;  <span class="hljs-comment">//  将当前的对象存放在array里</span>  array.<span class="hljs-property">oldThis</span> = <span class="hljs-variable language_">this</span>  <span class="hljs-comment">// 然后在返回一个新的jQuery对象， 防止污染</span>  <span class="hljs-comment">// 如果直接把数组赋值给elements返回的话，会污染到addClass方法</span>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">jQuery</span>(array)&#125;,</code></pre><h2 id="把方法放在原型上的实现思想"><a href="#把方法放在原型上的实现思想" class="headerlink" title="把方法放在原型上的实现思想"></a>把方法放在原型上的实现思想</h2><p><strong>优点：</strong> </p><ul><li>把方法都移到jQuery原型身上，这样每次创建一个jQuery对象时，就不会再去开一块内存存放方法了。</li><li>所有创建的jQuery对象中的方法都放在原型上，这样省内存。</li></ul><p><strong>代码展示：</strong></p><pre><code class="hljs js"><span class="hljs-variable language_">window</span>.<span class="hljs-property">$</span> = <span class="hljs-variable language_">window</span>.<span class="hljs-property">jQuery</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">selectorOrArray</span>) &#123;  <span class="hljs-keyword">let</span> elements = <span class="hljs-literal">null</span>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> selectorOrArray === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;    elements = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(selectorOrArray)  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (selectorOrArray <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span>) &#123;    elements = selectorOrArray  &#125;  <span class="hljs-keyword">const</span> api = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(jQuery.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>) <span class="hljs-comment">// 创建一个对象，这个对象的__proto__为括号里的</span>  <span class="hljs-comment">// Object.assign方法就是把&#123;&#125;中的对象都赋值给api</span>  <span class="hljs-comment">// 相当于 api.elements = elements</span>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(api, &#123;    <span class="hljs-attr">elements</span>: elements,    <span class="hljs-comment">// 把oldThis 存在这个对象里。 要不然别的方法访问不到</span>    <span class="hljs-comment">// find中返回的是新的jQuery对象，而selectorOrArray是有oldThis这个属性的</span>    <span class="hljs-attr">oldThis</span>: selectorOrArray.<span class="hljs-property">oldThis</span>,  &#125;)  <span class="hljs-keyword">return</span> api&#125;jQuery.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = &#123;  <span class="hljs-attr">constructor</span>: jQuery,  <span class="hljs-title function_">addClass</span>(<span class="hljs-params">className</span>) &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">elements</span>.<span class="hljs-property">length</span>; i++) &#123;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">elements</span>[i].<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(className)    &#125;    <span class="hljs-comment">// 要求返回this 的原因是因为能够链式操作</span>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>  &#125;,  <span class="hljs-title function_">find</span>(<span class="hljs-params">selector</span>) &#123;&#125;,  <span class="hljs-title function_">end</span>(<span class="hljs-params"></span>) &#123;&#125;,  <span class="hljs-title function_">each</span>(<span class="hljs-params">fn</span>) &#123;&#125;,  <span class="hljs-title function_">print</span>(<span class="hljs-params"></span>) &#123;&#125;,  <span class="hljs-title function_">parent</span>(<span class="hljs-params"></span>) &#123;&#125;,  <span class="hljs-title function_">children</span>(<span class="hljs-params"></span>) &#123;&#125;,  <span class="hljs-title function_">siblings</span>(<span class="hljs-params"></span>) &#123;&#125;,  <span class="hljs-title function_">next</span>(<span class="hljs-params"></span>) &#123;,  <span class="hljs-title function_">prev</span>(<span class="hljs-params"></span>) &#123;&#125;,&#125;</code></pre><h2 id="所以jQuery-是构造函数吗？"><a href="#所以jQuery-是构造函数吗？" class="headerlink" title="所以jQuery 是构造函数吗？"></a>所以jQuery 是构造函数吗？</h2><ul><li>不是： 因为它没有 new jQuery() 来构造出一个对象。</li><li>是：   因为jQuery函数就是构造出了一个对象。</li></ul><h2 id="最后的总结"><a href="#最后的总结" class="headerlink" title="最后的总结"></a>最后的总结</h2><p>通过这次实现，了解了什么是设计模式。 </p><p>设计模式其实就是一套反复使用的通用代码取个专业性的名字。</p><p>我们不需要刻意的使用设计模式，而是在写完代码后知道这个是属于哪种设计模式。</p>]]></content>
    
    
    <categories>
      
      <category>jQuery</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>手写DOM</title>
    <link href="/2020/12/06/29-%E6%89%8B%E5%86%99DOM/"/>
    <url>/2020/12/06/29-%E6%89%8B%E5%86%99DOM/</url>
    
    <content type="html"><![CDATA[<h1 id="手写DOM库"><a href="#手写DOM库" class="headerlink" title="手写DOM库"></a>手写DOM库</h1><p>因为DOM原生API太难用了<br><a href="https://github.com/wangpf1129/DOM-Library/blob/master/src/dom.js">源代码链接</a></p><h2 id="对象风格"><a href="#对象风格" class="headerlink" title="对象风格"></a>对象风格</h2><ul><li>window.dom  是我们提供的全局对象</li></ul><h2 id="增加节点"><a href="#增加节点" class="headerlink" title="增加节点"></a>增加节点</h2><pre><code class="hljs js">dom.<span class="hljs-title function_">append</span>(parent,child)  <span class="hljs-comment">// 用于新增儿子节点</span></code></pre><pre><code class="hljs js">dom.<span class="hljs-title function_">wrap</span>(<span class="hljs-string">`&lt;div&gt;&lt;/div&gt;`</span>)   <span class="hljs-comment">// 用于新增爸爸节点</span></code></pre><h3 id="dom-create-函数"><a href="#dom-create-函数" class="headerlink" title="dom.create 函数"></a>dom.create 函数</h3><pre><code class="hljs js">dom.<span class="hljs-title function_">create</span>(<span class="hljs-string">`&lt;div&gt;&lt;span&gt;hi&lt;/span&gt;&lt;/div&gt;`</span>) <span class="hljs-comment">// 用于创建节点</span></code></pre><ul><li>一般我们创造节点的目的就是在别的节点中插入此节点，</li><li>那么我要封装一个 以输入 <code>html格式的</code>  的 create函数</li><li>能够在创造节点的同时在里面加一些其他节点</li><li>传入的字符串要是以有标签的 以html的形式来</li></ul><p><strong>dom.create源代码</strong></p><pre><code class="hljs js"><span class="hljs-title function_">create</span>(<span class="hljs-params">string</span>) &#123;    <span class="hljs-comment">// 创建容器    template标签可以容纳任意元素</span>    <span class="hljs-keyword">const</span> container = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;template&#x27;</span>)    <span class="hljs-comment">// 要trim，防止拿到空字符</span>    container.<span class="hljs-property">innerHTML</span> = string.<span class="hljs-title function_">trim</span>()    <span class="hljs-comment">// 必须要 使用 .content  要不然拿不到</span>    <span class="hljs-keyword">return</span> container.<span class="hljs-property">content</span>.<span class="hljs-property">firstChild</span>    <span class="hljs-comment">// 或者</span>    <span class="hljs-comment">// container.innerHTML = string</span>    <span class="hljs-comment">// return container.content.children[0]</span>  &#125;</code></pre><p><strong>示例</strong></p><pre><code class="hljs js"><span class="hljs-keyword">const</span> div = dom.<span class="hljs-title function_">create</span>(<span class="hljs-string">&#x27;&lt;div&gt;&lt;span&gt;hello&lt;/span&gt;&lt;/div&gt;&#x27;</span>)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(div);</code></pre><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/36537b52b1f34ae8a5b6fcbc0ef2b6c4~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif"></p><h3 id="dom-after-函数"><a href="#dom-after-函数" class="headerlink" title="dom.after 函数"></a>dom.after 函数</h3><blockquote><p> 由于dom中的api由于只有添加前面的节点的方法，如果想要往某个节点的后面插入节点非常的费劲</p></blockquote><pre><code class="hljs js">dom.<span class="hljs-title function_">after</span>(node,newNode)     <span class="hljs-comment">// 用于新增下一个（弟弟）节点</span></code></pre><p><strong>dom.after  源代码</strong></p><blockquote><p>这里不比担心 如果 node 这个节点是最后一个节点怎么办。   即使为null，依然能插入的 </p></blockquote><pre><code class="hljs js"><span class="hljs-title function_">after</span>(<span class="hljs-params">node, newNode</span>) &#123;   <span class="hljs-comment">// 找到此节点的爸爸然后调用insertBefore（插入某个节点的前面）方法，</span>   <span class="hljs-comment">//把 newNode 插入到下一个节点的前面</span>   <span class="hljs-keyword">return</span> node.<span class="hljs-property">parentNode</span>.<span class="hljs-title function_">insertBefore</span>(newNode, node.<span class="hljs-property">nextSibling</span>) &#125;</code></pre><p><strong>示例</strong><br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa16a738b5f34d46966261afd6b3dace~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif"></p><h3 id="dom-before-函数"><a href="#dom-before-函数" class="headerlink" title="dom.before 函数"></a>dom.before 函数</h3><blockquote><p>这个方法和 dom.after 方法思路一致，</p></blockquote><pre><code class="hljs js">dom.<span class="hljs-title function_">before</span>(node,node2)   <span class="hljs-comment">// 用于新增上一个(哥哥)节点</span></code></pre><p><strong>dom.before 源代码</strong></p><pre><code class="hljs js"><span class="hljs-title function_">before</span>(<span class="hljs-params">node, newNode</span>) &#123;    <span class="hljs-comment">// 正常的返回DOM原生的添加前面的节点的方法即可</span>    <span class="hljs-keyword">return</span> node.<span class="hljs-property">parentNode</span>.<span class="hljs-title function_">insertBefore</span>(newNode, <span class="hljs-title class_">Node</span>)  &#125;</code></pre><h3 id="dom-append-函数"><a href="#dom-append-函数" class="headerlink" title="dom.append 函数"></a>dom.append 函数</h3><pre><code class="hljs js">dom.<span class="hljs-title function_">append</span>(parent,child)  <span class="hljs-comment">// 用于新增儿子节点</span></code></pre><p><strong>dom.append 源代码</strong></p><pre><code class="hljs js"><span class="hljs-title function_">append</span>(<span class="hljs-params">parent, node</span>) &#123;  <span class="hljs-keyword">return</span> parent.<span class="hljs-title function_">appendChild</span>(node)&#125;</code></pre><h3 id="dom-wrap函数"><a href="#dom-wrap函数" class="headerlink" title="dom.wrap函数"></a>dom.wrap函数</h3><blockquote><p>实现思路:     先把这个节点先从DOM树中移出来，把原来的位置插入新的(爸爸)节点，然后在这个爸爸节点中插入原来的节点</p></blockquote><pre><code class="hljs js">dom.<span class="hljs-title function_">wrap</span>(<span class="hljs-string">`&lt;div&gt;&lt;/div&gt;`</span>)   <span class="hljs-comment">// 用于添加在此节点外面套一个节点   (爸爸)节点</span></code></pre><p><strong>dom.wrap 源代码</strong></p><pre><code class="hljs js"><span class="hljs-title function_">wrap</span>(<span class="hljs-params">node, newNode</span>) &#123;  <span class="hljs-comment">// 先把newNode放在node节点的前面   后面也行</span>  dom.<span class="hljs-title function_">before</span>(node, newNode)  <span class="hljs-comment">// 然后把node节点放在newNode里面</span>  dom.<span class="hljs-title function_">append</span>(newNode, node)&#125;</code></pre><p><strong>实现思路图：</strong><br><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/60febc04d6834004ab09609d6786a3be~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="dom.wrap思路图"></p><p><strong>示例：</strong><br><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13007f4503b94595869b700d5781008a~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="示例"></p><h2 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h2><ul><li><pre><code class="js">dom.remove(node) // 用于删除节点<pre><code class="hljs autohotkey">- ```js  dom.empty(parent)  // 用于删除后代</code></pre></code></pre></li></ul><h3 id="dom-remove-函数"><a href="#dom-remove-函数" class="headerlink" title="dom.remove 函数"></a>dom.remove 函数</h3><blockquote><p>用法： 删除某一个节点，并返回这个节点</p><p>思路 ： 让他的爸爸删除他的儿子。  </p></blockquote><p><strong>源代码</strong></p><pre><code class="hljs js"><span class="hljs-title function_">remove</span>(<span class="hljs-params">node</span>) &#123;  node.<span class="hljs-property">parentNode</span>.<span class="hljs-title function_">removeChild</span>(node)  <span class="hljs-comment">//返回删除的节点</span>  <span class="hljs-keyword">return</span> node &#125;</code></pre><h3 id="dom-empty-函数"><a href="#dom-empty-函数" class="headerlink" title="dom.empty 函数"></a>dom.empty 函数</h3><blockquote><p>用法： 删除这个节点的所有子代</p><p>思路:   遍历删除它的所有子节点，并返回 删除的节点</p></blockquote><blockquote><p>不能用for循环的原因：因为每次 dom.remove 删除的时候，它的长度就会随之改变， 而我们又在for循环它，因此我测试时候会出现bug，因此我们选择使用 while 循环 解决。</p></blockquote><p><strong>源代码</strong></p><pre><code class="hljs js"><span class="hljs-title function_">empty</span>(<span class="hljs-params">node</span>) &#123;  <span class="hljs-keyword">const</span> firstChild = node.<span class="hljs-property">firstChild</span>  <span class="hljs-keyword">while</span> (firstChild) &#123;     array.<span class="hljs-title function_">push</span>(dom.<span class="hljs-title function_">remove</span>(node.<span class="hljs-property">firstChild</span>))  &#125;  <span class="hljs-comment">// 返回删除的节点</span>  <span class="hljs-keyword">return</span> array&#125;</code></pre><p><strong>示例</strong></p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/018c6fbad15345c5bfb5a666d0f224ee~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="删除节点"></p><h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><ul><li><pre><code class="js">dom.attr(node,&#39;title&#39;,&#39;hello&#39;)  //将node节点中的 title 属性值改为 hello    用于读写属性,,dom.attr(node,&#39;title&#39;)  // 获取 node节点的title属性值<pre><code class="hljs xquery">- ```js  dom.<span class="hljs-type">text</span>(<span class="hljs-type">node</span>,<span class="hljs-string">&#x27;我是修改后的&#x27;</span>)  //将<span class="hljs-type">node</span>节点中的文本修改为xxxxx    用于读写文本内容  dom.<span class="hljs-type">text</span>(<span class="hljs-type">node</span>)   // 查看文本内容</code></pre></code></pre></li><li><pre><code class="js">dom.html(node,&#39;&lt;em&gt;我是修改后的&lt;/em&gt;&#39;)  //将node节点中的html元素内容修改为xxxx ,  用于读写html内容dom.html(node)  // 查看此节点中的html内容<pre><code class="hljs awk">- ```js  dom.style(node,&#123;color:<span class="hljs-string">&#x27;red&#x27;</span>&#125;)   <span class="hljs-regexp">//</span> 用于修改style样式</code></pre></code></pre></li><li><pre><code class="js">dom.class.add(node,&#39;btn&#39;)  // 用于添加class类名<pre><code class="hljs csharp">- ```js  dom.<span class="hljs-keyword">class</span>.<span class="hljs-keyword">remove</span>(node,<span class="hljs-string">&#x27;btn&#x27;</span>)   <span class="hljs-comment">// 用于删除class</span></code></pre></code></pre></li><li><pre><code class="js">dom.class.has(node,&#39;btn&#39;)  // 查看是否拥有类名<pre><code class="hljs awk">- ```js  dom.on(node,<span class="hljs-string">&#x27;click&#x27;</span>,fn) <span class="hljs-regexp">//</span> 用于添加事件监听</code></pre></code></pre></li><li><pre><code class="js">dom.off(node,&#39;click&#39;,fn)  // 用于删除事件监听<pre><code class="hljs node-repl">### dom.attr 函数<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">用法： 如果传入的是三个参数     设置/修改 该节点中的属性值和属性名 </span><span class="hljs-meta prompt_">&gt;</span><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">``</span><span class="hljs-string">`js</span></span><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">dom.attr(node,&#x27;title&#x27;,&#x27;hello&#x27;)// 传入三个参数，就设置它的属性名和属性值</span></span><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-string">dom.attr(node,&#x27;title&#x27;)    // 如果传入的是俩个参数    获取属性名</span></span></code></pre></code></pre></li></ul><p><strong>源代码</strong></p><pre><code class="hljs js"><span class="hljs-title function_">attr</span>(<span class="hljs-params">node, name, value</span>) &#123;  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span> === <span class="hljs-number">3</span>) &#123;    <span class="hljs-comment">// 设置该节点某个属性和属性值</span>    node.<span class="hljs-title function_">setAttribute</span>(name, value)  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span> === <span class="hljs-number">2</span>) &#123;    <span class="hljs-comment">// 查看该节点某个属性的值</span>    <span class="hljs-keyword">return</span> node.<span class="hljs-title function_">getAttribute</span>(name)  &#125;&#125;</code></pre><p><strong>示例</strong></p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/09d6fb8575c04d98bed9e14938761a80~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="示例"><br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d4e548da4e5c4ad9ba7180914f9c3892~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="示例"></p><h3 id="dom-text-函数"><a href="#dom-text-函数" class="headerlink" title="dom.text 函数"></a>dom.text 函数</h3><blockquote><p>用法  和 <code>innerText </code>一致</p></blockquote><p><strong>源代码</strong></p><pre><code class="hljs js"><span class="hljs-title function_">text</span>(<span class="hljs-params">node, string</span>) &#123;  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span> === <span class="hljs-number">2</span>) &#123;   <span class="hljs-comment">// 重载</span>    <span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;innerText&#x27;</span> <span class="hljs-keyword">in</span> node) &#123;  <span class="hljs-comment">// 适配 </span>      node.<span class="hljs-property">innerText</span> = string    &#125; <span class="hljs-keyword">else</span> &#123;      node.<span class="hljs-property">textContent</span> = string    &#125;  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span> === <span class="hljs-number">1</span>) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;innerText&#x27;</span> <span class="hljs-keyword">in</span> node) &#123;      <span class="hljs-keyword">return</span> node.<span class="hljs-property">innerText</span>    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">return</span> node.<span class="hljs-property">textContent</span>    &#125;  &#125;&#125;</code></pre><p><strong>示例</strong></p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/52ce828d8a844f4e96acb44e565a8f87~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="dom.text示例"></p><h3 id="dom-html-函数"><a href="#dom-html-函数" class="headerlink" title="dom.html 函数"></a>dom.html 函数</h3><blockquote><p>用法和 innerHTML 一致</p></blockquote><p><strong>源代码</strong></p><pre><code class="hljs js"><span class="hljs-title function_">html</span>(<span class="hljs-params">node, string</span>) &#123;   <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span> === <span class="hljs-number">2</span>) &#123;     node.<span class="hljs-property">innerHTML</span> = string   &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span> === <span class="hljs-number">1</span>) &#123;     <span class="hljs-keyword">return</span> node.<span class="hljs-property">innerHTML</span>   &#125; &#125;</code></pre><h3 id="dom-style-函数"><a href="#dom-style-函数" class="headerlink" title="dom.style 函数"></a>dom.style 函数</h3><blockquote><p>原生DOM操作style的写法是： </p><pre><code class="hljs js">xxx.<span class="hljs-property">style</span>.<span class="hljs-property">color</span> = <span class="hljs-string">&#x27;red&#x27;</span>  或者  xxx.<span class="hljs-property">style</span>[<span class="hljs-string">&#x27;color&#x27;</span>]  = <span class="hljs-string">&#x27;red&#x27;</span></code></pre><p>我封装的修饰style 的写法：</p><pre><code class="hljs js">dom.<span class="hljs-title function_">style</span>(xxx,<span class="hljs-string">&#x27;color&#x27;</span>,<span class="hljs-string">&#x27;red&#x27;</span>)<span class="hljs-comment">// 使用字符串的形式 来修改样式</span>dom.<span class="hljs-title function_">style</span>(xxx,&#123;<span class="hljs-attr">color</span>:<span class="hljs-string">&#x27;red&#x27;</span>&#125;)        <span class="hljs-comment">// 使用对象的形式   来修改样式</span>dom.<span class="hljs-title function_">style</span>(xxx,<span class="hljs-string">&#x27;color&#x27;</span>)    <span class="hljs-comment">// 查看样式的内容</span></code></pre></blockquote><blockquote><p>思路: 我们可以引用原生的第二种写法 ，遍历属性值key‘，用xxx.style[key]实现  ， 此时的color 是一个变量需要从我们传入的对象中获取。 为什么不用  style.color=’red’ 的原因是因为 对象的属性值是字符串。</p></blockquote><p><strong>源代码</strong></p><pre><code class="hljs js"><span class="hljs-title function_">style</span>(<span class="hljs-params">node, name, value</span>) &#123;  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span> === <span class="hljs-number">3</span>) &#123;      <span class="hljs-comment">// dom.style(xxx,&#x27;color&#x27;,&#x27;red&#x27;)</span>    node.<span class="hljs-property">style</span>[name] = value  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span> === <span class="hljs-number">2</span>) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> name === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;      <span class="hljs-comment">// dom.style(xxx,&#x27;color&#x27;)</span>      <span class="hljs-keyword">return</span> node.<span class="hljs-property">style</span>[name]    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (name <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>) &#123;      <span class="hljs-comment">// dom.style(xxx,&#123;color:&#x27;red&#x27;&#125;)</span>      <span class="hljs-keyword">const</span> object = name      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> object) &#123;        <span class="hljs-comment">// 不能用 style.key 是因为 key是变量</span>        node.<span class="hljs-property">style</span>[key] = object[key]      &#125;    &#125;  &#125;&#125;</code></pre><p><strong>示例</strong></p><p><strong>使用对象的形式来修改样式：</strong><br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f2c571b3928e40159429a2bec14f2db4~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="示例1"></p><p><strong>使字符串的形式来修改样式</strong></p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e2cc02b488642babab86bccdf505df1~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="示例2"  /><h3 id="dom-class-函数"><a href="#dom-class-函数" class="headerlink" title="dom.class 函数"></a>dom.class 函数</h3><blockquote><p>用法：</p><pre><code class="hljs js">dom.<span class="hljs-property">class</span>.<span class="hljs-title function_">add</span>(test, <span class="hljs-string">&#x27;red&#x27;</span>)   <span class="hljs-comment">// 添加类名</span>dom.<span class="hljs-property">class</span>.<span class="hljs-title function_">remove</span>(test, <span class="hljs-string">&#x27;red&#x27;</span>)   <span class="hljs-comment">//  删除类名</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dom.<span class="hljs-property">class</span>.<span class="hljs-title function_">has</span>(test, <span class="hljs-string">&#x27;red&#x27;</span>));   <span class="hljs-comment">// 查看类名</span></code></pre></blockquote><blockquote><p>思路：首先在class 对象中 创建三个不同功能的方法。 然后封装一下原生的DOM即可。</p></blockquote><p><strong>源代码</strong></p><pre><code class="hljs js"><span class="hljs-attr">class</span>: &#123;  <span class="hljs-title function_">add</span>(<span class="hljs-params">node, className</span>) &#123;    node.<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(className)  &#125;,  <span class="hljs-title function_">remove</span>(<span class="hljs-params">node, className</span>) &#123;    node.<span class="hljs-property">classList</span>.<span class="hljs-title function_">remove</span>(className)  &#125;,  <span class="hljs-title function_">has</span>(<span class="hljs-params">node, className</span>) &#123;    <span class="hljs-keyword">return</span> node.<span class="hljs-property">classList</span>.<span class="hljs-title function_">contains</span>(className)  &#125;&#125;</code></pre><p><strong>示例</strong></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/270cf57e749d4750bc25cee4c5e3e17f~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="示例1"></p><h3 id="dom-on-函数-和-dom-off-函数"><a href="#dom-on-函数-和-dom-off-函数" class="headerlink" title="dom.on 函数 和  dom.off 函数"></a>dom.on 函数 和  dom.off 函数</h3><blockquote><p>用法：</p><pre><code class="hljs js">dom.<span class="hljs-title function_">on</span>(test, <span class="hljs-string">&#x27;click&#x27;</span>, fn)  <span class="hljs-comment">// fn是函数，  添加了点击事件</span>dom.<span class="hljs-title function_">off</span>(test,<span class="hljs-string">&#x27;click&#x27;</span>,fn) <span class="hljs-comment">// 移除点击事件</span></code></pre></blockquote><blockquote><p>思路： 封装一下原生的DOM的addEventListener即可。</p></blockquote><p><strong>源代码</strong></p><pre><code class="hljs js"><span class="hljs-title function_">on</span>(<span class="hljs-params">node, eventName, fn</span>) &#123;   node.<span class="hljs-title function_">addEventListener</span>(eventName,fn) &#125;, <span class="hljs-title function_">off</span>(<span class="hljs-params">node, eventName, fn</span>) &#123;    node.<span class="hljs-title function_">removeEventListener</span>(eventName,fn) &#125;</code></pre><p><strong>示例</strong></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ab7686a5a6a4ca6877f2aca3fc353de~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="示例1"></p><h2 id="查-（获取元素）"><a href="#查-（获取元素）" class="headerlink" title="查  （获取元素）"></a>查  （获取元素）</h2><ul><li><pre><code class="js">dom.find(&#39;选择器&#39;)  // 用于获取标签或标签们<pre><code class="hljs autohotkey">- ```js  dom.parent(node)  // 用于获取父元素</code></pre></code></pre></li><li><pre><code class="js">dom.children(node)  // 用于获取子元素<pre><code class="hljs autohotkey">- ```js  dom.siblings(node)  //用于获取兄弟姐妹元素</code></pre></code></pre></li><li><pre><code class="js">dom.next(node)  // 用于获取弟弟<pre><code class="hljs autohotkey">- ```js  dom.previous(node)  // 用于获取哥哥</code></pre></code></pre></li><li><pre><code class="js">dom.each(nodes,fn)  // 用于遍历所有节点<pre><code class="hljs crmsh">- ```js  dom.index(<span class="hljs-keyword">node</span><span class="hljs-title">)  // 用于获取索引值为x</span> 的元素</code></pre></code></pre></li></ul><h3 id="dom-find-函数"><a href="#dom-find-函数" class="headerlink" title="dom.find 函数"></a>dom.find 函数</h3><blockquote><p>用法 和  document.querySelectorAll()  一致</p></blockquote><p><strong>源代码</strong></p><pre><code class="hljs js"><span class="hljs-title function_">find</span>(<span class="hljs-params">selector,scope</span>) &#123;   <span class="hljs-keyword">return</span> (scope || <span class="hljs-variable language_">document</span>).<span class="hljs-title function_">querySelectorAll</span>(selector) &#125;</code></pre><p><strong>示例：</strong></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cfe498f0772a40a88159dc2fbdda663d~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="dom.find()示例"></p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a7e2cd3859b43bdadb32899d209fd54~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="dom.find()示例2"></p><h3 id="dom-parent-函数-和-dom-children-函数"><a href="#dom-parent-函数-和-dom-children-函数" class="headerlink" title="dom.parent  函数 和 dom.children 函数"></a>dom.parent  函数 和 dom.children 函数</h3><blockquote><p>用法: </p><pre><code class="hljs js">dom.<span class="hljs-title function_">parent</span>(node)  <span class="hljs-comment">// 用于获取父元素</span>dom.<span class="hljs-title function_">children</span>(node)  <span class="hljs-comment">// 用于获取子元素</span></code></pre></blockquote><p><strong>源代码</strong></p><pre><code class="hljs js"><span class="hljs-title function_">parent</span>(<span class="hljs-params">node</span>) &#123;   <span class="hljs-keyword">return</span> node.<span class="hljs-property">parentNode</span> &#125;,      <span class="hljs-title function_">children</span>(<span class="hljs-params">node</span>) &#123;   <span class="hljs-keyword">return</span> node.<span class="hljs-property">children</span>  &#125;</code></pre><h3 id="dom-siblings-函数"><a href="#dom-siblings-函数" class="headerlink" title="dom.siblings 函数"></a>dom.siblings 函数</h3><blockquote><p>用法：</p><pre><code class="hljs js">dom.<span class="hljs-title function_">siblings</span>(node)  <span class="hljs-comment">//用于获取兄弟姐妹元素 (除了自己)</span></code></pre></blockquote><blockquote><p>思路：  用 node.parentNode.children 获取所有子元素， 因为获取的伪数组， 转换为数组后过滤掉自己。</p></blockquote><p><strong>源代码</strong></p><pre><code class="hljs js"><span class="hljs-title function_">siblings</span>(<span class="hljs-params">node</span>) &#123;  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(node.<span class="hljs-property">parentNode</span>.<span class="hljs-property">children</span>)    .<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">n</span> =&gt;</span> n !== node)&#125;,</code></pre><p><strong>dom.parent  、dom.children  、 dom.siblings  示例</strong></p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1928c301d97e404ba905ef2ac1e54807~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="dom.parent  、dom.children  、 dom.siblings  示例"></p><h3 id="dom-next-函数-和-dom-previous-函数"><a href="#dom-next-函数-和-dom-previous-函数" class="headerlink" title="dom.next 函数  和 dom.previous 函数"></a>dom.next 函数  和 dom.previous 函数</h3><blockquote><p>用法：</p><pre><code class="hljs js">dom.<span class="hljs-title function_">next</span>(node)  <span class="hljs-comment">// 用于获取下一个节点       （弟弟）节点</span>dom.<span class="hljs-title function_">previous</span>(node)   <span class="hljs-comment">// 用于获取上一个节点      （哥哥）节点</span></code></pre></blockquote><blockquote><p>思路： 我们使用 node.nextSibing 时 可以会返回 文本节点， 这时我们需要排除文本节点即可  (nodeType 为1是元素节点、为3 是文本节点)       、    dom.previous的思路也是一样的</p></blockquote><p><strong>源代码</strong></p><pre><code class="hljs js"><span class="hljs-title function_">next</span>(<span class="hljs-params">node</span>) &#123;   <span class="hljs-keyword">let</span> x = node.<span class="hljs-property">nextSibling</span>   <span class="hljs-keyword">while</span> (x &amp;&amp; x.<span class="hljs-property">nodeType</span> === <span class="hljs-number">3</span>) &#123; <span class="hljs-comment">//  1是元素节点， 3是文本节点</span>     x = x.<span class="hljs-property">nextSibling</span>   &#125;   <span class="hljs-keyword">return</span> x &#125;, <span class="hljs-title function_">previous</span>(<span class="hljs-params">node</span>) &#123;   <span class="hljs-keyword">let</span> x = node.<span class="hljs-property">previousSibling</span>   <span class="hljs-keyword">while</span> (x &amp;&amp; x.<span class="hljs-property">nodeType</span> === <span class="hljs-number">3</span>) &#123; <span class="hljs-comment">//  1是元素节点， 3是文本节点</span>     x = x.<span class="hljs-property">previousSibling</span>   &#125;   <span class="hljs-keyword">return</span> x &#125;</code></pre><p><strong>示例</strong></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff9f33b4913f4ddaa9aeabd6fb12736e~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="dom.next示例"></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c8b6507260124bbe84d8b542eaa30ef9~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="dom.previous示例"></p><h3 id="dom-each-函数"><a href="#dom-each-函数" class="headerlink" title="dom.each 函数"></a>dom.each 函数</h3><blockquote><p>用法： 遍历每个元素，使他做对应的事</p><pre><code class="hljs js">dom.<span class="hljs-title function_">each</span>(nodes,fn)  <span class="hljs-comment">// 用于遍历所有节点</span></code></pre></blockquote><p><strong>源代码</strong></p><pre><code class="hljs js"><span class="hljs-title function_">each</span>(<span class="hljs-params">nodeList, fn</span>) &#123;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nodeList.<span class="hljs-property">length</span>; i++) &#123;    fn.<span class="hljs-title function_">call</span>(<span class="hljs-literal">null</span>, nodeList[i])  &#125;&#125;</code></pre><p><strong>示例：</strong></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/308ff6e8cb4c4594a33b6dc8919ed0ac~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="dom.each"></p><h3 id="dom-index-函数"><a href="#dom-index-函数" class="headerlink" title="dom.index 函数"></a>dom.index 函数</h3><blockquote><p>用法： 返当前节点在父节点内的索引值</p><pre><code class="hljs js">dom.<span class="hljs-title function_">index</span>(node)  <span class="hljs-comment">// 返回当前节点在它父节点中的索引值</span></code></pre></blockquote><blockquote><p>思路： 获取自己的父节点的所有子节点, 然后遍历， 如果遍历的子节点是自己，就返回 i</p></blockquote><p><strong>源代码</strong></p><pre><code class="hljs js"><span class="hljs-title function_">index</span>(<span class="hljs-params">node</span>) &#123;  <span class="hljs-keyword">const</span> list = dom.<span class="hljs-title function_">children</span>(node.<span class="hljs-property">parentNode</span>)  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; list.<span class="hljs-property">length</span>; i++) &#123;    <span class="hljs-keyword">if</span> (list[i] === node) &#123;      <span class="hljs-keyword">return</span> i    &#125;  &#125;&#125;</code></pre><p><strong>示例：</strong></p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/550cdf330dc04fd8bdcd1b0e6edfd958~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="dom.index "></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>你不知道的JavaScript</title>
    <link href="/2020/11/28/28-%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript/"/>
    <url>/2020/11/28/28-%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript/</url>
    
    <content type="html"><![CDATA[<h2 id="JavaScript是什么？"><a href="#JavaScript是什么？" class="headerlink" title="JavaScript是什么？"></a>JavaScript是什么？</h2><blockquote><p>JavaScript（通常缩写为JS）是一种高级的、解释型的编程语言。JavaScript是一门基于原型、函数先行的语言，是一门多范式的语言，它支持面向对象程序设计，命令式编程，以及函数式编程。它提供语法来操控文本、数组、日期以及正则表达式等，不支持I/O，比如网络、存储和图形等，但这些都可以由它的宿主环境提供支持。它已经由ECMA（欧洲电脑制造商协会）通过ECMAScript实现语言的标准化。它被世界上的绝大多数网站所使用，也被世界主流浏览器（Chrome、IE、Firefox、Safari、Opera）支持。</p></blockquote><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c11c9e3c05b74bcfa1f12f3170962df2~tplv-k3u1fbpfcp-zoom-1.image" srcset="/img/loading.gif" alt="JavaScript"></p><h2 id="JavaScript的诞生"><a href="#JavaScript的诞生" class="headerlink" title="JavaScript的诞生"></a>JavaScript的诞生</h2><p>　　它诞生于1995年，当时主要用于处理如今的“前端验证”，也就是说，在 JavaScript 没有问世之前，表单项的验证需要提交到服务器端，这在当时的网络情况下是一种极差的用户体验，然而浏览器鼻祖的公司 Netscape 决定开发一门语言用于解决这破事，然而就有了 LiveScript ，它是 JS 的前身，因为 Netscape 当时跟 Sun 公司合作联合开发的，Netscape 也想借当时 Java 的热度，所以索性把名字更换为 JavaScript，从此这门语言就引起了世人的注意。</p><p>　　然而，作为 Netscape 死对头的微软公司坐不住了，你整了一个 JavaScript，我就搞一个 JScript（轻吐槽一下，微软起步要在抄袭啊，人家的浏览器叫 Navigator，微软的浏览器就叫 Explorer ….），功能与 JavaScript 一致，所以这就导致了有标准不一致的 JS ，然而，将 JS 标准化就提到议程上了。1997年，JavaScript 1.1 作为蓝本交给了欧洲计算机制造商协会，由他们的技术委员会来制定标准，这个标准就是 ECMA-262，直到如今一共有7个版本（据说ES8也快出来了，嚯嚯~），也就是我们平时所认识的什么 ES5，ES6等等。</p><h2 id="Javascript的10个设计缺陷"><a href="#Javascript的10个设计缺陷" class="headerlink" title="Javascript的10个设计缺陷"></a>Javascript的10个设计缺陷</h2><ol><li><strong>不适合开发大型程序</strong>：Javascript没有名称空间（namespace），很难模块化；没有如何将代码分布在多个文件的规范；允许同名函数的重复定义，后面的定义可以覆盖前面的定义，很不利于模块化加载。</li><li><strong>非常小的标准库</strong>：Javascript提供的标准函数库非常小，只能完成一些基本操作，很多功能都不具备。</li><li><strong>null和undefined</strong>：null属于对象（object）的一种，意思是该对象为空；undefined则是一种数据类型，表示未定义。<pre><code class="hljs js"><span class="hljs-comment">// 两者非常容易混淆，但是含义完全不同。</span>　<span class="hljs-keyword">typeof</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// object</span>　<span class="hljs-keyword">typeof</span> <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// undefined</span></code></pre></li><li><strong>全局变量难以控制</strong>:Javascript的全局变量，在所有模块中都是可见的；任何一个函数内部都可以生成全局变量，这大大加剧了程序的复杂性。</li><li><strong>自动插入行尾分号</strong> ：Javascript的所有语句，都必须以分号结尾。但是，如果你忘记加分号，解释器并不报错，而是为你自动加上分号。有时候，这会导致一些难以发现的错误。</li><li><strong>加号运算符</strong>：+号作为运算符，有两个含义，可以表示数字与数字的和，也可以表示字符与字符的连接。</li><li><strong>NaN</strong>：NaN是一种数字，表示超出了解释器的极限。它有一些很奇怪的特性：</li><li><strong>数组和对象的区分</strong>：由于Javascript的数组也属于对象（object），所以要区分一个对象到底是不是数组，相当麻烦。</li><li><strong>== 和 ===</strong> ： ==用来判断两个值是否相等。当两个值类型不同时，会发生自动转换，得到的结果非常不符合直觉。</li><li><strong>基本类型的包装对象</strong> ： Javascript有三种基本数据类型：字符串、数字和布尔值。它们都有相应的建构函数，可以生成字符串对象、数字对象和布尔值对象。</li></ol><h2 id="为什么Javascript有设计缺陷"><a href="#为什么Javascript有设计缺陷" class="headerlink" title="为什么Javascript有设计缺陷"></a>为什么Javascript有设计缺陷</h2><ul><li><strong>设计阶段过于仓促</strong>， 因为Javascript的设计，其实只用了十天。</li><li><strong>没有先例</strong>，Javascript仍然是世界上唯一使用Prototype继承模型的主要语言。这使得它没有设计先例可以参考。</li><li><strong>过早的标准化</strong>  Javascript的发展非常快，根本没有时间调整设计。</li></ul><p>以上信息来自于：<a href="http://www.ruanyifeng.com/blog/2011/06/10_design_defects_in_javascript.html">阮一峰博客</a></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器渲染机制过程</title>
    <link href="/2020/11/20/27-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/"/>
    <url>/2020/11/20/27-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="以下是浏览器渲染机制必经过程"><a href="#以下是浏览器渲染机制必经过程" class="headerlink" title="以下是浏览器渲染机制必经过程"></a>以下是浏览器渲染机制必经过程</h2><ul><li>根据HTML构建HTML树（DOM）</li><li>根据CSS构建CSS树（CSSDOM）</li><li>将这俩棵树合并成一棵树（Reder Tree）</li><li>Latout 布局 （文档流、盒模型、计算大小和位置）</li><li>Paint 绘制 （把边框颜色、文字颜色、阴影等画出来）</li><li>Compose 合成 （根据层叠关系展示画面）</li></ul><h2 id="说一下这些步骤是什么样的（详细）"><a href="#说一下这些步骤是什么样的（详细）" class="headerlink" title="说一下这些步骤是什么样的（详细）"></a>说一下这些步骤是什么样的（详细）</h2><h3 id="Too-lang；don’t-read："><a href="#Too-lang；don’t-read：" class="headerlink" title="Too lang；don’t read："></a>Too lang；don’t read：</h3><ul><li>处理HTML并构建DOM树</li><li>处理CS并构建CSSDOM树</li><li>DOM 树 与CSSDOM 树 合并后形成渲染树</li><li>根据渲染树来布局 ，以计算每个节点的几何信息（布局会计算每个对象的精确位置和大小）</li><li>最后一步是绘制， 使用最终渲染树将像素渲染到屏幕上</li></ul><p>第一步是让浏览器将DOM和CSSDOM 合并成一个“渲染树”，收集页面上所有可以看见的DOM内容、以及每个节点所有的CSSDOM样式信息。</p><p>为构建渲染树，浏览器会完成下列工作：</p><ol><li>从DOM树的根节点开始遍历每个可见节点</li><li>对于每个可见节点，找到适配的CSSDOM规则并应用它们</li><li>发射可见节点，连同其内容和计算的样式</li></ol><p>最终输出的渲染同时包含了屏幕上的所有可见的内容和样式信息。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd76e0c6a88940dbb05d358c332f46f8~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="渲染树"></p><p><strong>有了渲染树，接下来的阶段就要进入 Layout布局 阶段,顾名思义，就是计算出每个节点在屏幕中的位置。</strong></p><ul><li>Layout 事件会在时间线中捕获渲染树构建以及位置和尺寸计算</li><li>布局完成后，浏览器会立即发出<code> Paint Setup</code> 和 <code>Paint</code> 事件，按照算出来的规则，将渲染树转换成屏幕上的像素</li></ul>]]></content>
    
    
    <categories>
      
      <category>浏览器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浏览器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>个人理解的CSS文档流</title>
    <link href="/2020/11/19/26-%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3%E7%9A%84CSS%E6%96%87%E6%A1%A3%E6%B5%81/"/>
    <url>/2020/11/19/26-%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3%E7%9A%84CSS%E6%96%87%E6%A1%A3%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h2 id="css文档流"><a href="#css文档流" class="headerlink" title="css文档流"></a>css文档流</h2><p>文档流，文档流，**<code>流</code>就是它最大的特点：<code>自适应</code>**。</p><p>那什么是文档流呢？ 顾名思义就是：像水流一样，倒入一个容器时，会自动充满容器。而css文档流的特性就是如此。</p><p>文档流有俩个比较重要的概念元素：<code>inline元素、block元素</code>，与之相对应的标签就是<code>span、div</code>。（还有一个是 inline-block 是前面俩个的结合）</p><p>那这俩个元素的区别在哪？  <code>inline元素</code>默认是水平排列。 而<code>block元素</code>默认会充满整个屏幕。你可以理解为<code>inline元素</code>就像是装着水的袋子（这个袋子的宽度会随着水的多少而发生变化）。<code>block元素</code>则像是一个装着水的瓶子（这个瓶子的宽度默认是整个屏幕。不管你瓶子中的水有多少，都会占满整个屏幕。）。</p><p>所以<strong>要记住的是这种代表文档流的元素默认宽度不是100%，而是width：auto，它们的margin、border、padding可以自动分配空间</strong></p><p>因此建议不要写width：100%。为什么不建议呢？那是因为一旦你给元素添加了宽度属性，它就会失去文档流。即使是width:100% ，也是会失去的。</p><p>一旦，我们设置了固定的宽度，它就会根据CSS的盒模型进行计算，便失去了文档流的特点：自动分配空间的流动性。</p><p>根据上段的理解，你可以知道它们的宽度是这样规定的：</p><ul><li>inline元素的宽度为内部inline元素和（不能有block元素），不能用width指定</li><li>block默认自动计算宽度，可用width指定</li><li>inline-block元素结合前两者的特点，可用width</li></ul><p>而高度的话，水就比较深了，这里不做过多的介绍，你可以直接记住下面的规则：</p><ul><li>inline 高度是由 line-height 间接确定，跟height无关</li><li>block 高度是由<strong>内部文档流元素决定</strong>（因为脱离文档流的元素不算），可以设置height</li><li>inline-block 跟 block 类似，可以设置height</li></ul><h2 id="“变态”情况："><a href="#“变态”情况：" class="headerlink" title="“变态”情况："></a>“变态”情况：</h2><p> <strong>1.写一个span 、div ，里面不写内容会出现什么情况？</strong></p><p>结果如下：<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d1123ef6cacb4eaf81e0dcfd685ffc74~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="结果"></p><p>由上图可见，span元素（inline元素）是有高度的！，所以可以证明的是它的高度是由line-height决定的。</p><p><strong>2.overflow 溢出问题</strong></p><p>当我给div（block元素）设置固定高度，但是内容却超出这个高度，就会出现如下情况</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8906035f86144d26b47595eb111b6a12~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="overflow 溢出问题"></p><p>那么该怎么解决呢？ <strong>用overflow</strong></p><ul><li><code>overflow:hidden </code> 干脆就直接让超出的内容隐藏了</li><li><code>overflow:auto </code>    不超出时，正常显示，超出时，就出现滚动条</li><li><code>overflow:scroll </code>   不建议使用，有auto好吗？ 它有的功能auto都有。</li><li>其他属性就不一一试了。</li></ul><h2 id="脱离文档流"><a href="#脱离文档流" class="headerlink" title="脱离文档流"></a>脱离文档流</h2><blockquote><p>先让我们回忆一下上文说到的文档流，block的高度是由内部文档流决定的，可以设置height，那么意思就是说有些元素是不在文档流中的。</p></blockquote><p>哪些元素可以脱离文档流呢？</p><ul><li>设置了 float</li><li>设置了 position:absolute/fixed</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>axios</title>
    <link href="/2020/09/26/25-axios/"/>
    <url>/2020/09/26/25-axios/</url>
    
    <content type="html"><![CDATA[<h1 id="axios-⭐"><a href="#axios-⭐" class="headerlink" title="axios ⭐"></a>axios ⭐</h1><blockquote><p>axios: ajax i/o system.</p></blockquote><ul><li><p><strong>功能特点</strong> ：</p><ul><li>在浏览器中发送 XMLHttpRequests 请求</li><li>在 node.js 中发送 http请求</li><li>支持 Promise API</li><li>拦截请求和响应</li><li>转换请求和响应数据</li></ul></li><li><p><strong>支持多种请求方式</strong></p><ul><li>axios(config)</li><li>axios.request(config)</li><li>axios.get(url[, config])</li><li>axios.delete(url[, config])</li><li>axios.head(url[, config])</li><li>axios.post(url[, data[, config]])</li><li>axios.put(url[, data[, config]])</li><li>axios.patch(url[, data[, config]])</li></ul></li></ul><h2 id="get-请求演示"><a href="#get-请求演示" class="headerlink" title="get 请求演示"></a>get 请求演示</h2><p><img src="https://img-blog.csdnimg.cn/20200926145610808.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Bmenp6eno=,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="get 请求演示"></p><h2 id="发送并发请求"><a href="#发送并发请求" class="headerlink" title="发送并发请求"></a>发送并发请求</h2><ul><li>有时候, 我们可能需求同时发送两个请求<ul><li>使用<strong>axios.all,</strong> 可以放入多个请求的数组. res[0],res[1] 得出结果</li><li><strong>axios.all([]) 返回的结果是一个数组</strong>，使用 axios.spread 可将数组 [res1,res2] 展开为 res1, res2</li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/20200926145610347.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Bmenp6eno=,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="发送并发请求"></p><p>如果不使用  axios.spread 那就 用 最简单的数组方法得出结果：  res[0],res[1]</p><h2 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h2><blockquote><p>在上面的示例中, 我们的BaseURL是固定的<br>事实上, 在开发中可能很多参数都是固定的.<br>这个时候我们可以进行一些抽取, 也可以利用axiox的全局配置</p></blockquote><pre><code class="hljs javascript">axios.<span class="hljs-property">defaults</span>.<span class="hljs-property">baseURL</span> = ‘<span class="hljs-number">123.207</span><span class="hljs-number">.32</span><span class="hljs-number">.32</span>:<span class="hljs-number">8000</span>’axios.<span class="hljs-property">defaults</span>.<span class="hljs-property">headers</span>.post[‘<span class="hljs-title class_">Content</span>-<span class="hljs-title class_">Type</span>’] = ‘application/x-www-form-urlencoded’;</code></pre><p><img src="https://img-blog.csdnimg.cn/20200926145610330.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Bmenp6eno=,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="全局配置"></p><h2 id="创建-axios-实例"><a href="#创建-axios-实例" class="headerlink" title="创建 axios 实例"></a>创建 axios 实例</h2><ul><li>为什么要创建axios的实例呢?<ul><li>当我们从axios模块中导入对象时, 使用的实例是默认的实例.</li><li>当给该实例设置一些默认配置时, 这些配置就被固定下来了.</li><li>但是后续开发中, 某些配置可能会不太一样.</li><li>比如某些请求需要使用特定的baseURL或者timeout或者content-Type等.</li><li>这个时候, 我们就可以创建新的实例, 并且传入属于该实例的配置信息.  </li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/20200926145610848.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Bmenp6eno=,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="创建 axios 实例"></p><h2 id="axios-模块化封装-⭐"><a href="#axios-模块化封装-⭐" class="headerlink" title="axios 模块化封装  ⭐"></a>axios 模块化封装  ⭐</h2><blockquote><p>在实际开发过程中，需要对AJAX请求进行统一的封装，使其模块化，易于修改和操作。</p><p>所以，最好这样做，而不是直接在 组件内使用 axios 插件 ，那样后期修改整个 axios 时会及其麻烦</p></blockquote><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;axios&quot;</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">request</span>(<span class="hljs-params">config</span>) &#123;  <span class="hljs-comment">//  1.配置基本信息   </span>  <span class="hljs-keyword">const</span> instance = axios.<span class="hljs-title function_">create</span>(&#123;    <span class="hljs-attr">baseURL</span>: <span class="hljs-string">&#x27;http://152.136.185.210:8000/api/z8&#x27;</span>,    <span class="hljs-attr">timeout</span>: <span class="hljs-number">5000</span>  &#125;)  <span class="hljs-comment">//  本身返回的就一个 Promise   不需要再次封装一个 Promise来使用</span>  <span class="hljs-comment">// 3.发送真正的网络请求  ( 方式一)</span>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">instance</span>(config)&#125; <span class="hljs-comment">//  使用 回调函数   ( 方式二)</span><span class="hljs-comment">// export function request(config, success, failure) &#123;</span><span class="hljs-comment">//   const instance = axios.create(&#123;</span><span class="hljs-comment">//     baseURL: &#x27;http://152.136.185.210:8000/api/z8&#x27;,</span><span class="hljs-comment">//     timeout: 5000</span><span class="hljs-comment">//   &#125;)</span><span class="hljs-comment">//   instance(config)</span><span class="hljs-comment">//     .then(res =&gt; &#123;</span><span class="hljs-comment">//       success(res)</span><span class="hljs-comment">//     &#125;)</span><span class="hljs-comment">//     .catch(err =&gt; &#123;</span><span class="hljs-comment">//       failure(err)</span><span class="hljs-comment">//     &#125;)</span><span class="hljs-comment">// &#125;</span><span class="hljs-comment">// 使用 Promise      ( 方式三 )</span><span class="hljs-comment">// export function request(config) &#123;</span><span class="hljs-comment">//   return new Promise((resolve, reject) =&gt; &#123;</span><span class="hljs-comment">//     const instance = axios.create(&#123;</span><span class="hljs-comment">//       baseURL: &#x27;http://152.136.185.210:8000/api/z8&#x27;,</span><span class="hljs-comment">//       timeout: 5000</span><span class="hljs-comment">//     &#125;)</span><span class="hljs-comment">//     instance(config)</span><span class="hljs-comment">//       .then(res =&gt; &#123;</span><span class="hljs-comment">//         resolve(res)</span><span class="hljs-comment">//       &#125;)</span><span class="hljs-comment">//       .catch(err =&gt; &#123;</span><span class="hljs-comment">//         reject(err)</span><span class="hljs-comment">//       &#125;)</span><span class="hljs-comment">//   &#125;)</span><span class="hljs-comment">// &#125;</span></code></pre><pre><code class="hljs javascript"><span class="hljs-comment">//  在组件内 传入对象 进行网络请求</span><span class="hljs-comment">// 方式一和方式三（promise） ，</span><span class="hljs-title function_">request</span>(&#123;    <span class="hljs-attr">url</span>:<span class="hljs-string">&#x27;/home/multidata&#x27;</span>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span>&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span>=&gt;</span>&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err)&#125;)<span class="hljs-comment">// 方式二 （使用的回调函数）:</span><span class="hljs-title function_">request</span>(&#123;    <span class="hljs-attr">url</span>:<span class="hljs-string">&#x27;/home/multidata&#x27;</span>&#125;,<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res) &#125;,<span class="hljs-function"><span class="hljs-params">err</span>=&gt;</span>&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err) &#125;)</code></pre><h2 id="axios-拦截器"><a href="#axios-拦截器" class="headerlink" title="axios 拦截器"></a>axios 拦截器</h2><blockquote><p>axios提供了拦截器，用于我们在发送每次请求或者得到相应后，进行对应的处理。</p></blockquote><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;axios&quot;</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">request</span>(<span class="hljs-params">config</span>) &#123;  <span class="hljs-comment">//  1.配置基本信息   （创建实例， 这样不是全局的）</span>  <span class="hljs-keyword">const</span> instance = axios.<span class="hljs-title function_">create</span>(&#123;    <span class="hljs-attr">baseURL</span>: <span class="hljs-string">&#x27;http://152.136.185.210:8000/api/z8&#x27;</span>,    <span class="hljs-attr">timeout</span>: <span class="hljs-number">5000</span>  &#125;)  <span class="hljs-comment">// 2.axios 拦截器</span>  <span class="hljs-comment">// 2.1请求拦截的作用： </span>  instance.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(<span class="hljs-function"><span class="hljs-params">config</span> =&gt;</span> &#123;    <span class="hljs-comment">//  这里可以拦截一些：</span>    <span class="hljs-comment">// 1. 比如config中的一些信息不符合服务器的要求  </span>    <span class="hljs-comment">// 2. 比如每次发送网络请求时，都希望在页面中显示一个请求的图标</span>    <span class="hljs-comment">// 3. 某些网络请求（比如登录需要的（token），必须携带一些特殊的信息）</span>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(config);    <span class="hljs-comment">// 拦截后 要发出去  要不就收不到</span>    <span class="hljs-keyword">return</span> config  &#125;, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err);  &#125;)  <span class="hljs-comment">// 2.2 响应拦截 </span>  instance.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;      <span class="hljs-comment">// 响应的成功拦截中，主要是对数据进行过滤。</span>    <span class="hljs-keyword">return</span> res.<span class="hljs-property">data</span> <span class="hljs-comment">// 真正有用的东西是 data中的数据</span>  &#125;, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;    <span class="hljs-comment">// 响应的失败拦截中，可以根据status判断报错的错误码，跳转到不同的错误提示页面。</span>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err);  &#125;)  <span class="hljs-comment">//  本身返回的就一个 Promise   不需要再次封装一个 Promise来使用</span>  <span class="hljs-comment">// 3.发送真正的网络请求</span>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">instance</span>(config)&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vuex详解</title>
    <link href="/2020/09/26/24-Vuex%E8%AF%A6%E8%A7%A3/"/>
    <url>/2020/09/26/24-Vuex%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="Vuex⭐"><a href="#Vuex⭐" class="headerlink" title="Vuex⭐"></a>Vuex⭐</h1><blockquote><p>Vuex是一个专为Vue开发的应用程序的状态管理模式，它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p></blockquote><p>简而言之，Vuex采用<strong>类似全局对象</strong>的形式来管理所有组件的公用数据，如果想修改这个全局对象的数据，得按照Vuex提供的方式来修改（不能自己随意用自己的方式来修改）</p><h2 id="1-安装和使用"><a href="#1-安装和使用" class="headerlink" title="1 安装和使用"></a>1 安装和使用</h2><p><strong>1.安装Vuex</strong></p><pre><code class="hljs js">npm install vuex --save</code></pre><p><strong>2.引用Vuex</strong></p><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vuex</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">Vuex</span>)<span class="hljs-number">123</span></code></pre><p><strong>3.创建仓库Store</strong></p><p>要使用Vuex，我们要创建一个实例 <code>store</code>，我们称之为仓库，利用这个仓库 <code>store</code> 来对我们的状态进行管理。</p><pre><code class="hljs js"><span class="hljs-comment">//创建一个 store</span><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vuex</span>.<span class="hljs-title class_">Store</span>(&#123;&#125;);</code></pre><h2 id="2-单界面的状态管理"><a href="#2-单界面的状态管理" class="headerlink" title="2 单界面的状态管理"></a>2 单界面的状态管理</h2><p><img src="https://img-blog.csdnimg.cn/20200926145610255.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Bmenp6eno=,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="单界面的状态管理"></p><ul><li><strong>State</strong>：不用多说，就是我们的状态。（你姑且可以当做就是data中的属性）</li><li><strong>View</strong>：视图层，可以针对State的变化，显示不同的信息。</li><li><strong>Actions</strong>：这里的Actions主要是用户的各种操作：点击、输入等等，会导致状态的改变。</li></ul><h2 id="3-单界面的状态管理的代码实现"><a href="#3-单界面的状态管理的代码实现" class="headerlink" title="3 单界面的状态管理的代码实现"></a>3 单界面的状态管理的代码实现</h2><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">test</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>当前计数：&#123;&#123;counter&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;counter+=1&quot;</span>&gt;</span>+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;counter-=1&quot;</span>&gt;</span>-1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><span class="language-javascript">        <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;HelloWorld&#x27;</span>,</span><span class="language-javascript">        <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;</span><span class="language-javascript">            <span class="hljs-keyword">return</span> &#123; </span><span class="language-javascript">            <span class="hljs-attr">counter</span>: <span class="hljs-number">0</span></span><span class="language-javascript">            &#125;</span><span class="language-javascript">        &#125;</span><span class="language-javascript">    &#125;</span><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre><ol><li><strong>在这个案例中， 我们有个 counter 需要管理</strong></li><li><strong>counter 需要被某种方式被记录下来，也就是我们的</strong> <code>State</code></li><li><strong>counter 目前的值会显示在界面上， 也就是我们的 <code>View</code> 部分</strong></li><li><strong>界面发送某些操作时， 比如我们这里使用的是 点击事件 ， 需要去更新状态， 也就是我们的</strong> <code>Actions</code></li></ol><h2 id="4-Vuex的核心概念和API"><a href="#4-Vuex的核心概念和API" class="headerlink" title="4 Vuex的核心概念和API"></a>4 Vuex的核心概念和API</h2><blockquote><p> 主要理解实例中下面这些对象是如何运作的。</p></blockquote><p><strong>流程：View -&gt; Actions -&gt; Mutations -&gt; State -&gt; View</strong></p><p><img src="https://img-blog.csdnimg.cn/20200926145610303.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Bmenp6eno=,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="Vuex的核心概念"></p><h3 id="1、-state"><a href="#1、-state" class="headerlink" title="1、 state"></a>1、 state</h3><ol><li><p>vuex 管理的状态对象</p></li><li><p>它应该是唯一的</p><pre><code> const state = &#123;   xxx: initValue  &#125;</code></pre></li></ol><h3 id="2、-mutations"><a href="#2、-mutations" class="headerlink" title="2、 mutations"></a>2、 mutations</h3><p>​         1) 包含多个直接更新 state 的方法(回调函数)的对象<br>​         2) 谁来触发: <strong>action 中的 commit(‘mutation 名称’)</strong><br>​         3) <strong>只能包含同步的代码, 不能写异步代码</strong><br>​           const mutations = {<br>​              yyy (state, {data1}) {<br>​                // 更新 state 的某个属性<br>​             }<br>​           }</p><h3 id="3、-actions"><a href="#3、-actions" class="headerlink" title="3、 actions"></a>3、 actions</h3><ol><li><p>包含多个事件回调函数的</p></li><li><p>通过执行: commit()来触发 mutation 的调用, 间接更新 state</p></li><li><p>谁来触发: 组件中: <strong>$store.dispatch(‘action 名称’, data1) // ‘zzz</strong></p></li><li><p><strong>可以包含异步代码(axios)</strong></p></li></ol><p>const actions ={</p><p>   zzz ({commit, state}, data1)</p><p>​        commit(‘yyy’, {data1})</p><p>  }</p><p>}</p><h3 id="4、-getters"><a href="#4、-getters" class="headerlink" title="4、 getters"></a>4、 getters</h3><ol><li><p><strong>包含多个计算属性(get)的对象</strong>（也就是说，getters是用来放state里面的变量的计算属性的）</p></li><li><p>谁来读取: 组件中: <strong>$store.getters.xxx</strong></p><p>const getters ={</p><p>xxx(state) {</p></li></ol><p>​         return …</p><p>​    }</p><p>}</p><h3 id="5、-modules"><a href="#5、-modules" class="headerlink" title="5、 modules"></a>5、 modules</h3><ol><li><p>包含多个 module</p></li><li><p>一个 module 是一个 store 的配置对象</p></li><li><p>与一个组件(包含有共享数据)对应</p></li></ol><h2 id="5-Vuex的运作流程"><a href="#5-Vuex的运作流程" class="headerlink" title="5 Vuex的运作流程"></a>5 Vuex的运作流程</h2><h3 id="Vuex的运作流程"><a href="#Vuex的运作流程" class="headerlink" title="Vuex的运作流程"></a>Vuex的运作流程</h3><p><img src="https://img-blog.csdnimg.cn/20181227125005140.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNjQ3OTk5,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="Vuex的运作流程"></p><h3 id="流程详解"><a href="#流程详解" class="headerlink" title="流程详解"></a>流程详解</h3><p>① 在组件（页面）中，通过dispatch()或mapActions()这个函数分发给actions的函数去处理。</p><p>② actions的函数可以与后台交互，也可以通过 commit() 提交给mutations去处理。</p><p>③ mutations 可以直接与devtool（如本地存储工具 → 在实例代码中的utils里的storageUtils.js）交互与直接更新state（数据状态）。</p><p>④ 如果有计算属性（get函数写在getters里面），则状态通过getters的$store.getters()或<strong>mapGetters()**来更新组件；反之就通过$store.state()或者</strong>mapState()**的方式来更新组件。</p>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VueRouter--前端路由</title>
    <link href="/2020/09/26/23-VueRouter/"/>
    <url>/2020/09/26/23-VueRouter/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue-router-前端路由⭐"><a href="#Vue-router-前端路由⭐" class="headerlink" title="Vue-router  前端路由⭐"></a>Vue-router  前端路由⭐</h1><blockquote><p>前端路由核心： 改变URL，但是页面不进行整体的刷新。</p></blockquote><h2 id="1-单页面导航路径"><a href="#1-单页面导航路径" class="headerlink" title="1 单页面导航路径"></a>1 单页面导航路径</h2><blockquote><p>URL.hash 和 HTML5 history</p></blockquote><h3 id="URL-hash"><a href="#URL-hash" class="headerlink" title="URL.hash"></a>URL.hash</h3><blockquote><p>URL的hash也就是锚点(#), 本质上是改变window.location的href属性.<br>我们可以通过直接赋值location.hash来改变href, 但是页面不发生刷新</p></blockquote><ul><li><p><strong>路径</strong>  （使用 url.hash）</p><ul><li>一般使用描点来表示路径，也就是 hash 作为页面导航的路径标识</li><li>为什么？ 因为<strong>正常的url地址会发请求，而hash描点不会发送请求刷新页面</strong></li></ul></li><li><p><strong>VueRouter 内部监视了 hash的改变  ——-  window.onhashchange</strong></p></li><li><p>然后根据 hash 的改变去展示路由规则中的配置组件</p></li><li><p>VueRouter 默认要求 hash 导航路径都以 #/开头</p><ul><li>为什么？</li><li>主要是为了和正常的hash锚点（网页内部定位、id）做区别</li><li>例如我们使用锚点内部定位的时候，需要给元素起id，我们几乎不会给id起名为 /xxx</li><li>如果 VueRouter 没有 #/ 的规则 ，例如直接 #foo 就可能会你锚点的那个 id foo 冲突</li></ul></li></ul><p><strong>因为有 url.hash 这样的设置使得 url 不美观， 那么我们可以使用HTML5新增属性 history 的方法</strong></p><ul><li>VueRouter  默认是 hash 路径模式</li><li>它页支持传统的 url 模式（HTML history）</li></ul><h3 id="history"><a href="#history" class="headerlink" title="history"></a>history</h3><ul><li>优点  — 优雅、同构应用友好</li><li>hash模式<ul><li>兼容性更好，不需要后端处理任何配置</li><li>file  协议或是http协议都可以运行</li><li>比较丑，不能用于服务端渲染同构开发</li></ul></li><li>history 模式<ul><li>相比 hash 浏览器 兼容不太好，需要后端特殊配置</li><li>必须运行在 http|https 服务中</li><li>url 简洁美观，如果需要做服务端渲染同构开发，则必须使用 history模式</li><li>注意： 使用了history模式之后，不要在模板中直接使用普通的 a 链接去跳转，一定要使用 router-link 或者  router.push 进行导航</li></ul></li></ul><p><strong>history 有五种模式改变URL而不刷新页面.</strong></p><ul><li><strong>history.pushState()</strong></li><li><strong>history.replaceState()</strong>       和 pushState 的区别是 不能返回</li><li><strong>history.go()</strong>   </li><li>**history.back() **         等价于 history.go(-1)</li><li><strong>history.forward()</strong>    则等价于 history.go(1)</li></ul><h2 id="2-vue-router-安装和使用"><a href="#2-vue-router-安装和使用" class="headerlink" title="2 vue-router 安装和使用"></a>2 vue-router 安装和使用</h2><ul><li>vue-router是基于路由和组件的<ul><li>路由用于设定访问路径, 将路径和组件映射起来.</li><li>在vue-router的单页面应用中, 页面的路径的改变就是组件的切换.</li></ul></li></ul><ul><li><p>步骤一: 安装vue-router</p><ul><li><pre><code class="shell">npm install vue-router --save<pre><code class="hljs php">- 步骤二: 在模块化工程中使用它(因为是一个插件, 所以可以通过Vue.<span class="hljs-keyword">use</span>()来安装路由功能)  - 第一步：导入路由对象，并且调用 Vue.<span class="hljs-keyword">use</span>(VueRouter)    - ```javascript      import Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>       import VueRouter <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span>       <span class="hljs-comment">// 1. 调用插件</span>      Vue.<span class="hljs-keyword">use</span>(VueRouter)</code></pre></code></pre></li><li><p>第二步：创建路由实例，并且传入路由映射配置</p></li><li><p>第三步：在Vue实例中挂载创建的路由实例</p></li></ul></li></ul><ul><li>使用vue-router的步骤:<ul><li>第一步: 创建路由组件</li><li>第二步: 配置路由映射: 组件和路径映射关系</li><li>第三步: 使用路由: 通过<router-link>和<router-view></li></ul></li></ul><h3 id="2-1-创建Vue实例"><a href="#2-1-创建Vue实例" class="headerlink" title="2.1 创建Vue实例"></a>2.1 创建Vue实例</h3><p><img src="https://i.loli.net/2020/09/25/Rl9VBz1wrFqoIbg.png" srcset="/img/loading.gif" alt="1"></p><h3 id="2-2-挂载到Vue实例中"><a href="#2-2-挂载到Vue实例中" class="headerlink" title="2.2 挂载到Vue实例中"></a>2.2 挂载到Vue实例中</h3><p><img src="https://img-blog.csdnimg.cn/2020092614545839.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Bmenp6eno=,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="挂载到Vue实例中"></p><h3 id="2-3-步骤一：创建路由组件"><a href="#2-3-步骤一：创建路由组件" class="headerlink" title="2.3 步骤一：创建路由组件"></a>2.3 步骤一：创建路由组件</h3><p><img src="https://i.loli.net/2020/09/25/rTXEdiZAHeUvQ3P.png" srcset="/img/loading.gif" alt="3"></p><h3 id="2-4-步骤二：配置组件和路径的映射关系"><a href="#2-4-步骤二：配置组件和路径的映射关系" class="headerlink" title="2.4 步骤二：配置组件和路径的映射关系"></a>2.4 步骤二：配置组件和路径的映射关系</h3><p><img src="https://img-blog.csdnimg.cn/20200926145610781.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Bmenp6eno=,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="配置组件和路径的映射关系"></p><h3 id="2-5-步骤三：使用路由"><a href="#2-5-步骤三：使用路由" class="headerlink" title="2.5 步骤三：使用路由."></a>2.5 步骤三：使用路由.</h3><p><img src="https://i.loli.net/2020/09/25/W9mfNcFsjC3Jy7e.png" srcset="/img/loading.gif" alt="5"></p><h3 id="最终效果如下"><a href="#最终效果如下" class="headerlink" title="最终效果如下"></a>最终效果如下</h3><p><img src="https://img-blog.csdnimg.cn/20200926145610812.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Bmenp6eno=,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="最终效果"></p><h3 id="2-6-路由的默认路径"><a href="#2-6-路由的默认路径" class="headerlink" title="2.6 路由的默认路径"></a>2.6 路由的默认路径</h3><ul><li>我们这里还有一个不太好的实现:<ul><li>默认情况下, 进入网站的首页, 我们希望<router-view>渲染首页的内容.</li><li>但是我们的实现中, 默认没有显示首页组件, 必须让用户点击才可以.</li></ul></li></ul><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> routes = [  &#123;    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;&#x27;</span>,    <span class="hljs-attr">redirect</span>: <span class="hljs-string">&#x27;/home&#x27;</span>  &#125;,  ]</code></pre><ul><li>配置解析:<ul><li>我们在routes中又配置了一个映射. </li><li>path配置的是根路径: /</li><li>redirect是重定向, 也就是我们将根路径重定向到/home的路径下, 这样就可以得到我们想要的结果了.</li></ul></li></ul><h3 id="2-7-使用-HTML5-history-模式"><a href="#2-7-使用-HTML5-history-模式" class="headerlink" title="2.7 使用 HTML5 history 模式"></a>2.7 使用 HTML5 history 模式</h3><ul><li>我们前面说过改变路径的方式有两种:<ul><li>URL的hash</li><li>HTML5的history</li><li>默认情况下, 路径的改变使用的URL的hash.</li></ul></li></ul><pre><code class="hljs javascript"><span class="hljs-comment">//  2. 创建 Router 实例对象 并 导出它</span><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Router</span>(&#123;  <span class="hljs-comment">// 3.  routes 属性： 配置路由和组件之间的映射关系</span>  routes,  <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;history&#x27;</span> <span class="hljs-comment">// 默认是 hash 模式， </span>&#125;)</code></pre><h3 id="2-8-router-link-的补充"><a href="#2-8-router-link-的补充" class="headerlink" title="2.8 router-link 的补充"></a>2.8 router-link 的补充</h3><ul><li><strong>tag</strong>: tag可以指定<router-link>之后渲染成什么组件, 比如上面的代码会被渲染成一个<li>元素, 而不是<a></li><li><strong>replace:</strong> replace不会留下history记录, 所以指定replace的情况下, 后退键返回不能返回到上一个页面中</li><li><strong>active-class</strong>: 当<router-link>对应的路由匹配成功时, 会自动给当前元素设置一个router-link-active的class, 设置active-class可以修改默认的名称.</li></ul><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>    <span class="hljs-comment">&lt;!-- tag: tag可以指定&lt;router-link&gt;之后渲染成什么组件, 比如上面的代码会被渲染成一个&lt;li&gt;元素, 而不是&lt;a&gt; --&gt;</span>    <span class="hljs-comment">&lt;!-- replace : replace不会留下history记录, 所以指定replace的情况下, 后退键返回不能返回到上一个页面中 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/home&quot;</span> <span class="hljs-attr">replace</span> <span class="hljs-attr">tag</span>=<span class="hljs-string">&quot;button&quot;</span>&gt;</span>首页<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/login&quot;</span> <span class="hljs-attr">replace</span> <span class="hljs-attr">tag</span>=<span class="hljs-string">&quot;button&quot;</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">&quot;&#x27;/user/&#x27;+id&quot;</span> <span class="hljs-attr">tag</span>=<span class="hljs-string">&quot;button&quot;</span>&gt;</span>用户<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">&quot;&#123;path:&#x27;/profile&#x27;,query:&#123;name:&#x27;wpf&#x27;,age:&#x27;23&#x27;,sex:&#x27;男&#x27;&#125;&#125;&quot;</span> <span class="hljs-attr">tag</span>=<span class="hljs-string">&quot;button&quot;</span>&gt;</span>档案<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span>    <span class="hljs-comment">&lt;!-- &lt;button @click=&quot;homeClick&quot;&gt;首页&lt;/button&gt;</span><span class="hljs-comment">    &lt;button @click=&quot;loginClick&quot;&gt;登录&lt;/button&gt;--&gt;</span>    <span class="hljs-comment">&lt;!-- inlcude（包含） -- 只有匹配的组件才会被缓存</span><span class="hljs-comment">    exclude（排除） -- 除了这些组件都会被缓存--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span> <span class="hljs-attr">exclude</span>=<span class="hljs-string">&quot;User,Profile&quot;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><span class="language-javascript">  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;App&quot;</span>,</span><span class="language-javascript">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;</span><span class="language-javascript">      <span class="hljs-attr">id</span>: <span class="hljs-string">&quot;wpfzzz&quot;</span>,</span><span class="language-javascript">    &#125;;</span><span class="language-javascript">  &#125;,</span><span class="language-javascript">&#125;;</span><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">style</span>  <span class="hljs-attr">scoped</span>&gt;</span><span class="language-css"></span><span class="language-css"><span class="hljs-selector-class">.router-link-active</span> &#123;</span><span class="language-css">  <span class="hljs-attribute">color</span>: <span class="hljs-number">#f00</span>;</span><span class="language-css">&#125;</span><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre><h3 id="2-9-路由代码跳转"><a href="#2-9-路由代码跳转" class="headerlink" title="2.9 路由代码跳转"></a>2.9 路由代码跳转</h3><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;homeClick&quot;</span>&gt;</span>首页<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;loginClick&quot;</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></code></pre><pre><code class="hljs javascript"><span class="hljs-attr">methods</span>: &#123;  <span class="hljs-title function_">homeClick</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-comment">// this.$router.push(&quot;/htmo&quot;);</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">$router</span>.<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;/htmo&quot;</span>).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> err);;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;home&quot;</span>);  &#125;,  <span class="hljs-title function_">loginClick</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-comment">// this.$router.push(&quot;/login&quot;);</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">$router</span>.<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;/login&quot;</span>).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> err);;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;login&quot;</span>);  &#125;,&#125;,</code></pre><h3 id="2-10-动态路由"><a href="#2-10-动态路由" class="headerlink" title="2.10  动态路由"></a>2.10  动态路由</h3><ul><li>在某些情况下，一个页面的path路径可能是不确定的，比如我们进入用户界面时，希望是如下的路径：<ul><li>/user/aaaa或/user/bbbb</li><li>除了有前面的/user之外，后面还跟上了用户的ID</li><li>这种path和Component的匹配关系，我们称之为动态路由(也是路由传递数据的一种方式)。</li></ul></li></ul><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">&quot;&#x27;/user/&#x27;+id&quot;</span> <span class="hljs-attr">tag</span>=<span class="hljs-string">&quot;button&quot;</span>&gt;</span>用户<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">&quot;&#123;path:&#x27;/profile&#x27;,query:&#123;name:&#x27;wpf&#x27;,age:&#x27;23&#x27;,sex:&#x27;男&#x27;&#125;&#125;&quot;</span> <span class="hljs-attr">tag</span>=<span class="hljs-string">&quot;button&quot;</span>&gt;</span>档案<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span> // 注意： 要使用 v-bind 动态绑定 这样可以获取data中的数据， 否则是个字符串</code></pre><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span>  path<span class="hljs-punctuation">:</span> &#x27;/user/<span class="hljs-punctuation">:</span>userId&#x27;<span class="hljs-punctuation">,</span>   <span class="hljs-comment">// 这个 </span>  component<span class="hljs-punctuation">:</span> User<span class="hljs-punctuation">,</span>  meta<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>    title<span class="hljs-punctuation">:</span> &#x27;用户&#x27;  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span></code></pre><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123;$route.params.userId&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></code></pre><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123;$route.query.name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123;$route.query.age&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123;$route.query.sex&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></code></pre><h2 id="3-路由懒加载"><a href="#3-路由懒加载" class="headerlink" title="3 路由懒加载"></a>3 路由懒加载</h2><ul><li>为什么要使用懒加载<ul><li>首先, 我们知道路由中通常会定义很多不同的页面.</li><li>这个页面最后被打包在哪里呢? 一般情况下, 是放在一个js文件中.</li><li>但是, 页面这么多放在一个js文件中, 必然会造成这个页面非常的大.</li><li>如果我们一次性从服务器请求下来这个页面, 可能需要花费一定的时间, 甚至用户的电脑上还出现了短暂空白的情况.</li><li>如何避免这种情况呢? 使用路由懒加载就可以了.</li></ul></li></ul><ul><li>路由懒加载可以做什么？<ul><li><strong>路由懒加载的主要作用就是将路由对应的组件打包成一个个的js代码块.</strong></li><li><strong>只有在这个路由被访问到的时候, 才加载对应的组件</strong></li></ul></li></ul><p><strong>路由懒加载后的效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200926145610878.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Bmenp6eno=,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="路由懒加载后的效果"></p><h3 id="3-1-懒加载的方式"><a href="#3-1-懒加载的方式" class="headerlink" title="3.1 懒加载的方式"></a>3.1 懒加载的方式</h3><ul><li><p><strong>方式一: 结合Vue的异步组件和Webpack的代码分析.</strong></p><ul><li><pre><code class="javascript">const Home = resolve =&gt; &#123; require.ensure([&#39;../components/Home.vue&#39;], () =&gt; &#123; resolve(require(&#39;../components/Home.vue&#39;)) &#125;)&#125;;<pre><code class="hljs zephir">- **方式二: AMD写法**  - ```javascript    <span class="hljs-keyword">const</span> About = resolve =&gt; <span class="hljs-keyword">require</span>([<span class="hljs-string">&#x27;../components/About.vue&#x27;</span>], resolve);</code></pre></code></pre></li></ul></li><li><p><strong>方式三: 在ES6中, 我们可以有更加简单的写法来组织Vue异步组件和Webpack的代码分割.</strong></p><ul><li><pre><code class="javascript">const Home = () =&gt; import(&#39;../components/Home.vue&#39;)<pre><code class="hljs moonscript">```javascript// <span class="hljs-keyword">import</span> Home <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../components/Home.vue&#x27;</span>// <span class="hljs-keyword">import</span> Login <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../components/Login.vue&#x27;</span>// <span class="hljs-keyword">import</span> User <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../components/User.vue&#x27;</span>;// 使用路由懒加载const Home = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;../components/Home.vue&#x27;</span>)const HomeNews = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;../components/HomeNews.vue&#x27;</span>)const HomeMessage = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;../components/HomeMessage.vue&#x27;</span>)const Login = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;../components/Login.vue&#x27;</span>)const User = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;../components/User.vue&#x27;</span>)const Profile = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;../components/Profile.vue&#x27;</span>)</code></pre></code></pre></li></ul></li></ul><h2 id="4-嵌套路由的使用"><a href="#4-嵌套路由的使用" class="headerlink" title="4 嵌套路由的使用"></a>4 嵌套路由的使用</h2><ul><li>嵌套路由是一个很常见的功能<ul><li>比如在home页面中, 我们希望通过/home/news和/home/message访问一些内容.</li><li>一个路径映射一个组件, 访问这两个路径也会分别渲染两个组件.</li></ul></li><li>实现嵌套路由有两个步骤:<ul><li>创建对应的子组件, 并且在路由映射中配置对应的子路由.</li><li>在组件内部使用<router-view>标签.</li></ul></li></ul><h2 id="5-传递参数"><a href="#5-传递参数" class="headerlink" title="5  传递参数"></a>5  传递参数</h2><h3 id="5-1-传递参数的俩种方式-params-和-query"><a href="#5-1-传递参数的俩种方式-params-和-query" class="headerlink" title="5.1 传递参数的俩种方式 params 和 query"></a>5.1 传递参数的俩种方式 params 和 query</h3><blockquote><p> 传递参数主要有两种类型: params和query</p></blockquote><ul><li>params的类型:  <strong>(参考 10.2.10 动态路由)</strong><ul><li>配置路由格式: <strong>/router/:id</strong></li><li>传递的方式: <strong>在path后面跟上对应的值</strong></li><li>传递后形成的路径: <strong>/router/123, /router/abc</strong></li></ul></li><li>query的类型:<ul><li>配置路由格式: /router, 也就是普通配置</li><li>传递的方式: 对象中使用query的key作为传递方式</li><li>传递后形成的路径: /router?id=123, /router?id=abc</li></ul></li></ul><h3 id="5-2-query-参数传递方式一："><a href="#5-2-query-参数传递方式一：" class="headerlink" title="5.2   query 参数传递方式一："></a>5.2   query 参数传递方式一：</h3><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">&quot;&#123;path:&#x27;/profile&#x27;,query:&#123;name:&#x27;wpf&#x27;,age:&#x27;23&#x27;,sex:&#x27;男&#x27;&#125;&#125;&quot;</span> <span class="hljs-attr">tag</span>=<span class="hljs-string">&quot;button&quot;</span>&gt;</span>档案<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span> // 注意： 要使用 v-bind 动态绑定 这样可以获取data中的数据， 否则是个字符串</code></pre><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>档案页面<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123;$route.query.name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123;$route.query.age&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123;$route.query.sex&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><h3 id="5-3-query-参数传递方式二："><a href="#5-3-query-参数传递方式二：" class="headerlink" title="5.3   query 参数传递方式二："></a>5.3   query 参数传递方式二：</h3><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;toProfile&quot;</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></code></pre><pre><code class="hljs javascript"><span class="hljs-attr">mehtods</span>:&#123;    <span class="hljs-title function_">toProfile</span>(<span class="hljs-params"></span>)&#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">$router</span>.<span class="hljs-title function_">push</span>(&#123;            <span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/proflie&#x27;</span>,            <span class="hljs-attr">query</span>:&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;wpf&#x27;</span>,<span class="hljs-attr">age</span>:<span class="hljs-number">23</span>,<span class="hljs-attr">sex</span>:<span class="hljs-string">&#x27;男&#x27;</span>&#125;        &#125;)    &#125;&#125;</code></pre><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>档案页面<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123;$route.query.name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123;$route.query.age&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123;$route.query.sex&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><h2 id="6-router-和-route-的区别"><a href="#6-router-和-route-的区别" class="headerlink" title="6  router 和 route 的区别"></a>6  router 和 route 的区别</h2><ul><li>$route和$router是有区别的<ul><li>$router为VueRouter实例，想要导航到不同URL，则使用$router.push方法</li><li>$route为当前router跳转对象里面可以获取name、path、query、params等 </li></ul></li></ul><h3 id="router"><a href="#router" class="headerlink" title="router"></a>router</h3><p><strong>router是VueRouter的一个对象</strong>，通过Vue.use(VueRouter)和VueRouter构造函数得到一个router的实例对象，这个对象中是一个<strong>全局的对象</strong>，他包含了所有的路由包含了许多关键的对象和属性。</p><p>举例：history对象</p><p><code>$router.push(&#123;path:&#39;home&#39;&#125;); </code> 本质是向history栈中添加一个路由，在我们看来是 切换路由，但本质是在添加一个history记录方法</p><p><code>$router.replace(&#123;path:&#39;home&#39;&#125;);</code>  替换路由，没有历史记录</p><h3 id="route"><a href="#route" class="headerlink" title="route"></a>route</h3><p><strong>route是一个跳转的路由对象</strong>，每一个路由都会有一个route对象，是一个<strong>局部的对象，</strong>可以获取对应的name,path,params,query等</p><p><code>$route.path </code><br>字符串，等于当前路由对象的路径，会被解析为绝对路径，如 <code>&quot;/home/news&quot;</code> 。</p><p><code>$route.params </code><br>对象，包含路由中的动态片段和全匹配片段的键值对</p><p><code>$route.query </code><br>对象，包含路由中查询参数的键值对。例如，对于 <code>/home/news/detail/01?favorite=yes</code> ，会得到<code>$route.query.favorite == &#39;yes&#39;</code> 。</p><p><code>$route.router </code><br>路由规则所属的路由器（以及其所属的组件）。</p><p><code>$route.matched </code><br>数组，包含当前匹配的路径中所包含的所有片段所对应的配置参数对象。</p><p><code>$route.name </code><br>当前路径的名字，如果没有使用具名路径，则名字为空。</p><p><code>$route.path, $route.params, $route.name, $route.query</code> 这几个属性很容易理解，主要用于接收路由传递的参数</p><h2 id="7-导航守卫"><a href="#7-导航守卫" class="headerlink" title="7 导航守卫"></a>7 导航守卫</h2><blockquote><h3 id="什么是导航守卫？"><a href="#什么是导航守卫？" class="headerlink" title="什么是导航守卫？"></a>什么是导航守卫？</h3><p>笼统的说，导航守卫是控制用户能够进入哪些路由和不能进入哪些路由的控制器，也就是管理路由的</p><p>打比方，在你第一次进入csdn网站，想写博客时，你必须先登录，才能进入博客编写；登陆界面就好比你能进入的路由，而博客是你不能进入的路由，当你登陆后，控制器才会给你权限，才能进入博客路由，这就是<strong>导航守卫</strong>的用途</p></blockquote><p><strong>全局路由 要在 main.js 文件下创建</strong></p><p>想用<strong>导航守卫</strong>先要有路由</p><pre><code class="hljs javascript"><span class="hljs-comment">//main.js</span><span class="hljs-keyword">const</span> router= <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span>(&#123;  <span class="hljs-attr">routes</span>:[    &#123;<span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/&#x27;</span>,<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;home&#x27;</span>,<span class="hljs-attr">component</span>:<span class="hljs-title class_">Home</span>&#125;,    &#123;<span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/menu&#x27;</span>,<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;menu&#x27;</span>,<span class="hljs-attr">component</span>:<span class="hljs-title class_">Menu</span>&#125;,    &#123;<span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/admin&#x27;</span>,<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;admin&#x27;</span>,<span class="hljs-attr">component</span>:<span class="hljs-title class_">Admin</span>&#125;,    &#123;<span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/about&#x27;</span>,<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;about&#x27;</span>,<span class="hljs-attr">component</span>:<span class="hljs-title class_">About</span>,<span class="hljs-attr">redirect</span>: &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;contactLink&#x27;</span>&#125;,<span class="hljs-attr">children</span>:[   <span class="hljs-comment">//二级路由</span>        &#123;<span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/about/contact&#x27;</span>,<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;contactLink&#x27;</span>,<span class="hljs-attr">component</span>:<span class="hljs-title class_">Contact</span>&#125;,        &#123;<span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/history&#x27;</span>,<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;historyLink&#x27;</span>,<span class="hljs-attr">component</span>:<span class="hljs-title class_">History</span>&#125;,        &#123;<span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/delivery&#x27;</span>,<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;deliveryLink&#x27;</span>,<span class="hljs-attr">component</span>:<span class="hljs-title class_">Delivery</span>&#125;,        &#123;<span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/orderingGuide&#x27;</span>,<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;orderingGuideLink&#x27;</span>,<span class="hljs-attr">component</span>:<span class="hljs-title class_">OrderingGuide</span>,<span class="hljs-attr">redirect</span>:&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;phonelink&#x27;</span>&#125;,<span class="hljs-attr">children</span>: [  <span class="hljs-comment">//三级路由</span>            &#123;<span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/phone&#x27;</span>,<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;phonelink&#x27;</span>,<span class="hljs-attr">component</span>:<span class="hljs-title class_">Phone</span>&#125;,            &#123;<span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/name&#x27;</span>,<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;namelink&#x27;</span>,<span class="hljs-attr">component</span>:<span class="hljs-title class_">Name</span>&#125;          ]&#125;,      ]&#125;,    &#123;<span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/login&#x27;</span>,<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;login&#x27;</span>,<span class="hljs-attr">component</span>:<span class="hljs-title class_">Login</span>&#125;,    &#123;<span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/register&#x27;</span>,<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;register&#x27;</span>,<span class="hljs-attr">component</span>:<span class="hljs-title class_">Register</span>&#125;,    &#123;<span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;*&#x27;</span>,<span class="hljs-attr">redirect</span>:<span class="hljs-string">&#x27;/&#x27;</span>&#125;  ],  <span class="hljs-attr">mode</span>:<span class="hljs-string">&quot;history&quot;</span>&#125;);</code></pre><p>利用上面路由对象 router 的方法 beforeEach() 实现导航守卫</p><pre><code class="hljs javascript"><span class="hljs-comment">//main.js</span><span class="hljs-comment">//to:跳转到的路由 from:从哪个路由离开  next:显示函数</span>router.<span class="hljs-title function_">beforeEach</span>(<span class="hljs-function">(<span class="hljs-params">to,<span class="hljs-keyword">from</span>,next</span>)=&gt;</span>&#123;       <span class="hljs-keyword">if</span>(to.<span class="hljs-property">path</span> == <span class="hljs-string">&#x27;/login&#x27;</span> || to.<span class="hljs-property">path</span> == <span class="hljs-string">&#x27;/register&#x27;</span>)&#123;    <span class="hljs-title function_">next</span>();  &#125;<span class="hljs-keyword">else</span>&#123;    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;请先登录&quot;</span>);    <span class="hljs-title function_">next</span>(<span class="hljs-string">&#x27;/login&#x27;</span>);  &#125;&#125;);</code></pre><p>‘/login’  ‘/register’ 为自己定义的路由地址</p><p>to.path 为跳转到的路由地址</p><p>next() 为显示当前路由内容</p><p>next(‘/login’) 跳转到指定路由并显示指定路由的内容</p><p>to 对象可获取的信息（console.log(to) 查看）</p><p><img src="https://img-blog.csdn.net/20180823114816241?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0MDg5NTAz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" srcset="/img/loading.gif" alt="img"></p><h3 id="7-1-全局守卫"><a href="#7-1-全局守卫" class="headerlink" title="7.1  全局守卫"></a>7.1  全局守卫</h3><h4 id="前置守卫"><a href="#前置守卫" class="headerlink" title="前置守卫 :"></a><strong>前置守卫 :</strong></h4><pre><code class="hljs javascript">router.<span class="hljs-title function_">beforeEach</span>(<span class="hljs-function">(<span class="hljs-params">to,<span class="hljs-keyword">from</span>,next</span>)=&gt;</span>&#123;&#125;)</code></pre><ul><li><strong>回调函数中的参数，</strong><ul><li><strong>to：进入到哪个路由去</strong></li><li><strong>from：从哪个路由离开</strong></li><li><strong>next：函数，决定是否展示你要看到的路由页面。</strong></li></ul></li></ul><h4 id="后置钩子"><a href="#后置钩子" class="headerlink" title="后置钩子:"></a><strong>后置钩子:</strong></h4><pre><code class="hljs javascript">router.<span class="hljs-title function_">afterEach</span>(<span class="hljs-function">(<span class="hljs-params">to,<span class="hljs-keyword">from</span></span>)=&gt;</span>&#123;&#125;)</code></pre><ul><li><strong>只有两个参数，</strong><ul><li><strong>to：进入到哪个路由去，</strong></li><li><strong>from：从哪个路由离。</strong></li></ul></li></ul><h3 id="7-2-组件守卫"><a href="#7-2-组件守卫" class="headerlink" title="7.2 组件守卫"></a>7.2 组件守卫</h3><blockquote><p>在路由组件内直接定义以下路由导航守卫：</p></blockquote><pre><code class="hljs javascript"><span class="hljs-title function_">beforeRouteEnter</span>(<span class="hljs-params">to,<span class="hljs-keyword">from</span>,next</span>)&#123;    <span class="hljs-comment">// 在渲染该组件的对应路由被 confirm 前调用</span>    <span class="hljs-comment">// 不能！！！ 获取组件实例中的 `this`</span>    <span class="hljs-comment">// 因为当守卫执行前，组件实例还没被创建</span>&#125;,<span class="hljs-title function_">beforeRouteUpdate</span>(<span class="hljs-params">to,<span class="hljs-keyword">from</span>,next</span>)&#123;    <span class="hljs-comment">// 在当前路由改变，但是该组件被复用时调用</span>    <span class="hljs-comment">// 可以访问组件实例 `this`</span>&#125;,<span class="hljs-title function_">beforeRouteLeave</span>(<span class="hljs-params">to,<span class="hljs-keyword">from</span>,next</span>)&#123;    <span class="hljs-comment">// 导航离开该组件的对应路由时调用</span>    <span class="hljs-comment">// 可以访问组件实例 `this`</span>&#125;</code></pre><h3 id="完整的导航解析流程"><a href="#完整的导航解析流程" class="headerlink" title="完整的导航解析流程"></a>完整的导航解析流程</h3><ol><li>导航被触发。</li><li>在失活的组件里调用离开守卫。</li><li>调用全局的 beforeEach 守卫。</li><li>在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。</li><li>在路由配置里调用 beforeEnter。</li><li>解析异步路由组件。</li><li>在被激活的组件里调用 beforeRouteEnter。</li><li>调用全局的 beforeResolve 守卫 (2.5+)。</li><li>导航被确认。</li><li>调用全局的 afterEach 钩子。</li><li>触发 DOM 更新。</li><li>用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。</li></ol><h3 id="7-3-keep-alive"><a href="#7-3-keep-alive" class="headerlink" title="7.3 keep-alive"></a>7.3 keep-alive</h3><blockquote><p>keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。</p></blockquote><p><strong>props（ 属性）</strong>：</p><ul><li>include - 字符串或正则表达式。只有名称匹配的组件会被缓存。</li><li>exclude - 字符串或正则表达式。任何名称匹配的组件都不会被缓存。</li><li>max - 数字。最多可以缓存多少组件实例。</li></ul><p><strong>生命周期函数</strong></p><p>  <strong>1. activated</strong></p><p>      在 keep-alive 组件激活时调用<br>      该钩子函数在服务器端渲染期间不被调用</p><p>  <strong>2. deactivated</strong></p><p>      在 keep-alive 组件停用时调用<br>      该钩子在服务器端渲染期间不被调用</p><p>    被包含在 keep-alive 中创建的组件，会多出两个生命周期的钩子: activated 与 deactivated</p><p>    使用 keep-alive 会将数据保留在内存中，如果要在每次进入页面的时候获取最新的数据，需要在 activated 阶段获取数据，承担原来 created 钩子函数中获取数据的任务。</p><p>    <strong>注意：</strong> 只有组件被 keep-alive 包裹时，这两个生命周期函数才会被调用，如果作为正常组件使用，是不会被调用的，以及在 2.1.0 版本之后，使用 exclude 排除之后，就算被包裹在 keep-alive 中，这两个钩子函数依然不会被调用！另外，在服务端渲染时，此钩子函数也不会被调用。</p><p><strong>缓存所有页面</strong></p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><span class="language-javascript">  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;App&#x27;</span></span><span class="language-javascript">&#125;</span><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><p><strong>根据条件缓存页面</strong></p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>  // 1. 将缓存 name 为 test 的组件  <span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span> <span class="hljs-attr">include</span>=<span class="hljs-string">&#x27;test&#x27;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive</span>&gt;</span>// 2. 将缓存 name 为 a 或者 b 的组件，结合动态组件使用<span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span> <span class="hljs-attr">include</span>=<span class="hljs-string">&#x27;a,b&#x27;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive</span>&gt;</span>// 3. 使用正则表达式，需使用 v-bind<span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span> <span class="hljs-attr">:include</span>=<span class="hljs-string">&#x27;/a|b/&#x27;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive</span>&gt;</span>// 5.动态判断<span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span> <span class="hljs-attr">:include</span>=<span class="hljs-string">&#x27;includedComponents&#x27;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive</span>&gt;</span>// 5. 将不缓存 name 为 test 的组件<span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span> <span class="hljs-attr">exclude</span>=<span class="hljs-string">&#x27;test&#x27;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><span class="language-javascript">  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;App&#x27;</span></span><span class="language-javascript">&#125;</span><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue-Cli脚手架</title>
    <link href="/2020/09/26/22-Vue-Cli%E8%84%9A%E6%89%8B%E6%9E%B6/"/>
    <url>/2020/09/26/22-Vue-Cli%E8%84%9A%E6%89%8B%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue-CLI-脚手架⭐"><a href="#Vue-CLI-脚手架⭐" class="headerlink" title="Vue-CLI  脚手架⭐"></a>Vue-CLI  脚手架⭐</h1><blockquote><p><a href="https://cli.vuejs.org/zh/">Vue CLI</a> 是 Vue 的脚手架工具，它可以帮助我们快速生成 Vue 基础项目代码，提供开箱即用的功能特性。</p></blockquote><ul><li>为什么需要使用 Vue-CLI<ul><li>使用Vue.js开发大型应用时，我们需要考虑代码目录结构、项目结构和部署、热加载、代码单元测试等事情。</li><li>如果每个项目都要手动完成这些工作，那无以效率比较低效，所以通常我们会使用一些脚手架工具来帮助完成这些事情。</li></ul></li></ul><h2 id="1-Vue-CLI-的使用"><a href="#1-Vue-CLI-的使用" class="headerlink" title="1 Vue-CLI 的使用"></a>1 Vue-CLI 的使用</h2><ul><li><p>安装Vue脚手架</p><ul><li><pre><code class="shell">npm install -g @vue/cli@版本号<pre><code class="hljs markdown"><span class="hljs-code">    </span><span class="hljs-code"></span><span class="hljs-bullet">-</span> Vue CLI2初始化项目<span class="hljs-bullet">  -</span> <span class="hljs-code">```shell</span><span class="hljs-code">    vue init webpack my-project</span></code></pre></code></pre></li></ul></li><li><p>Vue CLI3初始化项目</p><ul><li><pre><code class="shell">vue create my-project<pre><code class="hljs awk"><span class="hljs-comment">## 2 Vue-CLI2 详解</span><span class="hljs-comment">### 2.1 步骤详解</span>![image-<span class="hljs-number">20200923112538728</span>](https:<span class="hljs-regexp">//i</span>.loli.net<span class="hljs-regexp">/2020/</span><span class="hljs-number">09</span><span class="hljs-regexp">/25/g</span>Xfdbyo7erTmz19.png)<span class="hljs-comment">### 2.2 目录详解</span>![image-<span class="hljs-number">20200923112626821</span>](https:<span class="hljs-regexp">//i</span>.loli.net<span class="hljs-regexp">/2020/</span><span class="hljs-number">09</span><span class="hljs-regexp">/25/</span><span class="hljs-number">9</span>eP2bklLcqVTywp.png)<span class="hljs-comment">## 3 Runtime-Compiler和Runtime-only的区别 ⭐</span>- **<span class="hljs-number">1</span>、Runtime-Compiler和Runtime-only的main.js文件的区别：**```javascript<span class="hljs-regexp">//</span>（<span class="hljs-number">1</span>） Runtime-Compilernew Vue(&#123;  el: <span class="hljs-string">&#x27;#app&#x27;</span>,  router,  components: &#123; App &#125;,  template: <span class="hljs-string">&#x27;&lt;App/&gt;&#x27;</span>&#125;) <span class="hljs-regexp">//</span> （<span class="hljs-number">2</span>）Runtime-onlynew Vue(&#123;  el: <span class="hljs-string">&#x27;#app&#x27;</span>,  router,  render: h =&gt; h(App)&#125;) <span class="hljs-regexp">//</span> Runtime-Complier 解析过程：第一步：将template模板转换成抽象语法树（ast）;第二步：通过render函数将抽象语法树转换成虚拟DOM（vdom）;第三步：将虚拟DOM转换成真正的DOM；template =&gt; 抽象语法树(ast) =&gt; render() =&gt; 虚拟DOM(vdom) =&gt; 页面 <span class="hljs-regexp">//</span> Runtime-only 解析过程：第一步：vue-template-compiler插件直接将组件转换成 render函数；第二步：将render函数返回的虚拟DOM转换成页面；render() =&gt; 虚拟DOM(vdom) =&gt; 页面；</code></pre></code></pre></li></ul></li></ul><ul><li><strong>2.render()函数</strong></li></ul><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> render = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">var</span> _vm = <span class="hljs-variable language_">this</span>  <span class="hljs-keyword">var</span> _h = _vm.<span class="hljs-property">$createElement</span>  <span class="hljs-keyword">var</span> _c = _vm.<span class="hljs-property">_self</span>.<span class="hljs-property">_c</span> || _h  <span class="hljs-keyword">return</span> <span class="hljs-title function_">_c</span>(    <span class="hljs-string">&quot;div&quot;</span>,    &#123; <span class="hljs-attr">attrs</span>: &#123; <span class="hljs-attr">id</span>: <span class="hljs-string">&quot;app&quot;</span> &#125; &#125;,    [      <span class="hljs-title function_">_c</span>(<span class="hljs-string">&quot;img&quot;</span>, &#123; <span class="hljs-attr">attrs</span>: &#123; <span class="hljs-attr">src</span>: <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./assets/logo.png&quot;</span>) &#125; &#125;),      _vm.<span class="hljs-title function_">_v</span>(<span class="hljs-string">&quot; &quot;</span>),      <span class="hljs-title function_">_c</span>(<span class="hljs-string">&quot;router-view&quot;</span>)    ],    <span class="hljs-number">1</span>  )&#125;<span class="hljs-comment">// render函数返回的是虚拟DOM</span></code></pre><ul><li><ol start="3"><li>俩者的区别对比</li></ol></li></ul><pre><code class="hljs txt">（1）Runtime-only性能更高；（2）Runtime-only代码量更少；</code></pre><h2 id="4-Vue-CLI3-详解"><a href="#4-Vue-CLI3-详解" class="headerlink" title="4 Vue-CLI3 详解"></a>4 Vue-CLI3 详解</h2><p> <strong>CLI2 和 CLI3 的区别</strong></p><ul><li>vue-cli 3 与 2 版本有很大区别<ul><li>vue-cli 3 是基于 webpack 4 打造，vue-cli 2 还是 webapck 3</li><li>vue-cli 3 的设计原则是“<strong>0配置”，移除的配置文件根目录下的，build和config等目录</strong></li><li>vue-cli 3 提供了 vue ui 命令，提供了可视化配置，更加人性化</li><li><strong>移除了static文件夹，新增了public文件夹，并且index.html移动到public中</strong></li></ul></li></ul><h3 id="4-1-安装步骤详解"><a href="#4-1-安装步骤详解" class="headerlink" title="4.1  安装步骤详解"></a>4.1  安装步骤详解</h3><p><img src="https://i.loli.net/2020/09/25/sXYTBZDdym5GiF4.png" srcset="/img/loading.gif" alt="image-20200923113522511"></p><h3 id="4-2-目录结构详解"><a href="#4-2-目录结构详解" class="headerlink" title="4.2 目录结构详解"></a>4.2 目录结构详解</h3><p><img src="https://i.loli.net/2020/09/25/F6ybPXaMpt8vSIh.png" srcset="/img/loading.gif" alt="image-20200923113601396"></p>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webpack</title>
    <link href="/2020/09/25/21-webpack/"/>
    <url>/2020/09/25/21-webpack/</url>
    
    <content type="html"><![CDATA[<h1 id="webpack⭐"><a href="#webpack⭐" class="headerlink" title="webpack⭐"></a>webpack⭐</h1><h2 id="1-什么是webpack？"><a href="#1-什么是webpack？" class="headerlink" title="1 什么是webpack？"></a>1 什么是webpack？</h2><ul><li>官方解释： At its core, webpack is a static module bundler for modern JavaScript applications.</li><li>翻译： 从本质上来讲，webpack 是一个现代的JavaScript应用的静态<strong>模块打包</strong>工具</li></ul><p><img src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=3378498490,2105022646&fm=26&gp=0.jpg" srcset="/img/loading.gif" alt="img"></p><h3 id="1-1-模块"><a href="#1-1-模块" class="headerlink" title="1.1 模块"></a>1.1 模块</h3><ul><li>前端模块化：</li><li>目前使用前端模块化的一些方案：AMD、CMD、CommonJS、ES6。</li><li>在ES6之前，我们要想进行模块化开发，就必须借助于其他的工具，让我们可以进行模块化开发。</li><li>并且在通过模块化开发完成了项目后，还需要处理模块间的各种依赖，并且将其进行整合打包。</li><li>而webpack其中一个<strong>核心就是让我们可能进行模块化开发，并且会帮助我们处理模块间的依赖关系</strong>。</li><li>而且不仅仅是JavaScript文件，我们的CSS、图片、json文件等等在webpack中都可以被当做模块来使用</li><li>这就是webpack中模块化的概念。</li></ul><h3 id="1-2-打包"><a href="#1-2-打包" class="headerlink" title="1.2 打包"></a>1.2 打包</h3><ul><li>就是将webpack中的各种资源模块进行打包合并成一个或多个包(Bundle)。</li><li>并且在打包的过程中，还可以对资源进行处理，比如压缩图片，将scss转成css，将ES6语法转成ES5语法，将TypeScript转成JavaScript等等操作。</li><li>但是打包的操作似乎grunt/gulp也可以帮助我们完成，它们有什么不同呢？</li></ul><h3 id="1-3-和grunt-gulp的对比"><a href="#1-3-和grunt-gulp的对比" class="headerlink" title="1.3 和grunt/gulp的对比"></a>1.3 和grunt/gulp的对比</h3><ul><li>grunt/gulp的核心是<strong>Task</strong><ul><li>我们可以配置一系列的task，并且定义task要处理的事务（例如ES6、ts转化，图片压缩，scss转成css）</li><li>之后让grunt/gulp来依次执行这些task，而且让整个流程自动化。</li><li>所以grunt/gulp也被称为前端自动化任务管理工具。</li></ul></li></ul><ul><li>什么时候用grunt/gulp呢？<ul><li>如果你的工程模块依赖非常简单，甚至是没有用到模块化的概念。</li><li>只需要进行简单的合并、压缩，就使用grunt/gulp即可。</li><li>但是如果整个项目使用了模块化管理，而且相互依赖非常强，我们就可以使用更加强大的webpack了。</li></ul></li></ul><ul><li>grunt/gulp和webpack有什么不同呢？<ul><li>grunt/gulp更加强调的是前端流程的自动化，模块化不是它的核心。</li><li>webpack更加强调模块化开发管理，而文件压缩合并、预处理等功能，是他附带的功能。</li></ul></li></ul><h2 id="2-webpack的安装"><a href="#2-webpack的安装" class="headerlink" title="2  webpack的安装"></a>2  webpack的安装</h2><ul><li><p>安装webpack首先需要安装Node.js，Node.js自带了软件包管理工具npm<br>查看自己的node版本：</p><pre><code class="hljs shell">node -v</code></pre></li><li><p>全局安装webpack(这里我先指定版本号3.6.0，因为vue cli2依赖该版本)</p><pre><code class="hljs shell">npm install webpack@3.6.0 -g</code></pre></li><li><p>局部安装 webpack</p></li></ul><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 在对应目录下执行该命令</span></span>npm install webpack@3.6.0  --save-dev<span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#  因为webpack我们项目打包后不需要使用 ， 所以它只是我们开发时的一个工具  --save-dev  是开发时依赖</span></span></code></pre><ul><li><p>全局安装和局部安装的区别</p><ul><li>在终端直接执行的webpack命令，使用的是全局安装的webpack</li><li>当在packag.json中定义了scripts时，其中包含了webpack命令，那么使用的是局部webpack</li></ul><pre><code class="hljs json"><span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>   <span class="hljs-attr">&quot;test&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><span class="hljs-punctuation">,</span>   <span class="hljs-attr">&quot;bulid&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webpack&quot;</span> <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span></code></pre></li></ul><h2 id="3-webpack的配置"><a href="#3-webpack的配置" class="headerlink" title="3 webpack的配置"></a>3 webpack的配置</h2><h3 id="3-1-入口和出口"><a href="#3-1-入口和出口" class="headerlink" title="3.1 入口和出口"></a>3.1 入口和出口</h3><ul><li>如果每次使用webpack的命令都需要写上入口和出口作为参数，就很麻烦。</li><li>我们要创建一个 webpack.config.js文件</li></ul><p><img src="https://i.loli.net/2020/09/25/Pk7tDBJoyAeibQr.png" srcset="/img/loading.gif" alt="image-20200922173645764"></p><h3 id="3-2-如何使用局部安装的webpack"><a href="#3-2-如何使用局部安装的webpack" class="headerlink" title="3.2 如何使用局部安装的webpack"></a>3.2 如何使用局部安装的webpack</h3><h5 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h5><ul><li>第一步：项目中需要安装自己局部的webpack<ul><li>这里我们让局部安装   <a href="mailto:&#119;&#101;&#x62;&#112;&#97;&#x63;&#x6b;&#64;&#x33;&#x2e;&#x36;&#x2e;&#48;">&#119;&#101;&#x62;&#112;&#97;&#x63;&#x6b;&#64;&#x33;&#x2e;&#x36;&#x2e;&#48;</a> （因为我们要使用 脚手架2版本来学习）</li><li>Vue CLI3中已经升级到webpack4，但是它将配置文件隐藏了起来，所以查看起来不是很方便。</li></ul></li><li>第二步，通过node_modules/.bin/webpack启动webpack打包</li></ul><h5 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h5><ul><li>但是，每次执行都敲这么一长串有没有觉得不方便呢？<ul><li>OK，我们可以在package.json的scripts中定义自己的执行脚本。</li></ul></li><li>package.json中的scripts的脚本在执行时，会按照一定的顺序寻找命令对应的位置。<ul><li>首先，会寻找本地的node_modules/.bin路径中对应的命令。</li><li>如果没有找到，会去全局的环境变量中寻找。</li><li>如何执行我们的build指令呢？   <code>npm run bulid</code></li></ul></li><li><img src="https://i.loli.net/2020/09/26/RItGULf3edK1VSc.png" srcset="/img/loading.gif" alt="image-20200922174156285"></li></ul><h2 id="4-webpack-loader加载器"><a href="#4-webpack-loader加载器" class="headerlink" title="4 webpack-loader加载器"></a>4 webpack-loader加载器</h2><blockquote><p><strong>loader是webpack中一个非常核心的概念。</strong></p></blockquote><ul><li><p>webpack用来做什么呢？</p><ul><li><p>在我们之前的实例中，我们主要是用webpack来处理我们写的js代码，并且webpack会自动处理js之间相关的依赖。</p></li><li><p>但是，在开发中我们不仅仅有基本的js代码处理，我们也需要加载css、图片，也包括一些高级的将ES6转成ES5代码，将</p><p>TypeScript转成ES5代码，将scss、less转成css，将.jsx、.vue文件转成js文件等等。</p></li><li><p>对于webpack本身的能力来说，对于这些转化是不支持的。</p></li><li><p>那怎么办呢？给webpack扩展对应的loader就可以啦。</p></li></ul></li><li><p>loader使用过程：</p><ul><li>步骤一：通过npm安装需要使用的loader</li><li>步骤二：在webpack.config.js中的modules关键字下进行配置</li></ul></li><li><p>大部分loader我们都可以在webpack的官网中找到，并且学习对应的用法。</p></li></ul><p>webpack.config.js 文件如下：  <strong>如何配置 响应的 loader 在module内</strong></p><pre><code class="hljs JSON">const path = require(&#x27;path&#x27;)module.exports = <span class="hljs-punctuation">&#123;</span>  entry<span class="hljs-punctuation">:</span> &#x27;./src/main.js&#x27;<span class="hljs-punctuation">,</span>  output<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>    path<span class="hljs-punctuation">:</span> path.resolve(__dirname<span class="hljs-punctuation">,</span> &#x27;dist&#x27;)<span class="hljs-punctuation">,</span>    filename<span class="hljs-punctuation">:</span> &#x27;bundle.js&#x27;<span class="hljs-punctuation">,</span>    publicPath<span class="hljs-punctuation">:</span> &#x27;dist/&#x27;  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>  module<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>    rules<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span>        test<span class="hljs-punctuation">:</span> /\.css$/<span class="hljs-punctuation">,</span>        <span class="hljs-comment">// style-loader 负责将样式添加到DOM中</span>        <span class="hljs-comment">// css-loader 负责将css文件进行加载</span>        <span class="hljs-comment">// 注意：  使用多个 loader时， webpack是从右向左解析的</span>        use<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>&#x27;style-loader&#x27;<span class="hljs-punctuation">,</span> &#x27;css-loader&#x27;<span class="hljs-punctuation">]</span>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>      <span class="hljs-punctuation">&#123;</span>        test<span class="hljs-punctuation">:</span> /\.(png|jpg|gif)$/<span class="hljs-punctuation">,</span>        use<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span>          loader<span class="hljs-punctuation">:</span> &#x27;file-loader&#x27;<span class="hljs-punctuation">,</span>          options<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>            name<span class="hljs-punctuation">:</span> &#x27;img/<span class="hljs-punctuation">[</span>name<span class="hljs-punctuation">]</span>.<span class="hljs-punctuation">[</span>hash<span class="hljs-punctuation">:</span><span class="hljs-number">8</span><span class="hljs-punctuation">]</span>.<span class="hljs-punctuation">[</span>ext<span class="hljs-punctuation">]</span>&#x27;          <span class="hljs-punctuation">&#125;</span>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>      <span class="hljs-punctuation">&#123;</span>        test<span class="hljs-punctuation">:</span> /\.js$/<span class="hljs-punctuation">,</span>        exclude<span class="hljs-punctuation">:</span> /(node_modules|bower_components)/<span class="hljs-punctuation">,</span>        use<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>          loader<span class="hljs-punctuation">:</span> &#x27;babel-loader&#x27;<span class="hljs-punctuation">,</span>          options<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>            presets<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>&#x27;es2015&#x27;<span class="hljs-punctuation">]</span>          <span class="hljs-punctuation">&#125;</span>        <span class="hljs-punctuation">&#125;</span>      <span class="hljs-punctuation">&#125;</span>    <span class="hljs-punctuation">]</span>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span></code></pre><h2 id="5-webpack插件-plugin"><a href="#5-webpack插件-plugin" class="headerlink" title="5 webpack插件   plugin"></a>5 webpack插件   plugin</h2><ul><li>plugin是什么？<ul><li>plugin是插件的意思，通常是用于对某个现有的架构进行扩展。</li><li>webpack中的插件，就是对webpack现有功能的各种扩展，比如打包优化，文件压缩等等。</li></ul></li><li>loader和plugin区别<ul><li>loader主要用于转换某些类型的模块，它是一个转换器。</li><li>plugin是插件，它是对webpack本身的扩展，是一个扩展器。</li></ul></li><li>plugin的使用过程：<ul><li>步骤一：通过npm安装需要使用的plugins(某些webpack已经内置的插件不需要安装)</li><li>步骤二：在webpack.config.js中的plugins中配置插件。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue插槽</title>
    <link href="/2020/09/25/20-vue%E6%8F%92%E6%A7%BD/"/>
    <url>/2020/09/25/20-vue%E6%8F%92%E6%A7%BD/</url>
    
    <content type="html"><![CDATA[<h1 id="编译作用域⭐"><a href="#编译作用域⭐" class="headerlink" title="编译作用域⭐"></a>编译作用域⭐</h1><p><img src="https://i.loli.net/2020/09/25/9Zuw71bqsycSd8H.png" srcset="/img/loading.gif" alt="image-20200922160708539"></p><p><strong>根据以上图片代码， 可知 最后渲染出来的是 使用Vue实例的属性</strong></p><p>结论： </p><ul><li>官方给出了一条准则：<strong>父组件模板的所有东西都会在父级作用域内编译</strong>， <strong>子组件模板的所有东西都会在子级作用域内编译</strong></li><li>而我们在使用<my-cpn v-show="isShow"></my-cpn>的时候，整个组件的使用过程是相当于在父组件中出现的。</li><li>那么他的作用域就是父组件，使用的属性也是属于父组件的属性。</li><li>因此，isShow使用的是Vue实例中的属性，而不是子组件的属性。</li></ul><h1 id="solt插槽的基本使用⭐"><a href="#solt插槽的基本使用⭐" class="headerlink" title="solt插槽的基本使用⭐"></a>solt插槽的基本使用⭐</h1><p><img src="https://i.loli.net/2020/09/25/miSdjr5DNvCsH2O.png" srcset="/img/loading.gif" alt="image-20200922161624398"></p><h2 id="1-具名插槽"><a href="#1-具名插槽" class="headerlink" title="1 具名插槽"></a>1 具名插槽</h2><ul><li>当子组件的功能复杂时，子组件的插槽可能并非是一个。<ul><li>比如我们封装一个导航栏的子组件，可能就需要三个插槽，分别代表左边、中间、右边。</li><li>那么，外面在给插槽插入内容时，如何区分插入的是哪一个呢？</li><li>这个时候，我们就需要给插槽起一个名字</li></ul></li><li>如何使用具名插槽呢？<ul><li>非常简单，只要给slot元素一个name属性即可</li><li><slot name='myslot'></slot></li></ul></li></ul><p><img src="https://i.loli.net/2020/09/25/R12MJtQkvG5TErA.png" srcset="/img/loading.gif" alt="image-20200922161821227"></p><h2 id="2-作用域插槽"><a href="#2-作用域插槽" class="headerlink" title="2 作用域插槽"></a>2 作用域插槽</h2><blockquote><p>因为编译作用域的关系， 各个组件只能使用自己组件内的数据， 如果 父组件 使用插槽 想把子组件数据一并一起拿过来用怎么办？ 这时候就需要用 作用域插槽了</p></blockquote><p><strong>简单一句话：作用域插槽就是：父组件替换插槽的标签，但是内容（数据）是由子组件来提供。</strong></p><ul><li> <strong>1.子组件 插槽 slot 动态绑定  把data中的 <code>数据</code></strong> </li></ul><p><img src="https://i.loli.net/2020/09/25/EUPKAL7rYBFXZve.png" srcset="/img/loading.gif" alt="image-20200922163245338"></p><ul><li>2.<strong>父组件使用我们的子组件时，从子组件中拿到数据：</strong><ul><li><strong>我们通过<template slot-scope="slotProps">获取到slotProps属性</strong></li><li><strong>在通过slotProps.data就可以获取到刚才我们传入的data了</strong></li></ul></li></ul><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200922163259955.png" srcset="/img/loading.gif" alt="image-20200922163259955"></p>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue组件化开发</title>
    <link href="/2020/09/25/19-Vue%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/"/>
    <url>/2020/09/25/19-Vue%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<h1 id="组件化开发-⭐"><a href="#组件化开发-⭐" class="headerlink" title="组件化开发 ⭐"></a>组件化开发 ⭐</h1><h2 id="1-Vue-组件化思想⭐"><a href="#1-Vue-组件化思想⭐" class="headerlink" title="1. Vue 组件化思想⭐"></a>1. Vue 组件化思想⭐</h2><ul><li>组件化是Vuejs中的重要思想<ul><li>它提供了一种抽象，让我们可以开发出一个个独立可复用的小组件来构造我们的应用。</li><li>任何的应用都会被抽象成一颗组件树</li></ul></li></ul><p><img src="https://lipengzhou.com/vuejs/base/assets/components.png" srcset="/img/loading.gif" alt="Component Tree"></p><ul><li>组件化思想的应用：<ul><li>有了组件化的思想，我们在之后的开发中就要充分的利用它。</li><li>尽可能的将页面拆分成一个个小的，可复用的组件。</li><li>这样让我们的代码更加方便组织和管理，并且扩展性也更强。</li></ul></li></ul><h2 id="2-注册组件的基本步骤⭐"><a href="#2-注册组件的基本步骤⭐" class="headerlink" title="2.注册组件的基本步骤⭐"></a>2.注册组件的基本步骤⭐</h2><ul><li>组件的使用分为三个步骤:<ul><li>创建组件构造器</li><li>注册组件</li><li>使用组件</li></ul></li></ul><p><img src="https://i.loli.net/2020/09/25/FOCykHGvwR6TJns.png" srcset="/img/loading.gif" alt="image-20200920165211013"></p><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 3. 使用组件 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">cpn</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">cpn</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">cpn</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">cpn</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">cpn</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">cpn</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">cpn</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">cpn</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">  <span class="hljs-comment">// 1. 创建组件构造器对象</span></span><span class="language-javascript">  <span class="hljs-keyword">const</span> cpn = <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">extend</span>(&#123;</span><span class="language-javascript">    <span class="hljs-attr">template</span>: <span class="hljs-string">`    </span></span><span class="hljs-string"><span class="language-javascript">    &lt;div&gt;</span></span><span class="hljs-string"><span class="language-javascript">      &lt;h2&gt;注册组件步骤解析&lt;/h2&gt;</span></span><span class="hljs-string"><span class="language-javascript">      &lt;p&gt; 1. Vue.extend():  调用 Vue.extend() 创建的是一个组件构造器  通常在组件构造器时，传入template代表我们自定义组件的模板</span></span><span class="hljs-string"><span class="language-javascript">     该模板就是在使用组件的地方，要显示的HTML代码&lt;/p&gt;</span></span><span class="hljs-string"><span class="language-javascript">      &lt;p&gt;2.Vue.component(): 调用Vue.component()是将干柴的组件构造器注册为一个组件，并且给它起一个组件的标签名称，所以需要传递俩</span></span><span class="hljs-string"><span class="language-javascript">      个参数：1、注册组件的标签名，2、组件构造器&lt;/p&gt;</span></span><span class="hljs-string"><span class="language-javascript">      &lt;p&gt;3. 组件必须挂载在某个Vue实例下，否则它不会生效。&lt;/p&gt;</span></span><span class="hljs-string"><span class="language-javascript">    &lt;/div&gt;`</span></span><span class="language-javascript">  &#125;)</span><span class="language-javascript">  <span class="hljs-comment">// 2. 注册组件  方法一</span></span><span class="language-javascript">  <span class="hljs-comment">// Vue.component(&#x27;cpn&#x27;, cpn)</span></span><span class="language-javascript"></span><span class="language-javascript">  <span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><span class="language-javascript">    <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,</span><span class="language-javascript">    <span class="hljs-attr">data</span>: &#123;</span><span class="language-javascript">      <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;hello vue&#x27;</span>,</span><span class="language-javascript">    &#125;,</span><span class="language-javascript">    <span class="hljs-comment">// 2.注册组件 方法二</span></span><span class="language-javascript">    <span class="hljs-attr">components</span>: &#123;</span><span class="language-javascript">      cpn</span><span class="language-javascript">    &#125;</span><span class="language-javascript">  &#125;)</span><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><h3 id="2-1-注册组件步骤解析"><a href="#2-1-注册组件步骤解析" class="headerlink" title="2.1 注册组件步骤解析"></a>2.1 注册组件步骤解析</h3><ul><li><p><strong>Vue.extend()</strong>:     调用 Vue.extend() 创建的是一个组件构造器  通常在组件构造器时，传入template代表我们自定义组件的模板</p><p>该模板就是在使用组件的地方，要显示的HTML代码</p></li><li><p><strong>Vue.component()</strong>:     调用Vue.component()是将干柴的组件构造器注册为一个组件，并且给它起一个组件的标签名称，所以需要传递俩个参数： </p><ul><li><p><strong>1、注册组件的标签名，</strong></p></li><li><p><strong>2、组件构造器</strong></p></li><li><p><strong>组件必须挂载在某个Vue实例下，否则它不会生效</strong></p></li></ul></li></ul><h3 id="2-2-组件注册方式：全局组件-、局部组件"><a href="#2-2-组件注册方式：全局组件-、局部组件" class="headerlink" title="2.2 组件注册方式：全局组件  、局部组件"></a>2.2 组件注册方式：全局组件  、局部组件</h3><p>组件注册有俩种方式：</p><ul><li>全局组件<ul><li>​    定义在全局，在任意组件中都可以直接使用</li></ul></li><li>局部组件<ul><li>定义在组件内部，只能在当前组件中使用</li></ul></li></ul><p>建议把通用的组件定义在全局，把不通用的组件定义在局部</p><h4 id="全局组件"><a href="#全局组件" class="headerlink" title="全局组件"></a>全局组件</h4><p>注册：</p><pre><code class="hljs html">Vue.component(&quot;my-component&quot;, &#123;  template: &quot;<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>A custom component!<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>&quot;&#125;);// 创建根实例new Vue(&#123;  el: &quot;#example&quot;&#125;);</code></pre><p>在模板中使用组件：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;example&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">my-component</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">my-component</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><p>渲染结果：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;example&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>A custom component!<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><blockquote><p><strong>总结：</strong> </p><ul><li>可以在任何组件中被使用的组件（就好比全局变量）</li><li>如果应用中把所有组件都定义成全局组件，名字就不能有冲突</li><li>使用场景：多个页面都需要使用的组件建议定义成全局组件</li></ul></blockquote><h4 id="局部组件"><a href="#局部组件" class="headerlink" title="局部组件"></a>局部组件</h4><p>你不必把每个组件都注册到全局，你可以通过某个Vue实例/组件的实例选项 <code>components</code> 注册仅在其作用域中可用的组件：</p><p>注册：</p><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;  <span class="hljs-comment">// ...</span>  <span class="hljs-attr">components</span>: &#123;    <span class="hljs-comment">// &lt;my-component&gt; 将只在父组件模板中可用</span>    <span class="hljs-string">&quot;my-component&quot;</span>: &#123;      <span class="hljs-attr">template</span>: <span class="hljs-string">&quot;&lt;div&gt;A custom component!&lt;/div&gt;&quot;</span>    &#125;  &#125;&#125;);</code></pre><p>使用：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;example&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>A custom component!<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">my-component</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">my-component</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><p>总结：</p><ul><li>只能在它的父组件（定义所属的组件）中被使用，不会污染全局（就好比函数内部定义的变量）</li><li>使用组件的时候，会先在自己的 <code>components</code> 中找，如果找不到，<strong>直奔全局找</strong></li><li>局部组件 <strong>只能</strong> 在父组件中被使用， 爷爷、后代。。都不行</li><li>使用场景：不需要在其他组件中被使用的组件建议定义成局部</li></ul><h2 id="3-组件中的模板⭐"><a href="#3-组件中的模板⭐" class="headerlink" title="3.组件中的模板⭐"></a>3.组件中的模板⭐</h2><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">cpn</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">cpn</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-comment">&lt;!-- 1. 使用 script 标签 ， 类型必须是 text/x-template --&gt;</span>  <span class="hljs-comment">&lt;!-- &lt;script type=&quot;text/x-template&quot; id=&quot;cpn&quot;&gt;</span><span class="hljs-comment">    &lt;div&gt;</span><span class="hljs-comment">     &lt;h2&gt;组件模板的分离写法&lt;/h2&gt;</span><span class="hljs-comment">     &lt;p&gt;哈哈哈哈&lt;/p&gt;</span><span class="hljs-comment">    &lt;/div&gt;</span><span class="hljs-comment">&lt;/script&gt; --&gt;</span>  <span class="hljs-comment">&lt;!-- 2. 使用 template 标签 --&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;cpn&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123;title&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>哈哈哈哈<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">  <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;cpn&#x27;</span>, &#123;</span><span class="language-javascript">    <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;#cpn&#x27;</span>,</span><span class="language-javascript">    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">      <span class="hljs-keyword">return</span> &#123;</span><span class="language-javascript">        <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;组件模板的分离写法&#x27;</span></span><span class="language-javascript">      &#125;</span><span class="language-javascript">    &#125;</span><span class="language-javascript">  &#125;)</span><span class="language-javascript">  <span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><span class="language-javascript">    <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,</span><span class="language-javascript">    <span class="hljs-attr">data</span>: &#123;</span><span class="language-javascript">      <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;hello vue&#x27;</span>,</span><span class="language-javascript">    &#125;</span><span class="language-javascript">  &#125;)</span><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><p>小结：</p><ul><li>字符串模板 <code>template</code><ul><li>优点：合适快速学习测试，方便快捷</li><li>缺点：编辑器无法提供高亮显示，智能提示等</li></ul></li><li>.vue 单文件组件<ul><li>优点：更好的语法高亮，智能提示等</li><li>缺点：需要配合打包工具使用</li></ul></li><li>script 标签模板（了解，不常用）</li></ul><h2 id="4-组件中的data为什么必须是一个函数？⭐"><a href="#4-组件中的data为什么必须是一个函数？⭐" class="headerlink" title="4.组件中的data为什么必须是一个函数？⭐"></a>4.组件中的data为什么必须是一个函数？⭐</h2><ul><li>首先，如果不是一个函数，Vue直接就会报错。</li><li>其次，原因是在于Vue让每个组件对象都会返回一个新的对象，因为如果是同一个对象的，组件在多次使用后会相互影响。</li></ul><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">cpn</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">cpn</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">cpn</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">cpn</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">cpn</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">cpn</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;cpn&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>当前计数：&#123;&#123;current&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;add&quot;</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;sub&quot;</span>&gt;</span>-<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>      如果data是一个函数的话，这样每复用一次组件，就会返回一份新的data，      类似于给每个组件实例创建一个私有的数据空间，让各个组件实例维护各自的数据。      而单纯的写成对象形式，就使得所有组件实例共用了一份data，就会造成一个变了全都会变的结果。    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">  <span class="hljs-comment">// const obj = &#123;</span></span><span class="language-javascript">  <span class="hljs-comment">//   current: 0</span></span><span class="language-javascript">  <span class="hljs-comment">// &#125;</span></span><span class="language-javascript">  <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;cpn&#x27;</span>, &#123;</span><span class="language-javascript">    <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;#cpn&#x27;</span>,</span><span class="language-javascript">    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">      <span class="hljs-comment">// return obj</span></span><span class="language-javascript">      <span class="hljs-keyword">return</span> &#123;</span><span class="language-javascript">        <span class="hljs-attr">current</span>: <span class="hljs-number">0</span></span><span class="language-javascript">      &#125;</span><span class="language-javascript">    &#125;,</span><span class="language-javascript">    <span class="hljs-attr">methods</span>: &#123;</span><span class="language-javascript">      <span class="hljs-title function_">add</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">        <span class="hljs-variable language_">this</span>.<span class="hljs-property">current</span>++</span><span class="language-javascript">      &#125;,</span><span class="language-javascript">      <span class="hljs-title function_">sub</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">        <span class="hljs-variable language_">this</span>.<span class="hljs-property">current</span>--</span><span class="language-javascript">      &#125;</span><span class="language-javascript">    &#125;</span><span class="language-javascript">  &#125;)</span><span class="language-javascript">  <span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><span class="language-javascript">    <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,</span><span class="language-javascript">    <span class="hljs-attr">data</span>: &#123;</span><span class="language-javascript">      <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;hello vue&#x27;</span>,</span><span class="language-javascript">    &#125;</span><span class="language-javascript">  &#125;)</span><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="5-组件通信⭐"><a href="#5-组件通信⭐" class="headerlink" title="5.组件通信⭐"></a>5.组件通信⭐</h2><p>组件就像零散的积木，我们需要把这些积木按照一定的规则拼装起来，而且要让它们互相之间能进行通讯，这样才能构成一个有机的完整系统。</p><p>在真实的应用中，组件最终会构成树形结构，就像人类社会中的家族树一样：</p><p><img src="https://lipengzhou.com/vuejs/base/assets/891636a0-af23-11e7-b111-4d6e630f480d.png" srcset="/img/loading.gif" alt="891636a0-af23-11e7-b111-4d6e630f480d.png"></p><p>在树形结构里面，组件之间有几种典型的关系：父子关系、兄弟关系、没有直接关系。</p><p>相应地，组件之间有以下几种典型的通讯方案：</p><ul><li>直接的父子关系 <strong>(访问双方对象里面的一些方法)</strong><ul><li>父组件通过 <code>this.$refs</code> 访问子组件</li><li>子组件通过 <code>this.$parent</code> 访问父组件</li></ul></li><li>直接父子关系 <strong>（获取双方里面的数据）</strong><ul><li>父组件通过Props 给子组件下发数据</li><li>子组件通过事件方式给父组件发送消息</li></ul></li><li>没有直接关系<ul><li>简单场景：借助于事件机制进行通讯</li><li>复杂场景：使用状态管理容器</li></ul></li><li>利用 cookie 和  localstorage 进行通讯</li><li>利用 session 进行通讯</li></ul><p><strong>无论你使用什么前端框架，组件之间的通讯都离不开以上几种方案，这些方案与具体框架无关</strong></p><h3 id="5-1-父传子"><a href="#5-1-父传子" class="headerlink" title="5.1 父传子"></a>5.1 父传子</h3><p>组件设计初衷就是要配合使用的，最常见的就是形成父子组件的关系：组件 A 在它的模板中使用了组件 B。它们之间必然需要相互通信：父组件可能要给子组件下发数据，子组件则可能要将它内部发生的事情告知父组件。然而，通过一个良好定义的接口来尽可能将父子组件解耦也是很重要的。这保证了每个组件的代码可以在相对隔离的环境中书写和理解，从而提高了其可维护性和复用性。</p><p>在 Vue 中，父子组件的关系可以总结为 prop 向下传递，事件向上传递。父组件通过 prop 给子组件下发数据，子组件通过事件给父组件发送消息。看看它们是怎么工作的。</p><p><img src="https://i.loli.net/2020/09/25/fG3CE72y6FaexDu.png" srcset="/img/loading.gif" alt="image-20200920201644685"></p><h4 id="5-1-1-props-的基本使用"><a href="#5-1-1-props-的基本使用" class="headerlink" title="5.1.1 props 的基本使用"></a>5.1.1 props 的基本使用</h4><ul><li><p><strong>子组件 用 props 来接收 父组件传来的数据</strong></p></li><li><p>在组件中，使用选项props来声明需要从父级接受到的数据</p></li><li><p>props 的值有俩种方式</p><ul><li>方式一：字符串数组，数组中的字符串就是传递时的名称</li><li>方式二: 对象，对象可以设置传递</li></ul></li></ul><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">cpn</span> <span class="hljs-attr">:cmessage</span>=<span class="hljs-string">&quot;message&quot;</span> <span class="hljs-attr">:ccities</span>=<span class="hljs-string">&quot;cities&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">cpn</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;cpn&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123;ccities&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123;cmessage&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">P</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in ccities&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">P</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">  <span class="hljs-keyword">const</span> cpn = &#123;</span><span class="language-javascript">    <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;#cpn&#x27;</span>,</span><span class="language-javascript">    <span class="hljs-comment">// props: [&#x27;ccities&#x27;, &#x27;cmessage&#x27;]  // 1. 数组形式来传值</span></span><span class="language-javascript">    <span class="hljs-attr">props</span>: &#123;</span><span class="language-javascript">      <span class="hljs-comment">// 2. 对象形式   </span></span><span class="language-javascript">      <span class="hljs-comment">// 2.1 类型限制</span></span><span class="language-javascript">      <span class="hljs-comment">// cmessage: String,</span></span><span class="language-javascript">      <span class="hljs-comment">// ccities: Array</span></span><span class="language-javascript"></span><span class="language-javascript">      <span class="hljs-comment">// 2.2 提供一些默认值， 以及传值</span></span><span class="language-javascript">      <span class="hljs-attr">cmessage</span>: &#123;</span><span class="language-javascript">        <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>,</span><span class="language-javascript">        <span class="hljs-attr">default</span>: <span class="hljs-string">&#x27;默认值aa&#x27;</span>,</span><span class="language-javascript">      &#125;,</span><span class="language-javascript">      <span class="hljs-comment">// 类型对象如果是一个 数组或者对象时， 默认值必须是一个函数</span></span><span class="language-javascript">      <span class="hljs-attr">ccities</span>: &#123;</span><span class="language-javascript">        <span class="hljs-attr">type</span>: <span class="hljs-title class_">Array</span>,</span><span class="language-javascript">        <span class="hljs-keyword">default</span> () &#123;</span><span class="language-javascript">          <span class="hljs-keyword">return</span> [<span class="hljs-string">&#x27;初始1&#x27;</span>, <span class="hljs-string">&#x27;初始2&#x27;</span>, <span class="hljs-string">&#x27;初始3&#x27;</span>]</span><span class="language-javascript">        &#125;,</span><span class="language-javascript">      &#125;</span><span class="language-javascript">    &#125;</span><span class="language-javascript">  &#125;</span><span class="language-javascript">  <span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><span class="language-javascript">    <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,</span><span class="language-javascript">    <span class="hljs-attr">data</span>: &#123;</span><span class="language-javascript">      <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;hello vue&#x27;</span>,</span><span class="language-javascript">      <span class="hljs-attr">cities</span>: [<span class="hljs-string">&#x27;北京&#x27;</span>, <span class="hljs-string">&#x27;上海&#x27;</span>, <span class="hljs-string">&#x27;深圳&#x27;</span>]</span><span class="language-javascript">    &#125;,</span><span class="language-javascript">    <span class="hljs-attr">components</span>: &#123;</span><span class="language-javascript">      cpn</span><span class="language-javascript">    &#125;</span><span class="language-javascript">  &#125;)</span><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><h4 id="5-1-2-props数据验证"><a href="#5-1-2-props数据验证" class="headerlink" title="5.1.2  props数据验证"></a>5.1.2  props数据验证</h4><ul><li>我们可以为组件的 prop 指定验证规则。如果传入的数据不符合要求，Vue 会发出警告。这对于开发给他人使用的组件非常有用。 要指定验证规则，需要用对象的形式来定义 prop，而不能用字符串数组：</li><li>当需要对props进行类型等验证时，就需要对象写法了</li><li>验证都支持哪些数据类型呢？<ul><li>String</li><li>Number</li><li>Boolean</li><li>Array</li><li>Object</li><li>Date</li><li>Function</li><li>Symbol</li></ul></li><li>当我们有自定义构造函数时，验证也支持自定义的类型</li></ul><pre><code class="hljs javascript"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&quot;example&quot;</span>, &#123;  <span class="hljs-attr">props</span>: &#123;    <span class="hljs-comment">// 基础类型检测 (`null` 指允许任何类型)</span>    <span class="hljs-attr">propA</span>: <span class="hljs-title class_">Number</span>,    <span class="hljs-comment">// 可能是多种类型</span>    <span class="hljs-attr">propB</span>: [<span class="hljs-title class_">String</span>, <span class="hljs-title class_">Number</span>],    <span class="hljs-comment">// 必传且是字符串</span>    <span class="hljs-attr">propC</span>: &#123;      <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>,      <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>    &#125;,    <span class="hljs-comment">// 数值且有默认值</span>    <span class="hljs-attr">propD</span>: &#123;      <span class="hljs-attr">type</span>: <span class="hljs-title class_">Number</span>,      <span class="hljs-attr">default</span>: <span class="hljs-number">100</span>    &#125;,    <span class="hljs-comment">// 数组/对象的默认值应当由一个工厂函数返回</span>    <span class="hljs-attr">propE</span>: &#123;      <span class="hljs-attr">type</span>: <span class="hljs-title class_">Object</span>,      <span class="hljs-attr">default</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;hello&quot;</span> &#125;;      &#125;    &#125;,    <span class="hljs-comment">// 自定义验证函数</span>    <span class="hljs-attr">propF</span>: &#123;      <span class="hljs-attr">validator</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) &#123;        <span class="hljs-keyword">return</span> value &gt; <span class="hljs-number">10</span>;      &#125;    &#125;  &#125;&#125;);</code></pre><h3 id="5-2-子传父"><a href="#5-2-子传父" class="headerlink" title="5.2  子传父"></a>5.2  子传父</h3><h4 id="5-2-1-使用-自定义事件-来完成-emit"><a href="#5-2-1-使用-自定义事件-来完成-emit" class="headerlink" title="5.2.1 使用 自定义事件 来完成  $emit"></a>5.2.1 使用 自定义事件 来完成  $emit</h4><ul><li>props 用于父组件向子组件传递数据，还有一种比较常见的是子组件传递数据或事件到父组件中。</li><li>这个时候，我们需要用 <code>自定义事件</code> 来完成</li><li>什么时候需要自定义事件呢？<ul><li>当子组件需要向父组件传递数据时，就要用自定义事件了</li><li>我们之前学习的 v-on 不仅仅可以用于监听DOM事件，也可以用于组件的自定义事件</li></ul></li><li>自定义事件的流程：<ul><li>在子组件中，通过 $emit() 来触发事件。</li><li>在父组件中，通过 v-on 来监听子组件事件。</li></ul></li></ul><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>  <span class="hljs-comment">&lt;!-- 父组件模板 --&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>    <span class="hljs-comment">&lt;!--  自定义事件 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">cpn</span> @<span class="hljs-attr">itemclick</span>=<span class="hljs-string">&quot;cpnClick&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">cpn</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-comment">&lt;!-- 子组件模板 --&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;cpn&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in categories&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&#x27;btnClick(item)&#x27;</span>&gt;</span>&#123;&#123;item.name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">  <span class="hljs-comment">// 子组件</span></span><span class="language-javascript">  <span class="hljs-keyword">const</span> cpn = &#123;</span><span class="language-javascript">    <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;#cpn&#x27;</span>,</span><span class="language-javascript">    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">      <span class="hljs-keyword">return</span> &#123;</span><span class="language-javascript">        <span class="hljs-attr">categories</span>: [&#123;</span><span class="language-javascript">            <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>,</span><span class="language-javascript">            <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;热门推荐&#x27;</span></span><span class="language-javascript">          &#125;,</span><span class="language-javascript">          &#123;</span><span class="language-javascript">            <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>,</span><span class="language-javascript">            <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;数码相机&#x27;</span></span><span class="language-javascript">          &#125;,</span><span class="language-javascript">          &#123;</span><span class="language-javascript">            <span class="hljs-attr">id</span>: <span class="hljs-number">3</span>,</span><span class="language-javascript">            <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;电脑办公&#x27;</span></span><span class="language-javascript">          &#125;,</span><span class="language-javascript">          &#123;</span><span class="language-javascript">            <span class="hljs-attr">id</span>: <span class="hljs-number">4</span>,</span><span class="language-javascript">            <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;家用电器&#x27;</span></span><span class="language-javascript">          &#125;,</span><span class="language-javascript">        ]</span><span class="language-javascript">      &#125;</span><span class="language-javascript">    &#125;,</span><span class="language-javascript">    <span class="hljs-attr">methods</span>: &#123;</span><span class="language-javascript">      <span class="hljs-title function_">btnClick</span>(<span class="hljs-params">item</span>) &#123;</span><span class="language-javascript">        <span class="hljs-comment">// 发射事件，自定义事件   ()</span></span><span class="language-javascript">        <span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&#x27;itemclick&#x27;</span>, item)</span><span class="language-javascript">      &#125;</span><span class="language-javascript">    &#125;</span><span class="language-javascript">  &#125;</span><span class="language-javascript"></span><span class="language-javascript">  <span class="hljs-comment">// 父组件</span></span><span class="language-javascript">  <span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><span class="language-javascript">    <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,</span><span class="language-javascript">    <span class="hljs-attr">data</span>: &#123;</span><span class="language-javascript">      <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;hello vue&#x27;</span>,</span><span class="language-javascript">    &#125;,</span><span class="language-javascript">    <span class="hljs-attr">components</span>: &#123;</span><span class="language-javascript">      cpn</span><span class="language-javascript">    &#125;,</span><span class="language-javascript">    <span class="hljs-attr">methods</span>: &#123;</span><span class="language-javascript">      <span class="hljs-title function_">cpnClick</span>(<span class="hljs-params">item</span>) &#123;</span><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;cpnClick&#x27;</span>, item);</span><span class="language-javascript">      &#125;</span><span class="language-javascript">    &#125;</span><span class="language-javascript">  &#125;)</span><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><p><strong>子组件： 向 父组件用 $emit 发射一个自定义事件</strong> </p><pre><code class="hljs javascript"><span class="hljs-attr">methods</span>: &#123;      <span class="hljs-title function_">btnClick</span>(<span class="hljs-params">item</span>) &#123;        <span class="hljs-comment">// 发射事件，自定义事件   ()</span>        <span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&#x27;itemclick&#x27;</span>, item)      &#125;    &#125;</code></pre><p><strong>父组件模板 ：  用v-on来监听子组件</strong></p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>  <span class="hljs-comment">&lt;!--  自定义事件 --&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">cpn</span> @<span class="hljs-attr">itemclick</span>=<span class="hljs-string">&quot;cpnClick&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">cpn</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><p><strong>父组件 :  在父组件模板中用 v-on来监听子组件事件 然后 用自定义的事件来获取子组件的数据</strong></p><pre><code class="hljs javascript"><span class="hljs-attr">methods</span>: &#123;     <span class="hljs-title function_">cpnClick</span>(<span class="hljs-params">item</span>) &#123;       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;cpnClick&#x27;</span>, item);     &#125;   &#125;</code></pre><h3 id="5-3-父子组件通信-结合双向绑定案例"><a href="#5-3-父子组件通信-结合双向绑定案例" class="headerlink" title="5.3  父子组件通信-结合双向绑定案例"></a>5.3  父子组件通信-结合双向绑定案例</h3><ul><li>以下案例 实现 子传父 父传子 以及 上边的值 是下边的 100倍</li></ul><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">cpn</span> <span class="hljs-attr">v-bind:number1</span>=<span class="hljs-string">&quot;num1&quot;</span> <span class="hljs-attr">v-bind:number2</span>=<span class="hljs-string">&quot;num2&quot;</span> @<span class="hljs-attr">num1change</span>=<span class="hljs-string">&#x27;num1change&#x27;</span> @<span class="hljs-attr">num2change</span>=<span class="hljs-string">&#x27;num2change&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">cpn</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;cpn&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>props:&#123;&#123;number1&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>data:&#123;&#123;dnumber1&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>      <span class="hljs-comment">&lt;!-- &lt;input type=&quot;text&quot; v-model=&quot;dnumber1&quot;&gt; --&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">:vlaue</span>=<span class="hljs-string">&quot;dnumber1&quot;</span> @<span class="hljs-attr">input</span>=<span class="hljs-string">&quot;num1Input&quot;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>props:&#123;&#123;number2&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>data:&#123;&#123;dnumber2&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>      <span class="hljs-comment">&lt;!-- &lt;input type=&quot;text&quot; v-model=&quot;dnumber2&quot;&gt; --&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">:vlaue</span>=<span class="hljs-string">&quot;dnumber2&quot;</span> @<span class="hljs-attr">input</span>=<span class="hljs-string">&quot;num2Input&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">  <span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><span class="language-javascript">    <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,</span><span class="language-javascript">    <span class="hljs-attr">data</span>: &#123;</span><span class="language-javascript">      <span class="hljs-attr">num1</span>: <span class="hljs-number">0</span>,</span><span class="language-javascript">      <span class="hljs-attr">num2</span>: <span class="hljs-number">0</span></span><span class="language-javascript">    &#125;,</span><span class="language-javascript">    <span class="hljs-attr">methods</span>: &#123;</span><span class="language-javascript">      <span class="hljs-title function_">num1change</span>(<span class="hljs-params">value</span>) &#123;</span><span class="language-javascript">        <span class="hljs-variable language_">this</span>.<span class="hljs-property">num1</span> = <span class="hljs-title class_">Number</span>(value)</span><span class="language-javascript">      &#125;,</span><span class="language-javascript">      <span class="hljs-title function_">num2change</span>(<span class="hljs-params">value</span>) &#123;</span><span class="language-javascript">        <span class="hljs-variable language_">this</span>.<span class="hljs-property">num2</span> = <span class="hljs-title class_">Number</span>(value)</span><span class="language-javascript"></span><span class="language-javascript">      &#125;</span><span class="language-javascript">    &#125;,</span><span class="language-javascript">    <span class="hljs-attr">components</span>: &#123;</span><span class="language-javascript">      <span class="hljs-attr">cpn</span>: &#123;</span><span class="language-javascript">        <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;#cpn&#x27;</span>,</span><span class="language-javascript">        <span class="hljs-attr">props</span>: &#123;</span><span class="language-javascript">          <span class="hljs-attr">number1</span>: <span class="hljs-title class_">Number</span>,</span><span class="language-javascript">          <span class="hljs-attr">number2</span>: <span class="hljs-title class_">Number</span></span><span class="language-javascript">        &#125;,</span><span class="language-javascript">        <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">          <span class="hljs-keyword">return</span> &#123;</span><span class="language-javascript">            <span class="hljs-attr">dnumber1</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">number1</span>,</span><span class="language-javascript">            <span class="hljs-attr">dnumber2</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">number2</span></span><span class="language-javascript">          &#125;</span><span class="language-javascript">        &#125;,</span><span class="language-javascript">        <span class="hljs-attr">methods</span>: &#123;</span><span class="language-javascript">          <span class="hljs-title function_">num1Input</span>(<span class="hljs-params">event</span>) &#123;</span><span class="language-javascript">            <span class="hljs-comment">// 1.将input中的 value赋值到dnumber中</span></span><span class="language-javascript">            <span class="hljs-variable language_">this</span>.<span class="hljs-property">dnumber1</span> = event.<span class="hljs-property">target</span>.<span class="hljs-property">value</span></span><span class="language-javascript"></span><span class="language-javascript">            <span class="hljs-comment">// 2. 为了让父组件可以修改值，发出一个事件</span></span><span class="language-javascript">            <span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&#x27;num1change&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">dnumber1</span>)</span><span class="language-javascript"></span><span class="language-javascript">            <span class="hljs-comment">// 3. 影响 dnumber2的值， </span></span><span class="language-javascript">            <span class="hljs-variable language_">this</span>.<span class="hljs-property">dnumber2</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">dnumber1</span> * <span class="hljs-number">100</span></span><span class="language-javascript">            <span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&#x27;num2change&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">dnumber2</span>)</span><span class="language-javascript"></span><span class="language-javascript">          &#125;,</span><span class="language-javascript">          <span class="hljs-title function_">num2Input</span>(<span class="hljs-params">event</span>) &#123;</span><span class="language-javascript">            <span class="hljs-variable language_">this</span>.<span class="hljs-property">dnumber2</span> = event.<span class="hljs-property">target</span>.<span class="hljs-property">value</span></span><span class="language-javascript">            <span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&#x27;num2change&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">dnumber2</span>)</span><span class="language-javascript"></span><span class="language-javascript">            <span class="hljs-variable language_">this</span>.<span class="hljs-property">dnumber1</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">dnumber2</span> / <span class="hljs-number">100</span></span><span class="language-javascript">            <span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&#x27;num1change&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">dnumber1</span>)</span><span class="language-javascript">          &#125;</span><span class="language-javascript">        &#125;</span><span class="language-javascript">      &#125;</span><span class="language-javascript">    &#125;</span><span class="language-javascript">  &#125;)</span><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><h3 id="5-4-父子组件的访问"><a href="#5-4-父子组件的访问" class="headerlink" title="5.4 父子组件的访问"></a>5.4 父子组件的访问</h3><ul><li>有时候我们需要父组件直接访问子组件，子组件直接访问父组件，或者是子组件访问跟组件。<ul><li>父组件访问子组件：使用$children或$refs</li><li>子组件访问父组件：使用$parent</li></ul></li></ul><h4 id="5-4-1-children"><a href="#5-4-1-children" class="headerlink" title="5.4.1  $children"></a>5.4.1  $children</h4><ul><li>this.$children是一个数组类型，它包含所有子组件对象。</li><li>我们这里通过一个遍历，取出所有子组件的message状态。</li></ul><p><img src="https://i.loli.net/2020/09/25/A7mroRbg8aMWUHf.png" srcset="/img/loading.gif" alt="image-20200920230955986"></p><ul><li><strong>$children的缺陷：</strong><ul><li>通过$children访问子组件时，是一个数组类型，访问其中的子组件<strong>必须通过索引值。</strong></li><li>但是当子组件过多，我们需要拿到其中一个时，<strong>往往不能确定它的索引值</strong>，甚至还可能会发生变化。</li><li>有时候，我们想明确获取其中一个特定的组件，这个时候就可以使用**$refs**</li></ul></li></ul><h4 id="5-4-2-refs"><a href="#5-4-2-refs" class="headerlink" title="5.4.2 $refs"></a>5.4.2 $refs</h4><ul><li>$refs的使用：<ul><li>$refs和ref指令通常是一起使用的。</li><li>首先，我们通过ref给某一个子组件绑定一个特定的ID。</li><li>其次，通过this.$refs.ID就可以访问到该组件了。</li></ul></li></ul><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200920231328554.png" srcset="/img/loading.gif" alt="image-20200920231328554"></p>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue模板语法总结</title>
    <link href="/2020/09/25/18.Vue%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95/"/>
    <url>/2020/09/25/18.Vue%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="模板语法⭐"><a href="#模板语法⭐" class="headerlink" title="模板语法⭐"></a>模板语法⭐</h1><h2 id="1-插值操作"><a href="#1-插值操作" class="headerlink" title="1.插值操作"></a>1.插值操作</h2><ul><li>如何将data中的文本数据，插入到HTML中呢？<ul><li>我们已经学习过了，可以通过Mustache语法(也就是双大括号)。</li><li>Mustache: 胡子/胡须.</li></ul></li><li>我们可以像下面这样来使用，并且数据是响应式的<ul><li><img src="https://i.loli.net/2020/09/25/leUTF7VAxQEdYmI.png" srcset="/img/loading.gif" alt="Mustache"></li></ul></li></ul><h3 id="1-1-on-once-的基本使用"><a href="#1-1-on-once-的基本使用" class="headerlink" title="1.1 on-once 的基本使用"></a>1.1 on-once 的基本使用</h3><ul><li>在某些情况下，我们可能不希望界面随意的跟随改变<ul><li> 这个时候，我们就可以使用一个Vue的指令</li></ul></li></ul><pre><code class="hljs JavaScript">&lt;body&gt;  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123;message&#125;&#125; <span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="language-xml">    <span class="hljs-comment">&lt;!-- v-once 指令 就是 不能修改该变量了 --&gt;</span></span><span class="language-xml">    <span class="hljs-comment">&lt;!-- 该指令表示元素和组件只渲染一次，不会随着数据的改变而改变 --&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">v-once</span>&gt;</span>&#123;&#123;message&#125;&#125; <span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>&lt;/body&gt;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,</span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">data</span>: &#123;</span></span><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Hello Vue&#x27;</span></span></span><span class="language-javascript"><span class="language-xml">    &#125;</span></span><span class="language-javascript"><span class="language-xml">  &#125;)</span></span><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span></code></pre><p><img src="https://i.loli.net/2020/09/25/BmxRaKF34jDhCwe.png" srcset="/img/loading.gif" alt="image-20200919213449880"></p><h3 id="1-2-v-html的基本使用"><a href="#1-2-v-html的基本使用" class="headerlink" title="1.2 v-html的基本使用"></a>1.2 v-html的基本使用</h3><ul><li>某些情况下，我们从服务器请求到的数据本身就是一个HTML代码<ul><li>如果我们直接通过<code>双括号</code>来输出，会将HTML代码也一起输出。</li><li>但是我们可能希望的是按照HTML格式进行解析，并且显示对应的内容。</li></ul></li><li>如果我们希望解析出HTML展示<ul><li>可以使用v-html指令</li><li>该指令后面往往会跟上一个string类型</li><li>会将string的html解析出来并且进行渲染</li></ul></li></ul><pre><code class="hljs JavaScript">&lt;body&gt;  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123;url&#125;&#125; <span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">v-html</span>=<span class="hljs-string">&#x27;url&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>&lt;/body&gt;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,</span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">data</span>: &#123;</span></span><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;&lt;a href=&quot;https://www.baidu.com&quot;&gt;百度一下&lt;/a&gt;&#x27;</span></span></span><span class="language-javascript"><span class="language-xml">    &#125;</span></span><span class="language-javascript"><span class="language-xml">  &#125;)</span></span><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span></code></pre><p><img src="https://i.loli.net/2020/09/25/Mie5l2Iug38jbBf.png" srcset="/img/loading.gif" alt="image-20200919213423736"></p><h3 id="1-3-v-text-的基本用法"><a href="#1-3-v-text-的基本用法" class="headerlink" title="1.3 v-text 的基本用法"></a>1.3 v-text 的基本用法</h3><ul><li>v-text作用和Mustache比较相似：都是用于将数据显示在界面中</li><li>v-text通常情况下，接受一个string类型</li><li></li></ul><pre><code class="hljs JavaScript">&lt;body&gt;  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123;message&#125;&#125;,haha <span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="language-xml">    <span class="hljs-comment">&lt;!-- 会覆盖 hahha 不常用v-text  --&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">v-text</span>=<span class="hljs-string">&#x27;message&#x27;</span>&gt;</span>hahha<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>&lt;/body&gt;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,</span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">data</span>: &#123;</span></span><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;hello vue&#x27;</span></span></span><span class="language-javascript"><span class="language-xml">    &#125;</span></span><span class="language-javascript"><span class="language-xml">  &#125;)</span></span><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span></code></pre><h3 id="1-4-v-pre-的基本使用"><a href="#1-4-v-pre-的基本使用" class="headerlink" title="1.4 v-pre 的基本使用"></a>1.4 v-pre 的基本使用</h3><ul><li>v-pre用于跳过这个元素和它子元素的编译过程，用于显示原本的Mustache语法。</li><li>比如下面的代码：<ul><li>第一个p标签中的内容会被编译解析出来对应的内容</li><li>第二个p标签中会直接显示</li></ul></li></ul><p><img src="https://i.loli.net/2020/09/25/7F1aZ5Y92KXQCoc.png" srcset="/img/loading.gif" alt="image-20200919213843348"></p><pre><code class="hljs JavaScript">&lt;body&gt;  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123;message&#125;&#125; <span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="language-xml">    <span class="hljs-comment">&lt;!-- 不解析  message  只显示  &#123;&#123;message&#125;&#125; 这个文本 --&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">v-pre</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>&lt;/body&gt;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,</span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">data</span>: &#123;</span></span><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;hello vue&#x27;</span></span></span><span class="language-javascript"><span class="language-xml">    &#125;</span></span><span class="language-javascript"><span class="language-xml">  &#125;)</span></span><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span></code></pre><h3 id="1-5-v-cloak-的基本使用"><a href="#1-5-v-cloak-的基本使用" class="headerlink" title="1.5 v-cloak 的基本使用"></a>1.5 v-cloak 的基本使用</h3><ul><li>在某些情况下，我们浏览器可能会直接显然出未编译的Mustache标签。</li><li>cloak: 斗篷</li><li><strong>在刷新之前不希望把 {message}} 以这种形式显示出来</strong></li></ul><pre><code class="hljs JavaScript">&lt;style&gt;  [v-cloak] &#123;    <span class="hljs-attr">display</span>: none;  &#125;&lt;/style&gt;&lt;!-- 在刷新之前不希望把 &#123;message&#125;&#125; 以这种形式显示出来 --&gt;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">v-cloak</span>&gt;</span>&#123;&#123;message&#125;&#125; <span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><span class="language-javascript"><span class="language-xml">  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;</span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span></span><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,</span></span><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">data</span>: &#123;</span></span><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;hello vue&#x27;</span></span></span><span class="language-javascript"><span class="language-xml">      &#125;</span></span><span class="language-javascript"><span class="language-xml">    &#125;)</span></span><span class="language-javascript"><span class="language-xml">  &#125;, <span class="hljs-number">1000</span>)</span></span><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span></code></pre><h2 id="2-绑定属性-v-bind的使用"><a href="#2-绑定属性-v-bind的使用" class="headerlink" title="2. 绑定属性   v-bind的使用"></a>2. 绑定属性   v-bind的使用</h2><ul><li><p>除了内容需要动态来决定外，某些属性我们也希望动态来绑定。</p><ul><li>比如动态绑定a元素的href属性</li><li>比如动态绑定img元素的src属性</li></ul></li><li><p>这个时候，我们可以使用v-bind指令：</p><ul><li><strong>作用：动态绑定属性</strong></li><li><strong>缩写：<code>:</code></strong></li><li><strong>预期：any (with argument) | Object (without argument)</strong></li><li><strong>参数：attrOrProp (optional)</strong></li></ul><pre><code class="hljs JavaScript">&lt;body&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;!-- 错误 : 这里不能使用 Msutache 语法 urlImages --&gt;    &lt;!-- &lt;img src=&quot;&#123;&#123;urlImage&#125;&#125;&quot; alt=&quot;&quot;&gt; --&gt;    &lt;!-- 使用 v-bind指令 来绑定属性 --&gt;    &lt;h2&gt;&#123;&#123;message&#125;&#125; &lt;/h2&gt;    &lt;img v-bind:src=&quot;urlImage&quot; alt=&quot;&quot;&gt;    &lt;!-- v-bind 提供了一个语法糖 v-bind 对应的是 :  --&gt;    &lt;img :src=&quot;urlImage&quot; alt=&quot;&quot;&gt;  &lt;/div&gt;&lt;/body&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt;  const app = new Vue(&#123;    el: &#x27;#app&#x27;,    data: &#123;      message: &#x27;hello vue&#x27;,      urlImage: &#x27;https://i0.hdslb.com/bfs/space/cb1c3ef50e22b6096fde67febe863494caefebad.png@2200w_400h_1o.webp&#x27;    &#125;  &#125;)&lt;/script&gt;</code></pre><p><img src="https://i.loli.net/2020/09/25/6ANtm94IQCjJsvr.png" srcset="/img/loading.gif" alt="image-20200919215146368"></p></li></ul><h3 id="2-1-v-bind-绑定-class-对象语法"><a href="#2-1-v-bind-绑定-class-对象语法" class="headerlink" title="2.1 v-bind 绑定 class  (对象语法)"></a>2.1 v-bind 绑定 class  (对象语法)</h3><ul><li><p>绑定方式：对象语法</p><ul><li>对象语法的含义是:class后面跟的是一个对象。</li><li>对象语法有下面这些用法：</li></ul><pre><code class="hljs HTML">用法一：直接通过&#123;&#125;绑定一个类<span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;&#123;&#x27;active&#x27;: isActive&#125;&quot;</span>&gt;</span>Hello World<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>用法二：也可以通过判断，传入多个值<span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;&#123;&#x27;active&#x27;: isActive, &#x27;line&#x27;: isLine&#125;&quot;</span>&gt;</span>Hello World<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>用法三：和普通的类同时存在，并不冲突注：如果isActive和isLine都为true，那么会有title/active/line三个类<span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;title&quot;</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;&#123;&#x27;active&#x27;: isActive, &#x27;line&#x27;: isLine&#125;&quot;</span>&gt;</span>Hello World<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>用法四：如果过于复杂，可以放在一个methods或者computed中注：classes是一个计算属性<span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;title&quot;</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;classes&quot;</span>&gt;</span>Hello World<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></code></pre></li></ul><h3 id="2-2-v-bind-绑定-style"><a href="#2-2-v-bind-绑定-style" class="headerlink" title="2.2 v-bind 绑定 style"></a>2.2 v-bind 绑定 style</h3><p><strong>:style=”{color: currentColor, fontSize: fontSize + ‘px’}”</strong></p><ul><li>style后面跟的是一个对象类型<ul><li>对象的key是CSS属性名称</li><li>对象的value是具体赋的值，值可以来自于data中的属性</li></ul></li></ul><pre><code class="hljs JavaScript">&lt;body&gt;  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span></span><span class="language-xml">    <span class="hljs-comment">&lt;!-- &lt;h2 :style=&quot;&#123;CSS属性名:&#x27;value属性值&#x27;&#125;&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; --&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;&#123;fontSize:&#x27;50px&#x27;,color:&#x27;red&#x27;&#125;&quot;</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>&lt;/body&gt;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,</span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">data</span>: &#123;</span></span><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;hello vue&#x27;</span>,</span></span><span class="language-javascript"><span class="language-xml">    &#125;</span></span><span class="language-javascript"><span class="language-xml">  &#125;)</span></span><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span></code></pre><h2 id="3-计算属性"><a href="#3-计算属性" class="headerlink" title="3.计算属性"></a>3.计算属性</h2><h3 id="3-1什么是计算属性，为什么要使用它"><a href="#3-1什么是计算属性，为什么要使用它" class="headerlink" title="3.1什么是计算属性，为什么要使用它"></a>3.1什么是计算属性，为什么要使用它</h3><p><strong>模板内的表达式非常便利，但是设计它们的初衷是用于简单运算的。在模板中放入太多的逻辑会让模板过重且难以维护,例如：</strong></p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;example&quot;</span>&gt;</span>  &#123;&#123; message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><p><strong>在这个地方，模板不再是简单的声明式逻辑，你必须看一段时间才能意识到，这里是想要显示变量 <code>message</code> 的翻转字符串，当你想要在模板中多次引用此处的翻转字符串时，就会更加难以处理。</strong></p><ul><li>使用 方法 methods</li><li>使用 计算属性 compute</li></ul><h3 id="3-2-计算属性和方法的区别"><a href="#3-2-计算属性和方法的区别" class="headerlink" title="3.2 计算属性和方法的区别"></a>3.2 计算属性和方法的区别</h3><ul><li>计算属性是基于他们的响应式依赖进行缓存的，只在相关响应式依赖发生改变时，才会重新求值（也就是说，计算属性会把数据进行缓存）</li><li>而方法不会把数据进行缓存， 所以用计算属性效率会更高点</li></ul><p><strong>所以，对于任何复杂逻辑，都应该使用计算属性</strong></p><ul><li>在某些情况，我们可能需要对数据进行一些转化后再显示，或者需要将多个数据结合起来进行显示<ul><li>比如我们有firstName和lastName两个变量，我们需要显示完整的名称。</li><li>但是如果多个地方都需要显示完整的名称，我们就需要写多个 </li></ul></li></ul><pre><code class="hljs JavaScript">&lt;body&gt;  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123;firstName + &#x27; &#x27; + lastName&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123;firstName&#125;&#125; &#123;&#123;lastName&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123;getFullName()&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123;fullName&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>&lt;/body&gt;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,</span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">data</span>: &#123;</span></span><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">firstName</span>: <span class="hljs-string">&#x27;Lron&#x27;</span>,</span></span><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">lastName</span>: <span class="hljs-string">&#x27;Man&#x27;</span></span></span><span class="language-javascript"><span class="language-xml">    &#125;,</span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 推荐使用计算属性来操作，因为它会将这些数据进行缓存， 无论打印多少次，它只会调用一次</span></span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">computed</span>: &#123; <span class="hljs-comment">//  计算属性   注意 : 计算的是 属性,  所以这里面的属性 看成一个 对象(用名词形式来表达), 调用时候不用加小括号</span></span></span><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">fullName</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span></span><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span> + <span class="hljs-string">&#x27; &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastName</span></span></span><span class="language-javascript"><span class="language-xml"></span></span><span class="language-javascript"><span class="language-xml">      &#125;</span></span><span class="language-javascript"><span class="language-xml">    &#125;,</span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">methods</span>: &#123;</span></span><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">//  不会缓存， 所以有多少次就调用多少次，  没有 computed 划算</span></span></span><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">getFullName</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span></span><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span> + <span class="hljs-string">&#x27; &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastName</span></span></span><span class="language-javascript"><span class="language-xml">      &#125;</span></span><span class="language-javascript"><span class="language-xml">    &#125;</span></span><span class="language-javascript"><span class="language-xml">  &#125;)</span></span><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span></code></pre><h3 id="3-3-计算属性的setter和getter"><a href="#3-3-计算属性的setter和getter" class="headerlink" title="3.3 计算属性的setter和getter"></a>3.3 计算属性的setter和getter</h3><blockquote><p>每个计算属性都有 set 和 get 方法 ，但一般我们不用去设置 set 方法， 只用 get 的方法  只读属性</p></blockquote><pre><code class="hljs JavaScript"><span class="hljs-attr">computed</span>:&#123;    <span class="hljs-attr">fullName</span>:&#123;        <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>)&#123;&#125;,        <span class="hljs-title function_">set</span>(<span class="hljs-params"></span>)&#123;&#125;    &#125;&#125;<span class="hljs-comment">// 由于不经常用set， 如果只用 get方法的话 可以直接简化的成下面的。 </span><span class="hljs-title function_">fullName</span>(<span class="hljs-params"></span>)&#123;            &#125;</code></pre><h2 id="4-监听事件-v-on-，事件处理"><a href="#4-监听事件-v-on-，事件处理" class="headerlink" title="4.监听事件(v-on)，事件处理"></a>4.监听事件(v-on)，事件处理</h2><ul><li><p>在前端开发中，我们需要经常和用于交互。</p><ul><li>这个时候，我们就必须监听用户发生的时间，比如点击、拖拽、键盘事件等等</li><li>在Vue中如何监听事件呢？使用v-on指令</li></ul></li><li><p>v-on介绍</p><ul><li>作用：绑定事件监听器</li><li>缩写：@</li><li>预期：Function | Inline Statement | Object</li><li>参数：event</li></ul></li></ul><h3 id="4-1-v-on-基本语法"><a href="#4-1-v-on-基本语法" class="headerlink" title="4.1 v-on 基本语法"></a>4.1 v-on 基本语法</h3>  <pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;onClick&quot;</span>&gt;</span>测试<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>      <span class="hljs-comment">&lt;!-- 技巧：原生的怎么写，只需要把 on 替换为 v-on: --&gt;</span>      <span class="hljs-comment">&lt;!-- &lt;input type=&quot;text&quot; v-on:keydown=&quot;&quot;&gt; --&gt;</span>      <span class="hljs-comment">&lt;!-- &lt;input type=&quot;text&quot; v-on:keyup=&quot;&quot;&gt; --&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;node_modules/vue/dist/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">      <span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><span class="language-javascript">        <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>,</span><span class="language-javascript">        <span class="hljs-attr">data</span>: &#123;</span><span class="language-javascript">          <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;Hello Vue.js!&quot;</span></span><span class="language-javascript">        &#125;,</span><span class="language-javascript">        <span class="hljs-comment">/**</span></span><span class="hljs-comment"><span class="language-javascript">         * 实例选项 methods，存储模板中使用的方法</span></span><span class="hljs-comment"><span class="language-javascript">         */</span></span><span class="language-javascript">        <span class="hljs-attr">methods</span>: &#123;</span><span class="language-javascript">   </span><span class="language-javascript">          <span class="hljs-title function_">onClick</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">            <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;hello&quot;</span>);</span><span class="language-javascript">          &#125;</span><span class="language-javascript">        &#125;</span><span class="language-javascript">      &#125;);</span><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><h3 id="4-2-处理函数的-this-指向"><a href="#4-2-处理函数的-this-指向" class="headerlink" title="4.2 处理函数的 this 指向"></a>4.2 处理函数的 this 指向</h3><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;onClick&quot;</span>&gt;</span>测试<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;onClick2&quot;</span>&gt;</span>测试2<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;node_modules/vue/dist/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">      <span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><span class="language-javascript">        <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>,</span><span class="language-javascript">        <span class="hljs-attr">data</span>: &#123;</span><span class="language-javascript">          <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;Hello Vue.js!&quot;</span></span><span class="language-javascript">        &#125;,</span><span class="language-javascript">        <span class="hljs-attr">methods</span>: &#123;</span><span class="language-javascript">          <span class="hljs-title function_">onClick</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">            <span class="hljs-comment">// 事件处理函数中的 this 指向的是 Vue 实例对象，也就是 app</span></span><span class="language-javascript">            <span class="hljs-comment">// 注意：事件处理函数不能使用箭头函数定义</span></span><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span> === app);</span><span class="language-javascript"></span><span class="language-javascript">            <span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span> = <span class="hljs-string">&quot;hello&quot;</span>;</span><span class="language-javascript">          &#125;,</span><span class="language-javascript"></span><span class="language-javascript">          <span class="hljs-comment">// 注意：箭头函数定义的 methods 其中的 this 指向的是 window</span></span><span class="language-javascript">          <span class="hljs-comment">// 除非你不需要在函数中访问 Vue 实例 this，你可以定义箭头函数</span></span><span class="language-javascript">          <span class="hljs-comment">// 何必呢？</span></span><span class="language-javascript">          <span class="hljs-attr">onClick2</span>: <span class="hljs-function">() =&gt;</span> &#123;</span><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);</span><span class="language-javascript">          &#125;</span><span class="language-javascript">        &#125;</span><span class="language-javascript">      &#125;);</span><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><h3 id="4-3-v-on-的参数传递问题"><a href="#4-3-v-on-的参数传递问题" class="headerlink" title="4.3 v-on 的参数传递问题"></a>4.3 v-on 的参数传递问题</h3><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 1.事件调用的方法没有参数 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;btn1()&quot;</span>&gt;</span>按钮1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;btn1&quot;</span>&gt;</span>按钮1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 2.在事件定义时，写方法时省略了小括号，但是方法本身是需要一个参数，</span><span class="hljs-comment">    这个时候，Vue会默认将浏览器生产的event事件对象作为参数传入到方法中 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;btn2(123)&quot;</span>&gt;</span>按钮2<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span> <span class="hljs-comment">&lt;!-- 123--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;btn2()&quot;</span>&gt;</span>按钮2<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span> <span class="hljs-comment">&lt;!-- undefined--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;btn2&quot;</span>&gt;</span>按钮2<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span> <span class="hljs-comment">&lt;!-- event事件对象--&gt;</span>    <span class="hljs-comment">&lt;!-- 3.方法定义时，我们需要event对象，同时也需要其他对象 俩个参数不分先后 --&gt;</span>    <span class="hljs-comment">&lt;!-- 在调用方式，如何手动的获取浏览器参数event对象： $event  --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;btn3(123,$event)&quot;</span>&gt;</span>按钮3<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">  <span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><span class="language-javascript">    <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,</span><span class="language-javascript">    <span class="hljs-attr">data</span>: &#123;</span><span class="language-javascript"></span><span class="language-javascript">    &#125;,</span><span class="language-javascript">    <span class="hljs-attr">methods</span>: &#123;</span><span class="language-javascript">      <span class="hljs-title function_">btn1</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;btn1&#x27;</span>);</span><span class="language-javascript">      &#125;,</span><span class="language-javascript">      <span class="hljs-title function_">btn2</span>(<span class="hljs-params">event</span>) &#123;</span><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(event);</span><span class="language-javascript">      &#125;,</span><span class="language-javascript">      <span class="hljs-title function_">btn3</span>(<span class="hljs-params">abc, event</span>) &#123;</span><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(abc, event);</span><span class="language-javascript">      &#125;</span><span class="language-javascript">    &#125;</span><span class="language-javascript">  &#125;)</span><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><h3 id="4-4-v-on-修饰符"><a href="#4-4-v-on-修饰符" class="headerlink" title="4.4  v-on 修饰符"></a>4.4  v-on 修饰符</h3><ul><li>.stop - 调用 event.stopPropagation()。</li><li>.prevent - 调用 event.preventDefault()。</li><li>.{keyCode | keyAlias} - 只当事件是从特定键触发时才触发回调。</li><li>.native - 监听组件根元素的原生事件。</li><li>.once - 只触发一次回调。</li></ul><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">  <span class="hljs-selector-class">.my</span> &#123;</span><span class="language-css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><span class="language-css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><span class="language-css">    <span class="hljs-attribute">background-color</span>: pink;</span><span class="language-css">  &#125;</span><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>.stop : 调用 event.stopPropagation() 阻止冒泡事件<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>.prevent : 调用 event.preventDefault() 阻止默认事件<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span> .[keyCode|keyAlias] 只当事件是从待定键触发时才触发回调<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;my&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;divClick&quot;</span>&gt;</span>      <span class="hljs-comment">&lt;!-- 使用 .stop 修饰符 能够阻止事件冒泡 --&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click.stop</span>=<span class="hljs-string">&quot;btnClick&quot;</span>&gt;</span>按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;aaa&quot;</span>&gt;</span>      <span class="hljs-comment">&lt;!-- 使用  .prevent 修饰符 能够阻止默认事件 --&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;提交&quot;</span> @<span class="hljs-attr">click.prevent</span>=<span class="hljs-string">&quot;inpClick&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 监听某个键盘的键帽 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> @<span class="hljs-attr">keyup.enter</span>=<span class="hljs-string">&quot;keyup&quot;</span>&gt;</span> <span class="hljs-comment">&lt;!-- 监听回车键  --&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">  <span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><span class="language-javascript">    <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,</span><span class="language-javascript">    <span class="hljs-attr">data</span>: &#123;</span><span class="language-javascript">      <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;hello vue&#x27;</span>,</span><span class="language-javascript">    &#125;,</span><span class="language-javascript">    <span class="hljs-attr">methods</span>: &#123;</span><span class="language-javascript">      <span class="hljs-title function_">divClick</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;div&#x27;</span>);</span><span class="language-javascript">      &#125;,</span><span class="language-javascript">      <span class="hljs-title function_">btnClick</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;btn&#x27;</span>);</span><span class="language-javascript">      &#125;,</span><span class="language-javascript">      <span class="hljs-title function_">inpClick</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;inp&#x27;</span>);</span><span class="language-javascript">      &#125;,</span><span class="language-javascript">      <span class="hljs-title function_">keyup</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;keyup&#x27;</span>);</span><span class="language-javascript">      &#125;</span><span class="language-javascript">    &#125;</span><span class="language-javascript">  &#125;)</span><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><h2 id="5-条件判断"><a href="#5-条件判断" class="headerlink" title="5.条件判断"></a>5.条件判断</h2><h3 id="5-1-v-if-、-v-else-if-、-v-else"><a href="#5-1-v-if-、-v-else-if-、-v-else" class="headerlink" title="5.1 v-if 、 v-else-if 、 v-else"></a>5.1 v-if 、 v-else-if 、 v-else</h3><ul><li><p>v-if、v-else-if、v-else</p><ul><li>这三个指令与JavaScript的条件语句if、else、else if类似。</li><li>Vue的条件指令可以根据表达式的值在DOM中渲染或销毁元素或组件</li></ul></li></ul><h3 id="5-2-v-if-和-v-show-的区别"><a href="#5-2-v-if-和-v-show-的区别" class="headerlink" title="5.2 v-if 和 v-show 的区别"></a>5.2 v-if 和 v-show 的区别</h3><ul><li>v-if条件渲染，如果条件为 false ， 则不渲染元素<ul><li> true 渲染 DOM</li><li> false 不渲染 DOM</li></ul></li><li>v-show 条件显示，无论条件的真假始终都渲染元素<ul><li>true 渲染 DOM</li><li>false 渲染DOM ，但不显示（display：none）</li><li>不能和  v-else-if 、 v-else 结合使用</li></ul></li></ul><blockquote><p>一般来说， <code>v-if</code> 有更高的切换开销， 而 <code>v-show</code> 有更高的初始渲染开销。 因此、如果需要非常频繁地切换，则使用 <code>v-show</code> 较好； 如果在运行时条件很少改变，则使用<code>v-if</code> 较好</p></blockquote><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>  <span class="hljs-comment">&lt;!-- 当需要在显示和隐藏之间切换频繁时，使用v-show </span><span class="hljs-comment">       当只有一次切换时，通过使用v-if</span><span class="hljs-comment">  --&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 当条件为false时， v-if压根不会有对应的元素在DOM中 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;isShow&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;A&quot;</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 当条件为false时， v-show 仅仅是将元素的display属性设置为了none而已 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;isShow&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;B&quot;</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">  <span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><span class="language-javascript">    <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,</span><span class="language-javascript">    <span class="hljs-attr">data</span>: &#123;</span><span class="language-javascript">      <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;hello vue&#x27;</span>,</span><span class="language-javascript">      <span class="hljs-attr">isShow</span>: <span class="hljs-literal">false</span></span><span class="language-javascript">    &#125;</span><span class="language-javascript">  &#125;)</span><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><h2 id="6-循环遍历"><a href="#6-循环遍历" class="headerlink" title="6.循环遍历"></a>6.循环遍历</h2><h3 id="6-1-v-for-遍历数组"><a href="#6-1-v-for-遍历数组" class="headerlink" title="6.1 v-for 遍历数组"></a>6.1 v-for 遍历数组</h3><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>    <span class="hljs-comment">&lt;!-- v-for 第一个参数是 数组中的元素， 第二个参数是 索引值 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in names&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item,index) in names&quot;</span>&gt;</span>&#123;&#123;index&#125;&#125;.&#123;&#123;item&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">  <span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><span class="language-javascript">    <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,</span><span class="language-javascript">    <span class="hljs-attr">data</span>: &#123;</span><span class="language-javascript">      <span class="hljs-attr">names</span>: [<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-string">&#x27;李四&#x27;</span>, <span class="hljs-string">&#x27;王五&#x27;</span>]</span><span class="language-javascript">    &#125;</span><span class="language-javascript">  &#125;)</span><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><h3 id="6-2-检测数组更新"><a href="#6-2-检测数组更新" class="headerlink" title="6.2 检测数组更新"></a>6.2 检测数组更新</h3><p> <strong>这些常见的数组操作方法都会正常的进行视图更新：</strong></p><pre><code class="hljs JavaScript"><span class="hljs-title function_">push</span>();<span class="hljs-title function_">pop</span>();<span class="hljs-title function_">shift</span>();<span class="hljs-title function_">unshift</span>();<span class="hljs-title function_">splice</span>();<span class="hljs-title function_">sort</span>();<span class="hljs-title function_">reverse</span>();</code></pre><p><strong>或者直接对数组进行重新赋值：</strong></p><pre><code class="hljs JavaScript">实例.数组 = 新的数组;</code></pre><h3 id="6-3-v-for-遍历对象"><a href="#6-3-v-for-遍历对象" class="headerlink" title="6.3 v-for 遍历对象"></a>6.3 v-for 遍历对象</h3><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 1.在遍历对象中，如果只是一个参数，那么获取的是 属性值 （vlaue） --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;value in info&quot;</span>&gt;</span>&#123;&#123;value&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 2.如果有俩个参数， 第一是 属性值（value） 第二个是 属性名（key）  --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(value,key) in info&quot;</span>&gt;</span>&#123;&#123;key&#125;&#125;:&#123;&#123;value&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 3.如果有三个参数， 第一是 属性值（value） 第二个是 属性名（key） 第三个是 索引值（）index --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(value,key,index) in info&quot;</span>&gt;</span>&#123;&#123;index&#125;&#125;--&#123;&#123;key&#125;&#125;:&#123;&#123;value&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">  <span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><span class="language-javascript">    <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,</span><span class="language-javascript">    <span class="hljs-attr">data</span>: &#123;</span><span class="language-javascript">      <span class="hljs-attr">info</span>: &#123;</span><span class="language-javascript">        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;wpf&#x27;</span>,</span><span class="language-javascript">        <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,</span><span class="language-javascript">        <span class="hljs-attr">sex</span>: <span class="hljs-string">&#x27;男&#x27;</span></span><span class="language-javascript">      &#125;</span><span class="language-javascript">    &#125;</span><span class="language-javascript">  &#125;)</span><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><h3 id="6-4-v-for-和-key"><a href="#6-4-v-for-和-key" class="headerlink" title="6.4 v-for 和 key"></a>6.4 v-for 和 key</h3><p>为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 <code>key</code> 属性：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in items&quot;</span> <span class="hljs-attr">v-bind:key</span>=<span class="hljs-string">&quot;item.id&quot;</span>&gt;</span>  <span class="hljs-comment">&lt;!-- 内容 --&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><p>建议尽可能在使用 <code>v-for</code> 时提供 <code>key</code> attribute，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。</p><p>因为它是 Vue 识别节点的一个通用机制，<code>key</code> 并不仅与 <code>v-for</code> 特别关联。后面我们将在指南中看到，它还具有其它用途。</p><blockquote><p>注意：</p><ul><li>不要使用对象或数组之类的非基本类型值作为 <code>v-for</code> 的 <code>key</code>。请用字符串或数值类型的值。</li><li>不要使用遍历索引 index 作为唯一的 key 值，会有问题</li><li>一般使用数据中能表示唯一的那个字段，例如 id</li></ul></blockquote><h2 id="7-表单绑定"><a href="#7-表单绑定" class="headerlink" title="7.表单绑定"></a>7.表单绑定</h2><ul><li>Vue中使用v-model指令来实现表单元素和数据的双向绑定。</li><li>案例的解析：<ul><li>当我们在输入框输入内容时</li><li>因为input中的v-model绑定了message，所以会实时将输入的内容传递给message，message发生改变。</li><li>当message发生改变时，因为上面我们使用Mustache语法，将message的值插入到DOM中，所以DOM会发生响应的改变。<br>所以，通过v-model实现了双向的绑定。</li></ul></li></ul><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 双向绑定 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span>    &#123;&#123;message&#125;&#125;  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">  <span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><span class="language-javascript">    <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,</span><span class="language-javascript">    <span class="hljs-attr">data</span>: &#123;</span><span class="language-javascript">      <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;hello vue&#x27;</span>,</span><span class="language-javascript">    &#125;</span><span class="language-javascript">  &#125;)</span><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><h3 id="7-1-v-model-原理"><a href="#7-1-v-model-原理" class="headerlink" title="7.1 v-model 原理"></a>7.1 v-model 原理</h3><ul><li>v-model 其实是一个语法糖，它的背后本质上是包含俩个操作：<ul><li>v-bind 绑定一个 value 属性</li><li>v-on 指令给当前元素绑定 input 事件</li></ul></li><li>也就是说下面的代码：等同于下面的代码：</li></ul><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span>等同于<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-bind:value</span>=<span class="hljs-string">&quot;message&quot;</span> <span class="hljs-attr">v-on:input</span>=<span class="hljs-string">&quot;message = $event.target.value&quot;</span>&gt;</span></code></pre><h3 id="7-2-v-model-checkbox"><a href="#7-2-v-model-checkbox" class="headerlink" title="7.2 v-model : checkbox"></a>7.2 v-model : checkbox</h3><ul><li>复选框分为俩种情况：单个勾选框和多个勾选框</li><li>单个勾选框：<ul><li>v-model 即为布尔值。</li><li>此时input的value并不影响v-model的值。</li></ul></li><li>多个复选框：<ul><li>当是多个复选框时，因为可以选中多个，所以对应的data中属性是一个数组。</li><li>当选中某一个时，就会将input的value添加到数组中。</li></ul></li></ul><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;agreement&quot;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;agreement&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;isAgree&quot;</span>&gt;</span>同意协议    <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">:disabled</span>=<span class="hljs-string">&quot;!isAgree&quot;</span>&gt;</span>下一步<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>    <span class="hljs-comment">&lt;!-- &lt;input type=&quot;checkbox&quot; v-model=&quot;hobbies&quot; value=&quot;足球&quot;&gt;足球</span><span class="hljs-comment">    &lt;input type=&quot;checkbox&quot; v-model=&quot;hobbies&quot; value=&quot;篮球&quot;&gt;篮球</span><span class="hljs-comment">    &lt;input type=&quot;checkbox&quot; v-model=&quot;hobbies&quot; value=&quot;羽毛球&quot;&gt;羽毛球</span><span class="hljs-comment">    &lt;input type=&quot;checkbox&quot; v-model=&quot;hobbies&quot; value=&quot;排球&quot;&gt;排球 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>你的爱好是：&#123;&#123;hobbies&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in originHobbies&quot;</span> <span class="hljs-attr">:for</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">:id</span>=<span class="hljs-string">&quot;item&quot;</span> <span class="hljs-attr">:value</span>=<span class="hljs-string">&quot;item&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;hobbies&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">  <span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><span class="language-javascript">    <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,</span><span class="language-javascript">    <span class="hljs-attr">data</span>: &#123;</span><span class="language-javascript">      <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;hello vue&#x27;</span>,</span><span class="language-javascript">      <span class="hljs-attr">isAgree</span>: <span class="hljs-literal">false</span>,</span><span class="language-javascript">      <span class="hljs-attr">hobbies</span>: [],</span><span class="language-javascript">      <span class="hljs-attr">originHobbies</span>: [<span class="hljs-string">&#x27;足球&#x27;</span>, <span class="hljs-string">&#x27;篮球&#x27;</span>, <span class="hljs-string">&#x27;羽毛球&#x27;</span>, <span class="hljs-string">&#x27;排球&#x27;</span>]</span><span class="language-javascript">    &#125;</span><span class="language-javascript">  &#125;)</span><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><h3 id="7-3-v-model-：-select"><a href="#7-3-v-model-：-select" class="headerlink" title="7.3 v-model ： select"></a>7.3 v-model ： select</h3><ul><li>和checkbox一样，select也分单选和多选两种情况。</li><li>单选：只能选中一个值。<ul><li>v-model绑定的是一个值。</li><li>当我们选中option中的一个时，会将它对应的value赋值到mySelect中</li></ul></li><li>多选：可以选中多个值。<ul><li>v-model绑定的是一个数组。</li><li>当选中多个值时，就会将选中的option对应的value添加到数组mySelects中</li></ul></li></ul><p><img src="https://i.loli.net/2020/09/25/HrvkQnG3p6jBtzd.png" srcset="/img/loading.gif" alt="image-20200920162613143"></p><h3 id="7-4-v-model-修饰符的使用"><a href="#7-4-v-model-修饰符的使用" class="headerlink" title="7.4 v-model 修饰符的使用"></a>7.4 v-model 修饰符的使用</h3><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>    <span class="hljs-comment">&lt;!-- lazy（懒惰的） 修饰符 ： 默认情况下，v-model默认是在input事件中同步输入框的数据的。</span><span class="hljs-comment">    也就是说， 一旦有数据发生改变对应的data中的数据也会自动发生改变</span><span class="hljs-comment">    lazy修饰符可以让数据在失去焦点或者回车时才会更新 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model.lazy</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 2. number 修饰符  v-model 默认会把数据以string的形式传递， 我们需要传递是数字型，这时就可以用 number修饰符 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;number&quot;</span> <span class="hljs-attr">v-model.number</span>=<span class="hljs-string">&quot;age&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123;age&#125;&#125;--- &#123;&#123;typeof age&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 3. trim (修剪) 修饰符：  如果输入的内容首尾有很多空格， 通常我们希望将其去除， 这是 trim 修饰符可以过滤内容左右俩边的空格 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model.trim</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>你的名字是：&#123;&#123;name&#125;&#125; 注意在这里（浏览器里默认空格去除了，但真实的数据没有，F12进行操作查看）<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">  <span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><span class="language-javascript">    <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,</span><span class="language-javascript">    <span class="hljs-attr">data</span>: &#123;</span><span class="language-javascript">      <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;hello vue&#x27;</span>,</span><span class="language-javascript">      <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,</span><span class="language-javascript">      <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;&#x27;</span></span><span class="language-javascript">    &#125;</span><span class="language-javascript">  &#125;)</span><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>filter()、map()、reduce()函数的使用</title>
    <link href="/2020/09/02/17.filter-%E3%80%81map-%E3%80%81reduce-%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/09/02/17.filter-%E3%80%81map-%E3%80%81reduce-%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="高阶函数-filter-map-reduce-的使用"><a href="#高阶函数-filter-map-reduce-的使用" class="headerlink" title="高阶函数  filter,map,reduce 的使用"></a>高阶函数  filter,map,reduce 的使用</h1><h3 id="使用一个例子类说明-filter、map、reduce的使用及好处"><a href="#使用一个例子类说明-filter、map、reduce的使用及好处" class="headerlink" title="使用一个例子类说明 filter、map、reduce的使用及好处"></a>使用一个例子类说明 filter、map、reduce的使用及好处</h3><h4 id="需求：-1-将数组小于100的挑选出来"><a href="#需求：-1-将数组小于100的挑选出来" class="headerlink" title="需求： 1. 将数组小于100的挑选出来"></a>需求： 1. 将数组小于100的挑选出来</h4><h4 id="需求：-2-将挑选出来的数组的元素乘以-2"><a href="#需求：-2-将挑选出来的数组的元素乘以-2" class="headerlink" title="需求：  2. 将挑选出来的数组的元素乘以 2"></a>需求：  2. 将挑选出来的数组的元素乘以 2</h4><h4 id="需求：-3-把最终的数组中的元素相加"><a href="#需求：-3-把最终的数组中的元素相加" class="headerlink" title="需求： 3. 把最终的数组中的元素相加"></a>需求： 3. 把最终的数组中的元素相加</h4><h4 id="一、-用ES5基本语法来写"><a href="#一、-用ES5基本语法来写" class="headerlink" title="一、 用ES5基本语法来写"></a>一、 用ES5基本语法来写</h4><pre><code class="hljs JavaScript"> <span class="hljs-keyword">const</span> nums = [<span class="hljs-number">10</span>, <span class="hljs-number">15</span>, <span class="hljs-number">124</span>, <span class="hljs-number">118</span>, <span class="hljs-number">23</span>, <span class="hljs-number">121</span>, <span class="hljs-number">98.48</span>]<span class="hljs-comment">// 1.需求 取出所有小于 100 的数字</span><span class="hljs-keyword">let</span> newNums = []<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> n <span class="hljs-keyword">of</span> nums) &#123;  <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">100</span>) &#123;    newNums.<span class="hljs-title function_">push</span>(n)  &#125;&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newNums);<span class="hljs-comment">// 2. 需求  将小于100的数字 都 乘 2</span><span class="hljs-keyword">let</span> new2Nums = []<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> n <span class="hljs-keyword">of</span> newNums) &#123;  new2Nums.<span class="hljs-title function_">push</span>(n * <span class="hljs-number">2</span>)&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(new2Nums);<span class="hljs-comment">// 3. 需求 将 new2Nums 数组中的数字 加起来</span><span class="hljs-keyword">let</span> result = <span class="hljs-number">0</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> n <span class="hljs-keyword">of</span> new2Nums) &#123;  result += n&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">parseInt</span>(result));</code></pre><h4 id="二、使用-filter、map、reduce-来写"><a href="#二、使用-filter、map、reduce-来写" class="headerlink" title="二、使用 filter、map、reduce 来写"></a>二、使用 filter、map、reduce 来写</h4><pre><code class="hljs JavaScript"><span class="hljs-comment">// 1.需求 取出所有小于 100 的数字</span><span class="hljs-comment">// 使用高阶函数 filter / map / reduce</span><span class="hljs-comment">// 1. filter 中的参数是一个回调函数 有一个要求： 返回的必须是一个布尔值</span><span class="hljs-comment">// true: 当返回true时， 函数内部会自动将这次回调的 n 加入到新的数组中</span><span class="hljs-comment">// false： 当返回的是false， 函数内部会过滤掉这次的n</span><span class="hljs-keyword">let</span> newNums = nums.<span class="hljs-title function_">filter</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">n</span>) &#123; <span class="hljs-comment">// n 表示 nums 数组中的元素</span>  <span class="hljs-keyword">return</span> n &lt; <span class="hljs-number">100</span>&#125;)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newNums);<span class="hljs-comment">// 2. 需求  将小于100的数字 都 乘 2</span><span class="hljs-comment">// map函数的使用，  参数一个回调函数，  </span><span class="hljs-comment">// Array.map() 方法返回一个新数组，此方法可以以一个函数为参数，循环数组的每一个元素，函数将数组中的元素接收为单个参数。</span><span class="hljs-keyword">let</span> new2Nums = newNums.<span class="hljs-title function_">map</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">n</span>) &#123;  <span class="hljs-keyword">return</span> n * <span class="hljs-number">2</span>&#125;)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(new2Nums);<span class="hljs-comment">// 3. 需求 将 new2Nums 数组中的数字 加起来</span><span class="hljs-comment">// reduce函数的使用</span><span class="hljs-comment">//  reduce作用对数组中所有的内容进行汇总  第一个参数是 回调函数， 第二个参数是 初始化值</span><span class="hljs-keyword">let</span> result = new2Nums.<span class="hljs-title function_">reduce</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">preValue, n</span>) &#123;  <span class="hljs-keyword">return</span> preValue + n&#125;, <span class="hljs-number">0</span>)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">parseInt</span>(result));</code></pre><h4 id="使用链式编程-写出最简单的一行搞定的代码"><a href="#使用链式编程-写出最简单的一行搞定的代码" class="headerlink" title="使用链式编程 写出最简单的一行搞定的代码"></a>使用链式编程 写出最简单的一行搞定的代码</h4><pre><code class="hljs JavaScript"><span class="hljs-comment">// 使用高阶函数的链式编程来进行写：</span><span class="hljs-keyword">let</span> result = <span class="hljs-built_in">parseInt</span>(nums.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">n</span> =&gt;</span> n &lt; <span class="hljs-number">100</span>).<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">n</span> =&gt;</span> n * <span class="hljs-number">2</span>).<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">preValue, n</span>) =&gt;</span> preValue + n, <span class="hljs-number">0</span>)) <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);</code></pre>]]></content>
    
    
    <categories>
      
      <category>es6</category>
      
    </categories>
    
    
    <tags>
      
      <tag>es6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>babel转换器</title>
    <link href="/2020/08/28/15.babel/"/>
    <url>/2020/08/28/15.babel/</url>
    
    <content type="html"><![CDATA[<h2 id="一、配置文件-babelrc"><a href="#一、配置文件-babelrc" class="headerlink" title="一、配置文件.babelrc"></a>一、配置文件.babelrc</h2><p>Babel的配置文件是.babelrc，存放在项目的根目录下。使用Babel的第一步，就是配置这个文件。</p><p>该文件用来设置转码规则和插件，基本格式如下。</p><pre><code class="hljs JavaScript">&#123;  <span class="hljs-string">&quot;presets&quot;</span>: [],  <span class="hljs-string">&quot;plugins&quot;</span>: []&#125;</code></pre><h5 id="presets字段设定转码规则，官方提供以下的规则集，你可以根据需要安装。"><a href="#presets字段设定转码规则，官方提供以下的规则集，你可以根据需要安装。" class="headerlink" title="presets字段设定转码规则，官方提供以下的规则集，你可以根据需要安装。"></a>presets字段设定转码规则，官方提供以下的规则集，你可以根据需要安装。</h5><pre><code class="hljs bash"><span class="hljs-comment"># ES2015转码规则</span>$ npm install --save-dev babel-preset-es2015<span class="hljs-comment"># react转码规则</span>$ npm install --save-dev babel-preset-react````<span class="hljs-comment">##### 然后，将这些规则加入.babelrc。</span>```JavaScript&#123;    <span class="hljs-string">&quot;presets&quot;</span>: [      <span class="hljs-string">&quot;es2015&quot;</span>,      <span class="hljs-string">&quot;react&quot;</span>,      <span class="hljs-string">&quot;stage-2&quot;</span>    ],    <span class="hljs-string">&quot;plugins&quot;</span>: []  &#125;</code></pre><blockquote><p>注意，以下所有Babel工具和模块的使用，都必须先写好.babelrc。</p></blockquote><h3 id="（前面步骤必不可少）"><a href="#（前面步骤必不可少）" class="headerlink" title="（前面步骤必不可少）"></a>（前面步骤必不可少）</h3><ul><li>babel-cli：命令行转码</li><li>babel-node：babel-cli工具自带一个babel-node命令，提供一个支持ES6的REPL环境</li><li>babel-register：实时转码，所以只适合在开发环境使用</li><li>babel-core：如果某些代码需要调用Babel的API进行转码，就要使用babel-core模块</li></ul><h2 id="二、babel-cli："><a href="#二、babel-cli：" class="headerlink" title="二、babel-cli："></a>二、babel-cli：</h2><p>一种使用方式就是全局安装：<code>npm install -g babel-cli</code>（可以通过 <code>npm root -g</code> 查看全局包安装目录），<br>只要全局安装了 <code>babel-cli</code>，则会在命令行中多出一个命令：<code>babel</code>。</p><p>这里如果使用全局安装的 <code>babel-cli</code> 进行转码是没有问题的，但是问题是如果一旦项目给了别人，<br>别人不知道你使用了这个转码工具，所以解决方式就是将 <code>babel-cli</code> 安装到本地项目中：</p><pre><code class="hljs bash">npm install --save-dev babel-cli</code></pre><p>这种第三方命令行工具如果安装到本地项目，会在 <code>node_modules</code> 中生成一个目录：<code>.bin</code>，<br>然后第三方命令行工具会将对应的可执行文件放到该目录中。</p><p>这样的话，就可以直接在本地项目中使用该第三方命令行工具了。</p><p>对于如何使用，则可以通过配置 <code>package.json</code> 文件中的 <code>scripts</code> 字段来配置使用：</p><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;babel-demo&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>    <span class="hljs-attr">&quot;test&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;babel demo1.js&quot;</span>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;devDependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>    <span class="hljs-attr">&quot;babel-cli&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^6.22.2&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;babel-preset-es2015&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^6.22.0&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;babel-preset-react&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^6.22.0&quot;</span>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span></code></pre><h2 id="三、babel-register（适合开发阶段，实时编码转换）"><a href="#三、babel-register（适合开发阶段，实时编码转换）" class="headerlink" title="三、babel-register（适合开发阶段，实时编码转换）:"></a>三、babel-register（适合开发阶段，实时编码转换）:</h2><p>第一：安装 babel-register</p><pre><code class="hljs bash">npm install --save-dev babel-register</code></pre><p>第二：添加一个傀儡文件(main.js)：</p><pre><code class="hljs js"><span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;babel-register&#x27;</span>)<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;你的核心功能代码入口文件模块&#x27;</span>)</code></pre><p>第三：使用 node 执行 <code>main.js</code>，而不是你的入口文件.</p><h2 id="四、package-json中-scripts-配置说明"><a href="#四、package-json中-scripts-配置说明" class="headerlink" title="四、package.json中 scripts 配置说明"></a>四、package.json中 scripts 配置说明</h2><pre><code class="hljs JavaScript"><span class="hljs-string">&quot;scripts&quot;</span>: &#123;   <span class="hljs-string">&quot;test&quot;</span>: <span class="hljs-string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span>,   <span class="hljs-string">&quot;dev&quot;</span>: <span class="hljs-string">&quot;node main.js&quot;</span>, <span class="hljs-comment">// 开发时运行这个，babel会帮我们把ES6语法转换为可以识别的ES5语法进去启动</span>   <span class="hljs-string">&quot;build&quot;</span>: <span class="hljs-string">&quot;babel src -d dist&quot;</span>, <span class="hljs-comment">//  把开发时使用的ES6语法转换到dist目录下以ES5的语法呈现</span>   <span class="hljs-string">&quot;prestart&quot;</span>: <span class="hljs-string">&quot;npm run build&quot;</span>, <span class="hljs-comment">// 会先执行 build 再执行 start</span>   <span class="hljs-string">&quot;start&quot;</span>: <span class="hljs-string">&quot;node dist/app.js&quot;</span> <span class="hljs-comment">// 启动app.js 相当于 node app.js</span> &#125;,</code></pre><h2 id="五、–save-和-–save-dev"><a href="#五、–save-和-–save-dev" class="headerlink" title="五、–save 和 –save-dev"></a>五、–save 和 –save-dev</h2><p>通过 <code>--save</code> 参数安装的包，是将依赖项保存到 package.json 文件中的 dependencies 选项中。<br>通过 <code>--save-dev</code> 参数安装的包，是将依赖项保存到 package.json 文件中的 devDependencies 选项中。</p><p>无论是 <code>--save</code> 或者 <code>--save-dev</code> 安装的包，通过执行 <code>npm install</code> 都会将对应的依赖包安装进来。</p><p>但是，在开发阶段会有一些仅仅用来辅助开发的一些第三方包或是工具，然后最终上线运行（到了生产环境），<br>这些开发依赖项就不再需要了，就可以通过 <code>npm install --production</code> 命令仅仅安装 <code>dependencies</code> 中的<br>依赖项。</p>]]></content>
    
    
    <categories>
      
      <category>babel</category>
      
    </categories>
    
    
    <tags>
      
      <tag>es6</tag>
      
      <tag>babel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>es6基础语法总结</title>
    <link href="/2020/08/27/16.es6%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"/>
    <url>/2020/08/27/16.es6%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="ECMAScript-6-简介"><a href="#ECMAScript-6-简介" class="headerlink" title="ECMAScript 6 简介"></a>ECMAScript 6 简介</h2><blockquote><p>本笔记相当于阮一峰老师的ES6教程进行了进一步浓缩</p></blockquote><ul><li>ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。</li><li>ECMAScript 是 JavaScript 语言的标注规范。</li><li>JavaScript 是 ECMAScript 规范的具体实现。<ul><li>具体实现取决于各大浏览器厂商的支持进度</li></ul></li><li>ECMAScript 6 也被称作 ECMAScript 2015</li><li>目前，各大浏览器对 ES6 的支持可以查看kangax.github.io/compat-table/es6/。</li><li>对于不支持 ES6 的环境，可以使用一些编译转码工具做转换处理再使用<ul><li>比如 babel</li></ul></li></ul><hr><h2 id="let-和-const-命令"><a href="#let-和-const-命令" class="headerlink" title="let 和 const 命令"></a>let 和 const 命令</h2><h3 id="1-let命令特性"><a href="#1-let命令特性" class="headerlink" title="1. let命令特性"></a>1. let命令特性</h3><h4 id="1-1-let-具有块级作用域"><a href="#1-1-let-具有块级作用域" class="headerlink" title="1.1 let 具有块级作用域"></a>1.1 let 具有块级作用域</h4><pre><code class="hljs JavaScript">&#123;  <span class="hljs-keyword">let</span> a = <span class="hljs-number">10</span>;  <span class="hljs-keyword">var</span> b = <span class="hljs-number">1</span>;&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">// ReferenceError: a is not defined.</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b); <span class="hljs-comment">// 1</span></code></pre><h4 id="1-2-不存在变量提升"><a href="#1-2-不存在变量提升" class="headerlink" title="1.2 不存在变量提升"></a>1.2 不存在变量提升</h4><pre><code class="hljs JavaScript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(bar); <span class="hljs-comment">// 报错ReferenceError</span><span class="hljs-keyword">let</span> bar = <span class="hljs-number">2</span>;</code></pre><h4 id="1-3-暂时性死区"><a href="#1-3-暂时性死区" class="headerlink" title="1.3 暂时性死区"></a>1.3 暂时性死区</h4><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> tmp = <span class="hljs-number">123</span><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<span class="hljs-comment">// 当前所在块级区域的 tmp 会默认为被 let 声明绑定了 </span><span class="hljs-comment">// 所以只能先声明后赋值</span>  tmp = <span class="hljs-string">&#x27;abc&#x27;</span>; <span class="hljs-comment">// ReferenceError</span>  <span class="hljs-keyword">let</span> tmp;&#125;</code></pre><h4 id="1-4-不允许重复声明"><a href="#1-4-不允许重复声明" class="headerlink" title="1.4 不允许重复声明"></a>1.4 不允许重复声明</h4><p><code>let</code>不允许在相同作用域内，重复声明同一个变量。</p><pre><code class="hljs JavaScript"><span class="hljs-comment">// 报错</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">func</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">let</span> a = <span class="hljs-number">10</span>;  <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;&#125;<span class="hljs-comment">// 报错</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">func</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">let</span> a = <span class="hljs-number">10</span>;  <span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span>;&#125;</code></pre><hr><h3 id="2-块级作用域的好处"><a href="#2-块级作用域的好处" class="headerlink" title="2. 块级作用域的好处"></a>2. 块级作用域的好处</h3><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>按钮1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>按钮2<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>按钮3<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>按钮4<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">        <span class="hljs-comment">// 点击按钮依次弹出它的索引号</span></span><span class="language-javascript">        <span class="hljs-keyword">var</span> btns = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&quot;button&quot;</span>);</span><span class="language-javascript">        <span class="hljs-comment">// 1. 使用var变量 但得用闭包</span></span><span class="language-javascript">        <span class="hljs-comment">// for (var i = 0; i &lt; btns.length; i++) &#123;</span></span><span class="language-javascript">        <span class="hljs-comment">//     // 用var  需要用到闭包 才能解决</span></span><span class="language-javascript">        <span class="hljs-comment">//     (function (i) &#123;</span></span><span class="language-javascript">        <span class="hljs-comment">//         btns[i].onclick = function () &#123;</span></span><span class="language-javascript">        <span class="hljs-comment">//             alert(i)</span></span><span class="language-javascript">        <span class="hljs-comment">//         &#125;</span></span><span class="language-javascript">        <span class="hljs-comment">//     &#125;)(i)</span></span><span class="language-javascript">        <span class="hljs-comment">// &#125;;</span></span><span class="language-javascript"></span><span class="language-javascript">        <span class="hljs-comment">//  2. 使用let变量 直接就可以  因为let具有块级作用域</span></span><span class="language-javascript">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; btns.<span class="hljs-property">length</span>; i++) &#123;</span><span class="language-javascript">            btns[i].<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">                <span class="hljs-title function_">alert</span>(i)</span><span class="language-javascript">            &#125;</span><span class="language-javascript"></span><span class="language-javascript">        &#125;;</span><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre><hr><h3 id="3-const-命令特性"><a href="#3-const-命令特性" class="headerlink" title="3. const 命令特性"></a>3. const 命令特性</h3><blockquote><p>和 let 特性一样 唯一的区别在于 const 声明后不能再修改，常量</p></blockquote><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PI</span> = <span class="hljs-number">3.14</span><span class="hljs-variable constant_">PI</span> = <span class="hljs-number">3</span>  <span class="hljs-comment">//  TypeError: Assignment to constant variable.</span></code></pre><pre><code class="hljs JavaScript"><span class="hljs-comment">// const 常量 对于复杂类型， 内部的值可以更改 但是把复杂类型整体修改是不允许的， 也就是复杂类型整体的内存地址不可更改</span>       <span class="hljs-keyword">const</span> ary = [<span class="hljs-number">100</span>, <span class="hljs-number">200</span>];       ary[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 因为更改内部的值 并没有更改它的内存地址 所有可以修改</span>       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ary); <span class="hljs-comment">//  1，200</span>       ary = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]; <span class="hljs-comment">//  这个 把整体都重新赋值了也就是更改了它的内存地址 故报错</span>       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ary); <span class="hljs-comment">// 报错</span></code></pre><hr><h3 id="4-解构赋值"><a href="#4-解构赋值" class="headerlink" title="4. 解构赋值"></a>4. 解构赋值</h3><blockquote><p>注意：解构赋值 必须要同时进行，不能先声明再赋值  如：  let {a,b};  {a,b}={a:12,b:5}  这样是错的</p></blockquote><h4 id="4-1-基本使用"><a href="#4-1-基本使用" class="headerlink" title="4.1 基本使用"></a>4.1 基本使用</h4><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> [a,b,c]  = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>] <span class="hljs-comment">// 相当于以下</span><span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span><span class="hljs-keyword">let</span> b = <span class="hljs-number">2</span><span class="hljs-keyword">let</span> c = <span class="hljs-number">3</span></code></pre><blockquote><p>本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值</p></blockquote><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;aaa&#x27;</span>);&#125;<span class="hljs-keyword">let</span> [x = <span class="hljs-title function_">f</span>()] = [<span class="hljs-number">1</span>];</code></pre><p>上面代码中，因为x能取到值，所以函数f根本不会执行。上面的代码其实等价于下面的代码。</p><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> x;<span class="hljs-keyword">if</span> ([<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] === <span class="hljs-literal">undefined</span>) &#123;  x = <span class="hljs-title function_">f</span>();&#125; <span class="hljs-keyword">else</span> &#123;  x = [<span class="hljs-number">1</span>][<span class="hljs-number">0</span>];&#125;</code></pre><hr><h4 id="4-2-对象的解构赋值"><a href="#4-2-对象的解构赋值" class="headerlink" title="4.2 对象的解构赋值"></a>4.2 对象的解构赋值</h4><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> &#123; bar, foo &#125; = &#123; <span class="hljs-attr">foo</span>: <span class="hljs-string">&#x27;aaa&#x27;</span>, <span class="hljs-attr">bar</span>: <span class="hljs-string">&#x27;bbb&#x27;</span> &#125;;foo <span class="hljs-comment">// &quot;aaa&quot;</span>bar <span class="hljs-comment">// &quot;bbb&quot;</span><span class="hljs-keyword">let</span> &#123; baz &#125; = &#123; <span class="hljs-attr">foo</span>: <span class="hljs-string">&#x27;aaa&#x27;</span>, <span class="hljs-attr">bar</span>: <span class="hljs-string">&#x27;bbb&#x27;</span> &#125;;baz <span class="hljs-comment">// undefined  因为bar变量没有对应的同名属性，导致取不到值，最后等于undefined。</span></code></pre><hr><h4 id="4-3-字符串的解构赋值"><a href="#4-3-字符串的解构赋值" class="headerlink" title="4.3  字符串的解构赋值"></a>4.3  字符串的解构赋值</h4><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> [a, b, c, d, e] = <span class="hljs-string">&#x27;hello&#x27;</span>;a <span class="hljs-comment">// &quot;h&quot;</span>b <span class="hljs-comment">// &quot;e&quot;</span>c <span class="hljs-comment">// &quot;l&quot;</span>d <span class="hljs-comment">// &quot;l&quot;</span>e <span class="hljs-comment">// &quot;o&quot;</span></code></pre><hr><h4 id="4-4-函数参数的解构赋值"><a href="#4-4-函数参数的解构赋值" class="headerlink" title="4.4 函数参数的解构赋值"></a>4.4 函数参数的解构赋值</h4><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">[x, y]</span>)&#123;  <span class="hljs-keyword">return</span> x + y;&#125;<span class="hljs-title function_">add</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]); <span class="hljs-comment">// 3</span></code></pre><h2 id="上面代码中，函数add的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量x和y。对于函数内部的代码来说，它们能感受到的参数就是x和y。"><a href="#上面代码中，函数add的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量x和y。对于函数内部的代码来说，它们能感受到的参数就是x和y。" class="headerlink" title="上面代码中，函数add的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量x和y。对于函数内部的代码来说，它们能感受到的参数就是x和y。"></a>上面代码中，函数add的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量x和y。对于函数内部的代码来说，它们能感受到的参数就是x和y。</h2><h4 id="4-5-用途"><a href="#4-5-用途" class="headerlink" title="4.5 用途"></a>4.5 用途</h4><h5 id="1-交换变量的值"><a href="#1-交换变量的值" class="headerlink" title="(1) 交换变量的值"></a>(1) 交换变量的值</h5><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> x = <span class="hljs-number">1</span>;<span class="hljs-keyword">let</span> y = <span class="hljs-number">2</span>;[x, y] = [y, x];</code></pre><h2 id="上面代码交换变量x和y的值，这样的写法不仅简洁，而且易读，语义非常清晰。"><a href="#上面代码交换变量x和y的值，这样的写法不仅简洁，而且易读，语义非常清晰。" class="headerlink" title="上面代码交换变量x和y的值，这样的写法不仅简洁，而且易读，语义非常清晰。"></a>上面代码交换变量x和y的值，这样的写法不仅简洁，而且易读，语义非常清晰。</h2><h5 id="（2）从函数返回多个值"><a href="#（2）从函数返回多个值" class="headerlink" title="（2）从函数返回多个值"></a>（2）从函数返回多个值</h5><pre><code class="hljs JavaScript"><span class="hljs-comment">// 返回一个数组</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">example</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">return</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];&#125;<span class="hljs-keyword">let</span> [a, b, c] = <span class="hljs-title function_">example</span>();<span class="hljs-comment">// 返回一个对象</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">example</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">return</span> &#123;    <span class="hljs-attr">foo</span>: <span class="hljs-number">1</span>,    <span class="hljs-attr">bar</span>: <span class="hljs-number">2</span>  &#125;;&#125;<span class="hljs-keyword">let</span> &#123; foo, bar &#125; = <span class="hljs-title function_">example</span>();</code></pre><hr><h5 id="（3）提取-JSON-数据"><a href="#（3）提取-JSON-数据" class="headerlink" title="（3）提取 JSON 数据"></a>（3）提取 JSON 数据</h5><blockquote><p>解构赋值对提取 JSON 对象中的数据，尤其有用。</p></blockquote><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> jsonData = &#123;  <span class="hljs-attr">id</span>: <span class="hljs-number">42</span>,  <span class="hljs-attr">status</span>: <span class="hljs-string">&quot;OK&quot;</span>,  <span class="hljs-attr">data</span>: [<span class="hljs-number">867</span>, <span class="hljs-number">5309</span>]&#125;;<span class="hljs-keyword">let</span> &#123; id, status, <span class="hljs-attr">data</span>: number &#125; = jsonData;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(id, status, number);<span class="hljs-comment">// 42, &quot;OK&quot;, [867, 5309]</span></code></pre><hr><h3 id="5-字符串的扩展"><a href="#5-字符串的扩展" class="headerlink" title="5.字符串的扩展"></a>5.字符串的扩展</h3><h4 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h4><pre><code class="hljs JavaScript"><span class="hljs-comment">//  字符串模板 的 优点   1.  可以直接塞东西进去   $(东西)   2. 可以换行  注意用 反单引号 ``</span><span class="hljs-keyword">let</span> uname = <span class="hljs-string">&#x27;王鹏飞&#x27;</span>;<span class="hljs-comment">// 拼接字符串 </span><span class="hljs-comment">// let str = &#x27;hello,我的名字是&#x27; + uname + &#x27;&#x27;;</span><span class="hljs-comment">// let str = &#x27;hello,我的名字是&#x27; + uname;</span><span class="hljs-keyword">let</span> str = <span class="hljs-string">`hello,我的名字是<span class="hljs-subst">$&#123;uname&#125;</span>`</span>;<span class="hljs-comment">//hello,我的名字是王鹏飞</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(uname);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str);<span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">55</span>, <span class="hljs-number">88</span>, <span class="hljs-number">4156</span>, <span class="hljs-number">12</span>];arr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`第<span class="hljs-subst">$&#123;index&#125;</span>个:<span class="hljs-subst">$&#123;item&#125;</span>`</span>));</code></pre><hr><h4 id="startsWith-和-endsWidth"><a href="#startsWith-和-endsWidth" class="headerlink" title="startsWith 和 endsWidth"></a>startsWith 和 endsWidth</h4><ul><li>startsWith() : 表示参数字符串是否在原子符串的头部，返回布尔值</li><li>endsWidth() ：表示参数字符串是否在原字符串的尾部，返回布尔值</li><li></li></ul><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;hello world&#x27;</span>str.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&#x27;hello&#x27;</span>)  <span class="hljs-comment">// true</span>str.<span class="hljs-title function_">endsWidth</span>(<span class="hljs-string">&#x27;!&#x27;</span>)  <span class="hljs-comment">// true</span></code></pre><pre><code class="hljs JavaScript"> <span class="hljs-comment">// startsWith</span><span class="hljs-keyword">let</span> start = <span class="hljs-string">&#x27;https://www.baidu.com/&#x27;</span>;<span class="hljs-keyword">if</span> (start.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&#x27;http:&#x27;</span>)) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;普通网址&#x27;</span>);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (start.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&#x27;https:&#x27;</span>)) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;加密网址&#x27;</span>);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (start.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&#x27;svg:&#x27;</span>)) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;库&#x27;</span>);&#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;其他网址&#x27;</span>)&#125;;<span class="hljs-comment">// endsWidth</span><span class="hljs-keyword">let</span> end = <span class="hljs-string">&#x27;1.jpg&#x27;</span>;<span class="hljs-keyword">if</span> (end.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">&#x27;.jpg&#x27;</span>)) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;jpg图片&#x27;</span>);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (end.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">&#x27;.png&#x27;</span>)) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;png图片&#x27;</span>);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (end.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">&#x27;.webp&#x27;</span>)) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;webp图片&#x27;</span>);&#125;<span class="hljs-comment">// repeat</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;wpf&#x27;</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">3</span>)); <span class="hljs-comment">// 把wpf 重复三次  wpfwpfwpf色图st</span></code></pre><hr><h3 id="6-数组的扩展"><a href="#6-数组的扩展" class="headerlink" title="6.数组的扩展"></a>6.数组的扩展</h3><h4 id="6-1-Array-from"><a href="#6-1-Array-from" class="headerlink" title="6.1 Array.from()"></a>6.1 Array.from()</h4><blockquote><p>Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）。</p></blockquote><p>下面是一个类似数组的对象，Array.from将它转为真正的数组。</p><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> arrayLike = &#123;    <span class="hljs-string">&#x27;0&#x27;</span>: <span class="hljs-string">&#x27;a&#x27;</span>,    <span class="hljs-string">&#x27;1&#x27;</span>: <span class="hljs-string">&#x27;b&#x27;</span>,    <span class="hljs-string">&#x27;2&#x27;</span>: <span class="hljs-string">&#x27;c&#x27;</span>,    <span class="hljs-attr">length</span>: <span class="hljs-number">3</span>&#125;;<span class="hljs-comment">// ES5的写法</span><span class="hljs-keyword">var</span> arr1 = [].<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(arrayLike); <span class="hljs-comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span><span class="hljs-comment">// ES6的写法</span><span class="hljs-keyword">let</span> arr2 = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(arrayLike); <span class="hljs-comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></code></pre><p>实际应用中，常见的类似数组的对象是 DOM 操作返回的 NodeList 集合，以及函数内部的arguments对象。Array.from都可以将它们转为真正的数组。</p><pre><code class="hljs JavaScript"><span class="hljs-comment">// NodeList对象</span><span class="hljs-keyword">let</span> ps = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;p&#x27;</span>);<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(ps).<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">p</span> =&gt;</span> &#123;  <span class="hljs-keyword">return</span> p.<span class="hljs-property">textContent</span>.<span class="hljs-property">length</span> &gt; <span class="hljs-number">100</span>;&#125;);<span class="hljs-comment">// arguments对象</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">var</span> args = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-variable language_">arguments</span>);  <span class="hljs-comment">// ...</span>&#125;</code></pre><p>上面代码中，querySelectorAll方法返回的是一个类似数组的对象，可以将这个对象转为真正的数组，再使用filter方法。</p><h4 id="6-2-Array-of"><a href="#6-2-Array-of" class="headerlink" title="6.2 Array.of()"></a>6.2 Array.of()</h4><blockquote><p>Array.of方法用于将一组值，转换为数组。</p></blockquote><pre><code class="hljs JavaScript"><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">of</span>(<span class="hljs-number">3</span>, <span class="hljs-number">11</span>, <span class="hljs-number">8</span>) <span class="hljs-comment">// [3,11,8]</span><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">of</span>(<span class="hljs-number">3</span>) <span class="hljs-comment">// [3]</span><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">of</span>(<span class="hljs-number">3</span>).<span class="hljs-property">length</span> <span class="hljs-comment">// 1</span></code></pre><p>这个方法的主要目的，是弥补数组构造函数Array()的不足。因为参数个数的不同，会导致Array()的行为有差异.</p><pre><code class="hljs JavaScript"><span class="hljs-title class_">Array</span>() <span class="hljs-comment">// []</span><span class="hljs-title class_">Array</span>(<span class="hljs-number">3</span>) <span class="hljs-comment">// [, , ,]</span><span class="hljs-title class_">Array</span>(<span class="hljs-number">3</span>, <span class="hljs-number">11</span>, <span class="hljs-number">8</span>) <span class="hljs-comment">// [3, 11, 8]</span></code></pre><h4 id="6-3-数组实例的-find-和-findIndex"><a href="#6-3-数组实例的-find-和-findIndex" class="headerlink" title="6.3 数组实例的 find() 和 findIndex()"></a>6.3 数组实例的 find() 和 findIndex()</h4><h5 id="find"><a href="#find" class="headerlink" title="find()"></a>find()</h5><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> arr = [&#123;        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;wpf&#x27;</span>,        <span class="hljs-attr">age</span>: <span class="hljs-number">23</span>    &#125;,    &#123;        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;zyz&#x27;</span>,        <span class="hljs-attr">age</span>: <span class="hljs-number">24</span>    &#125;, &#123;        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;zd&#x27;</span>,        <span class="hljs-attr">age</span>: <span class="hljs-number">25</span>    &#125;]<span class="hljs-keyword">let</span> newArr = arr.<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">name</span> === <span class="hljs-string">&#x27;wpf&#x27;</span>)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newArr); <span class="hljs-comment">// &#123; name: &#x27;wpf&#x27;, age: 23 &#125;</span></code></pre><h5 id="findIndex"><a href="#findIndex" class="headerlink" title="findIndex()"></a>findIndex()</h5><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> arr = [&#123;        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;wpf&#x27;</span>,        <span class="hljs-attr">age</span>: <span class="hljs-number">23</span>    &#125;,    &#123;        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;zyz&#x27;</span>,        <span class="hljs-attr">age</span>: <span class="hljs-number">24</span>    &#125;, &#123;        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;zd&#x27;</span>,        <span class="hljs-attr">age</span>: <span class="hljs-number">25</span>    &#125;]<span class="hljs-keyword">let</span> newArr = arr.<span class="hljs-title function_">findIndex</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">name</span> === <span class="hljs-string">&#x27;zyz&#x27;</span>)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newArr); <span class="hljs-comment">// 1</span></code></pre><h4 id="数组实例的-includes"><a href="#数组实例的-includes" class="headerlink" title="数组实例的 includes()"></a>数组实例的 includes()</h4><blockquote><p>数组中是否包含某个元素</p></blockquote><pre><code class="hljs JavaScript">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">includes</span>(<span class="hljs-number">2</span>)     <span class="hljs-comment">// true</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">includes</span>(<span class="hljs-number">4</span>)     <span class="hljs-comment">// false</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-title class_">NaN</span>].<span class="hljs-title function_">includes</span>(<span class="hljs-title class_">NaN</span>) <span class="hljs-comment">// true</span></code></pre><h4 id="rest参数"><a href="#rest参数" class="headerlink" title="rest参数"></a>rest参数</h4><blockquote><p>rest 参数（形式为…变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。</p></blockquote><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">a, ...args</span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(...args); <span class="hljs-comment">//  2  3</span>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(args); <span class="hljs-comment">//  [2,3]</span>&#125;<span class="hljs-title function_">fn</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)</code></pre><h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><blockquote><p>箭头函数就是用来简化函数定义语法的<br>适用场景: 在方法中使用。 比如： find(),map(),等</p></blockquote><pre><code class="hljs JavaScript">funciton sum (num1,num2)&#123;    <span class="hljs-keyword">return</span> num1 + num2&#125; <span class="hljs-comment">// 相当于以下代码</span><span class="hljs-keyword">const</span> <span class="hljs-title function_">sum</span> = (<span class="hljs-params">num1,num2</span>) =&gt; num1 + num2</code></pre><ul><li>箭头函数特点<ul><li>如果形参只有一个的话，可以省略小括号（）</li><li>如果函数体中的代码只有一个return，可以省略小括号（）</li><li>this指向的是原先定义好的位置，而不是随着当前箭头函数的位置而改变</li></ul></li><li>由于箭头函数this 的指向问题 所以：<ul><li>不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。</li><li>不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</li></ul></li></ul><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = <span class="hljs-number">0</span>;      <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-comment">// 回调里面的 `this` 变量就指向了期望的那个对象了</span>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>++;    &#125;, <span class="hljs-number">3000</span>);&#125;<span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();</code></pre><hr>]]></content>
    
    
    <categories>
      
      <category>es6</category>
      
    </categories>
    
    
    <tags>
      
      <tag>es6</tag>
      
      <tag>babel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>github</title>
    <link href="/2020/08/23/14.Github/"/>
    <url>/2020/08/23/14.Github/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Github 就是程序员的新浪微博<br>它可以让你使用社交化的方式进行编程协作、<br>    - 点赞<br>    - 评论<br>    - 转发<br>    - etc.<br>主要作用：可以免费在线托管你的仓库<br>可以实现多人协作<br>提供了一个可视化界面（Web Page）让你能直观清晰的了解你的项目源代码</p></blockquote><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><ul><li>注册</li><li>登陆</li><li>创建远程仓库</li><li>通过 <code>git clone</code> 命令下载远程仓库到本地<ul><li>git clone 会自动帮你把远程仓库下载到本地，不需要再去 git init 了</li><li>通过 clone 下来的仓库，git 有一个远程仓库地址列表，git 默认会把你 clone 的地址起一个别名：origin</li><li>然后你执行 push 的时候实际上就是将本地的版本提交到 origin 上</li></ul></li><li>在本地进行操作，通过 <code>git commit</code> 形成历史记录</li><li>通过 <code>git push</code> 将本地仓库中的历史记录提交到远程仓库</li></ul><h3 id="本地已有仓库，需要提交到线上"><a href="#本地已有仓库，需要提交到线上" class="headerlink" title="本地已有仓库，需要提交到线上"></a>本地已有仓库，需要提交到线上</h3><p>如果是 <code>git init</code> 出来的仓库，进行 <code>push</code> 提交的时候就不知道要往哪里 push。</p><p>所以，这里通过 <code>remote</code> 相关命令进行设置：</p><pre><code class="hljs bash"><span class="hljs-comment"># 查看所有的远程仓库信息</span>git remote show<span class="hljs-comment"># 根据别名查看指定的远程仓库信息</span>git remote show 远程仓库地址别名<span class="hljs-comment"># 添加远程仓库信息</span>git remote add 别名 远程仓库地址</code></pre><p>通过上面的 <code>git remote add</code> 添加完远程仓库地址信息之后，还不能直接 <code>git push</code>，必须在每一次<br><code>push</code> 的时候加上 <code>git push 仓库地址别名 master</code> 就可以提交了。</p><p>如果想要省略 <code>git push</code> 后面需要指定的 <code>仓库地址别名 master</code> 可以通过下面的命令修改：</p><pre><code class="hljs avrasm">git <span class="hljs-keyword">push</span> --<span class="hljs-keyword">set</span>-upstream heima master</code></pre><p>这样就可以直接使用 <code>git pish</code> 进行提交而不需要指定 <code>heima master</code> 了</p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ol><li>能概述什么是版本控制并举例</li><li>能概述 SVN 的协作交互流程（远程仓库、用户、本地仓库）</li><li>能掌握 SVN 基本的交互使用（checkout、update、commit）</li><li>能概述 Git 的协作交互流程（远程仓库、用户、本地仓库）</li><li>能掌握 Git 的基本使用（init、status、add、commit、log、clone、push、remote）</li></ol>]]></content>
    
    
    <categories>
      
      <category>github</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
      <tag>github</tag>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git</title>
    <link href="/2020/08/23/13.git/"/>
    <url>/2020/08/23/13.git/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://zh.wikipedia.org/wiki/Git">维基百科 - Git</a></p></blockquote><h2 id="学习资源介绍"><a href="#学习资源介绍" class="headerlink" title="学习资源介绍"></a>学习资源介绍</h2><ul><li><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/">Git教程 - 廖雪峰</a></li><li><a href="http://git.oschina.net/progit/">Pro Git</a></li><li><a href="http://rogerdudler.github.io/git-guide/index.zh.html">git - 简明指南</a></li><li><a href="http://backlogtool.com/git-guide/cn/">猴子都能懂的GIT入门</a></li></ul><h2 id="Git-简介"><a href="#Git-简介" class="headerlink" title="Git 简介"></a>Git 简介</h2><ul><li>是什么<ul><li>Git 也是一个版本控制管理软件</li></ul></li><li>有什么用，可以解决什么问题<ul><li>保存历史记录</li><li>多人协作</li></ul></li><li>有了 SVN，为啥要学 Git<ul><li>Git 火</li><li>Git 相对于 SVN 来说，更强大，用户也非常多</li></ul></li><li>怎么用</li><li>Git 的诞生<ul><li><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137402760310626208b4f695940a49e5348b689d095fc000">http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137402760310626208b4f695940a49e5348b689d095fc000</a></li></ul></li></ul><h2 id="Git-使用交互流程"><a href="#Git-使用交互流程" class="headerlink" title="Git 使用交互流程"></a>Git 使用交互流程</h2><p><img src="img/git%E4%BA%A4%E4%BA%92%E6%A8%A1%E5%9E%8B.png" srcset="/img/loading.gif" alt="git交互模型"></p><h2 id="安装和配置-Git-环境"><a href="#安装和配置-Git-环境" class="headerlink" title="安装和配置 Git 环境"></a>安装和配置 Git 环境</h2><ul><li>下载地址：<a href="https://git-scm.com/">https://git-scm.com/</a></li></ul><h3 id="git-bash-常用命令"><a href="#git-bash-常用命令" class="headerlink" title="git-bash 常用命令"></a>git-bash 常用命令</h3><ul><li><p>pwd</p></li><li><p>ls   查看文件目录</p><ul><li>ls -a  查看隐藏文件</li></ul></li><li><p>cd</p></li><li><p>mkdir    创建文件</p></li><li><p>clear    清屏</p></li><li><p>rmdir</p><ul><li>只能删除空目录</li></ul></li><li><p>rm</p><ul><li><p>rm 文件名</p></li><li><p>rm -rf 目录名</p><ul><li>注：很强大，可以删除非空目录，以及一些比较顽固的文件或者目录 </li></ul><h3 id="git-bash-文件操作常用目录"><a href="#git-bash-文件操作常用目录" class="headerlink" title="git-bash 文件操作常用目录"></a>git-bash 文件操作常用目录</h3></li></ul></li><li><p>touch：创建文件</p></li><li><p>cat 查看文件内容</p></li><li><p>less：查看大文本文件内容 （从头开始往下看）</p></li><li><p>vi 编辑 ： （visual interface）</p><ul><li>Esc  退出命令模式</li><li>i  进入插入模式</li><li>:q   退出vi</li><li>:w  保存编辑</li><li>:wq  保存并退出</li><li>:q! 强制退出不保存修改</li><li>vi 的所有操作基本都是命令，这里掌握基本使用就可以了</li><li>有时候使用 git commit 进行提交的时候希望能多写几行提交日志，这时候可以省略 -m 参数进入 vi</li></ul></li></ul><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><ul><li><code>git init</code><ul><li>初始化一个 Git 仓库</li></ul></li><li><code>git status</code><ul><li>查看当前工作区、暂存区、本地仓库的状态</li></ul></li><li><code>git add</code>   提交到暂存区</li><li><code>git commit</code> 将文件存入文档库<ul><li>示例：<code>git commit -m &quot;日志说明&quot; --author=&quot;操作者姓名 &lt;邮箱&gt;&quot;</code></li><li>执行 <code>git commit</code> 的时候，Git 会要求具有用户名和邮箱的参数选项</li><li>可以通过 <code>git config</code> 命令配置一下用户名和邮箱</li></ul></li><li><code>git log</code>  查看提交日志</li><li><code>gitk</code>     图形化的呈现出提交日志</li></ul><p><strong>总结</strong>：操作 Git 的基本工作流程就是先修改文件，然后执行 <code>git add</code> 命令。<br><code>git add</code> 命令会把文件加入到暂存区，接着就可以执行 <code>git commit</code> 命令，将文件存入文档库，<br>从而形成一次历史记录。</p><ul><li>问题1：关于 Git-bash 中文问题</li><li><a href="https://github.com/msysgit/msysgit/wiki/Git-for-Windows-Unicode-Support">Git for Windows Unicode Support</a></li><li>问题2：执行 commit 的时候一大堆的信息</li><li>问题3：配置 user.name 和 user.email 问题</li></ul><h3 id="初始化配置"><a href="#初始化配置" class="headerlink" title="初始化配置"></a>初始化配置</h3><pre><code class="hljs bash"><span class="hljs-comment"># 设置用户名</span>git config --global user.name <span class="hljs-string">&quot;你的名字&quot;</span><span class="hljs-comment"># 配置用户邮箱</span>git config --global user.email <span class="hljs-string">&quot;你的常用邮箱&quot;</span><span class="hljs-comment"># 设置 gitk 图形查看工具中文显示默认编码（防止乱码）</span>git config --global gui.encoding utf-8<span class="hljs-comment"># 查看配置列表项</span>git config --list</code></pre><h3 id="添加-删除文件"><a href="#添加-删除文件" class="headerlink" title="添加/删除文件"></a>添加/删除文件</h3><pre><code class="hljs bash"><span class="hljs-comment"># 添加指定文件到暂存区</span>git add [files1] [files2] ...<span class="hljs-comment"># 添加指定目录到暂存区，包括子目录</span>git add [<span class="hljs-built_in">dir</span>]<span class="hljs-comment"># 添加当前目录所有文件到暂存区</span>git add --allgie add .<span class="hljs-comment"># 停止追踪指定文件，但该文件会保留在工作区 （也就是 把暂存区的文件给退回到工作区）</span>git <span class="hljs-built_in">rm</span>  --cached [file]<span class="hljs-comment"># 改名文件，并且将这个改名的放入暂存区</span>git <span class="hljs-built_in">mv</span> [file-original] [file-renamed]</code></pre><h3 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h3><pre><code class="hljs bash"><span class="hljs-comment"># 提交到暂存区到仓库区</span>git commit -m [message]<span class="hljs-comment"># 提交暂存区的指定文件到仓库区</span>git commit [file1] [file2] ... -m [message]<span class="hljs-comment"># 提交工作区自上次commit之后的变化， 直接到仓库去</span><span class="hljs-comment"># (也就是说。 被跟踪过的 即之前在暂存区过的文件 可以直接越过暂存区提交到仓库区)</span>git commit -a  -m [message]<span class="hljs-comment"># 使用一次新的commit， 替代上一次提交</span><span class="hljs-comment"># 如果代码没有任何新变化，则用改写上一次commit的提交信息</span>git commit --amend -m [message]</code></pre><h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><pre><code class="hljs bash"><span class="hljs-comment"># git rm --cached &lt;file&gt;</span><span class="hljs-comment"># 恢复暂存区的指定文件到工作区</span>$ git checkout [file]<span class="hljs-comment"># 恢复某个commit的指定文件到暂存区和工作区</span>$ git checkout [commit] [file]<span class="hljs-comment"># 恢复暂存区的所有文件到工作区</span>$ git checkout .<span class="hljs-comment"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span>$ git reset [file]<span class="hljs-comment"># 重置暂存区与工作区，与上一次commit保持一致</span>$ git reset --hard<span class="hljs-comment"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span>$ git reset [commit]<span class="hljs-comment"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span>$ git reset --hard [commit]<span class="hljs-comment"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span>$ git reset --keep [commit]<span class="hljs-comment"># 新建一个commit，用来撤销指定commit</span><span class="hljs-comment"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span>$ git revert [commit]<span class="hljs-comment"># 暂时将未提交的变化移除，稍后再移入</span>$ git stash$ git stash pop</code></pre><h3 id="分支基本操作"><a href="#分支基本操作" class="headerlink" title="分支基本操作"></a>分支基本操作</h3><pre><code class="hljs bash"><span class="hljs-comment"># 列出所有分支</span>git branch<span class="hljs-comment"># 基于当前分支新建一个分支，但依然停留在当前分支</span>git branch [branch-name]<span class="hljs-comment"># 基于当前分支新建一个分支 并切换到该分支</span>git checkout -b [branch-name]<span class="hljs-comment"># 切换到指定分支，并更新工作区</span>git checkout [branch-name]<span class="hljs-comment"># 切换到上一个分支， 交替和上一个分支进行切换</span>git checkout - <span class="hljs-comment"># 合并指定分支到当前分支</span>git merge [branch-name]<span class="hljs-comment"># 删除分支</span>git branch -d [branch-name]</code></pre><h3 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h3><ul><li>remote</li><li>push</li><li>pull</li></ul><h3 id="在线仓库托管服务"><a href="#在线仓库托管服务" class="headerlink" title="在线仓库托管服务"></a>在线仓库托管服务</h3><blockquote><p>一个不知道 github、stackoverflow 的程序员想想都是可悲的</p></blockquote><ul><li>github</li><li>码云</li><li>coding</li></ul><hr><h3 id="Github-Pages"><a href="#Github-Pages" class="headerlink" title="Github Pages"></a>Github Pages</h3><blockquote><p>Github Pages 提供了一个免费在线托管静态资源的服务</p></blockquote><h4 id="使用方法如下："><a href="#使用方法如下：" class="headerlink" title="使用方法如下："></a>使用方法如下：</h4><ul><li>在个人的Github账户中创建一个仓库</li><li>仓库名称必须为 <code>个人账户名称.github.io</code></li><li>往该仓库根目录提交一个 <code>index.html</code>文件</li><li>然后就可以在地址栏输入 <code>个人账户名称.github.io</code> 地址，就可以看到 <code>index.html</code> 网页内容了</li></ul><p>注意：上面的创建仓库名称必须是<code>个人账户名称.github.io</code>，否则无法访问。</p><h3 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h3><blockquote><p>Hexo  是基于Node.js开放的一个静态博客生成器，提供了本地实时预览及部署功能，基本使用方法如下：</p></blockquote><pre><code class="hljs shell">npm install  hexo-cli -ghexo init blog(这个是文件名字)cd blog<span class="hljs-meta prompt_"># </span><span class="language-bash">启动本地预览服务，默认是 127.0.0.1：4000</span>hexo server<span class="hljs-meta prompt_"></span><span class="hljs-meta prompt_"># </span><span class="language-bash">新建文章</span>hexo new 文章标题</code></pre><p>也可以参考Hexo官方文档 <a href="https://hexo.io/zh-cn/%EF%BC%8C%E9%87%8C%E9%9D%A2%E6%9C%89%E5%85%B7%E4%BD%93%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F">https://hexo.io/zh-cn/，里面有具体使用方式</a></p><h3 id="自动发布-Hexo-搭建的静态博客"><a href="#自动发布-Hexo-搭建的静态博客" class="headerlink" title="自动发布 Hexo 搭建的静态博客"></a>自动发布 Hexo 搭建的静态博客</h3><ul><li><p>第一：先修改 <code>_config.yml</code>配置文件，下面是一个示例：</p><pre><code class="hljs awk">deploy:  type: git  reop: https:<span class="hljs-regexp">//</span>wangpf1129:mima@github.com<span class="hljs-regexp">/wangpf1129/</span>wangpf1129.github.io.git</code></pre><p>上面配置选项中，一定要注意repo中获取对应的格式加入Github用户名和密码。</p></li><li><p>第二：安装自动发布的插件:</p></li></ul><pre><code class="hljs shell">npm install hexo-deployer-git --save</code></pre><ul><li>第三： 使用命令一键进行发布：</li></ul><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">俩条命令都可以，发布可能有延迟，稍微等待即可</span> hexo generate --deploy hexo deploy --generate</code></pre><h1 id="注意-如果访问不了-https-xxx-github-io"><a href="#注意-如果访问不了-https-xxx-github-io" class="headerlink" title="注意 如果访问不了 https://xxx.github.io"></a>注意 如果访问不了 <a href="https://xxx.github.io/">https://xxx.github.io</a></h1><p>需要把本机电脑的 ipv4 协议中的 DNS 服务地址 修改为 114.114.114.114</p>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
      <category>github</category>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
      <tag>github</tag>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SVN</title>
    <link href="/2020/08/22/12-SVN/"/>
    <url>/2020/08/22/12-SVN/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是版本控制？"><a href="#什么是版本控制？" class="headerlink" title="什么是版本控制？"></a>什么是版本控制？</h3><p>版本管理就是管理更新的历史记录，<br>它给我们提供了一些在软件开发过程中必不可少的功能，例如：</p><ul><li>记录一款软件添加或更改源代码的过程</li><li>回滚到特定阶段，恢复误删除的文件</li><li>合并多人协作的文件等</li><li>多人协同，文件传输</li></ul><h3 id="版本控制分类"><a href="#版本控制分类" class="headerlink" title="版本控制分类"></a>版本控制分类</h3><ul><li>集中式<ul><li>SVN</li></ul></li><li>分布式<ul><li>Git</li></ul></li></ul><hr><h2 id="SVN"><a href="#SVN" class="headerlink" title="SVN"></a>SVN</h2><p>SVN 全称 Apache Subversion，是一个开放源代码的集中式版本管理系统。<br>在 2000 年由 CollabNet 开发，现已发展成为 Apache 软件基金会的一个开源项目。</p><h3 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h3><h3 id="SVN-交互协作流程"><a href="#SVN-交互协作流程" class="headerlink" title="SVN 交互协作流程"></a>SVN 交互协作流程</h3><p><img src="./img/svn%E4%BA%A4%E4%BA%92%E6%B5%81%E7%A8%8B.png" srcset="/img/loading.gif" alt="集中式版本管理 - SVN"></p><h3 id="集中式"><a href="#集中式" class="headerlink" title="集中式"></a>集中式</h3><p>早期的版本管理就是以 <code>Apache Subversion</code> 为代表的集中式版本管理，<br>集中式版本管理将所有的数据集中存放在服务器中，这是有便于统一管理的优点。<br>但是一旦开发者所处的环境不能连接服务器，就无法获取最新源代码，开发也就无法进行。<br>服务器宕机时也是同样的道理，而且万一服务器故障导致数据丢失，<br>恐怕开发者就再也见不到最新的源代码了。</p><p>简而言之：</p><ul><li>中央服务器好比是一个图书馆</li><li>你要改一本书，必须先从图书馆借出来（checkout）</li><li>然后回到家自己改，改完了，再放到图书馆（commit）</li></ul><h3 id="一些术语"><a href="#一些术语" class="headerlink" title="一些术语"></a>一些术语</h3><ul><li>源代码库（repository）：源代码统一存放的地方</li><li>检出（checkout）：当你手上没有源代码的时候，就需要从 responsive checkout 一份</li><li>提交（commit）：当你已经修改了代码，就需要 commit 到 repository</li><li>更新（update）：当你已经 checkout 了一份源代码，Update 一下就可以和 repository 上的源代码同步，你手上的代码就会有最新的变更</li></ul><h3 id="使用-VisualSVN-搭建-SVN-服务器"><a href="#使用-VisualSVN-搭建-SVN-服务器" class="headerlink" title="使用 VisualSVN 搭建 SVN 服务器"></a>使用 VisualSVN 搭建 SVN 服务器</h3><p>SVN 服务器：运行 Subversion 服务的计算机。</p><p>为了方便，我们这里使用比较流行的图形化工具 <a href="https://www.visualsvn.com/">VisualSVN</a><br>来搭建我们的 SVN 服务。</p><p>安装完毕之后，基本使用流程如下：</p><ul><li>创建用户</li><li>创建版本仓库</li><li>设定用户权限</li></ul><h3 id="使用-TortoiseSVN-作为-SVN-客户端"><a href="#使用-TortoiseSVN-作为-SVN-客户端" class="headerlink" title="使用 TortoiseSVN 作为 SVN 客户端"></a>使用 TortoiseSVN 作为 SVN 客户端</h3><p>SVN 客户端：用户通过SVN客户端同SVN服务器交互</p><p>这里我们使用最流行的 <a href="https://tortoisesvn.net/">TortoiseSVN</a></p><p><a href="https://desktop-40umeji:8443/svn/jd">https://DESKTOP-40UMEJI:8443/svn/jd</a></p><p><a href="https://192.168.133.25:8443/svn/jd">https://192.168.133.25:8443/svn/jd</a></p><h3 id="TortoiseSVN-客户端基本操作流程"><a href="#TortoiseSVN-客户端基本操作流程" class="headerlink" title="TortoiseSVN 客户端基本操作流程"></a>TortoiseSVN 客户端基本操作流程</h3><ul><li>检出项目：<code>checkout</code><ul><li>在没有源代码的前提下，需要通过 tortoise-svn 客户端下载</li></ul></li><li>提交修改：<code>commit</code><ul><li>帮你记录当前开发的软件的状态</li></ul></li><li>更新文件或目录：<code>update</code>（更新）<ul><li>别的开发人员在已有源代码的前提下可以通过 update 更新服务器上最新的版本</li></ul></li><li>查看版本日志：<code>log</code>（日志）</li></ul><h3 id="关于冲突"><a href="#关于冲突" class="headerlink" title="关于冲突"></a>关于冲突</h3><p>假设 A、B 两个用户都在版本号为 100 的时候，更新了 kingtuns.txt 这个文件，<br>A 用户在修改完成之后提交 kingtuns.txt 到服务器， 这个时候提交成功，<br>这个时候 kingtuns.txt 文件的版本号已经变成 101 了。<br>同时B用户在版本号为 100 的 kingtuns.txt 文件上作修改， 修改完成之后提交到服务器时，<br>由于不是在当前最新的 101 版本上作的修改，所以导致提交失败。</p><p>良好的使用习惯就是，提交之前，先更新。</p><p>为了避免冲突，别人的文件你最好不要动，<br>万一你要修改公共的文件或者是别人的文件，<br>跟别人最好口头沟通好，就是你改动的时候，<br>别人最好不要去改动，这样才能最大程度上避免冲突的问题。</p><p>多人协作时，同个目录或同个文件需要不同成员共同开发，<br>这个时候 commit 和 update 就可能出现冲突。</p><ul><li>两个程序员只要不是修改了同一行程序，SVN 可以通过 update 自动合并修改</li><li>但是如果两个程序员修改了同一行程序， SVN 会提示文件 conflict，需要手动确定</li></ul><p>如何解决？</p><p>第一种解决方法：手动合并冲突的内容</p><p>第二种解决方法：每次修改某个文件的时候对文件上锁，这样你在修改的过程中别人就无法更新这个文件</p><p>建议：</p><ul><li>一个文件最好同一时间只被一个人修改提交</li><li>多跟团队成员沟通</li><li>不要随便去修改别人的文件</li></ul><h3 id="版本管理使用建议"><a href="#版本管理使用建议" class="headerlink" title="版本管理使用建议"></a>版本管理使用建议</h3><ul><li>不要频繁的提交版本<ul><li>一般有比较成熟的功能模块的时候，再去提交</li><li>修复了功能性 bug 的时候再去提交</li><li>提交的代码最好无 bug</li></ul></li><li>每次 commit 之前都要 update<ul><li>因为你在编辑这个文件的时候，可能比人已经编辑并提交了某个版本</li><li>所以先 update，目的是为了检查一下服务器上有没有最新版，如果有，直接更新<ul><li>更新的过程中如果遇到冲突，不要慌，去手动解决</li></ul></li></ul></li><li>每次 commit 的时候都务必要写提交日志<ul><li>这个提交日志就好比你保存副本的时候加的一个标记</li><li>目的是为了日后做版本的回退查找以及查看记录更新状态</li></ul></li></ul><h3 id="使用总结"><a href="#使用总结" class="headerlink" title="使用总结"></a>使用总结</h3><ul><li>版本控制管理系统</li><li>源代码仓库 repository</li><li>检出代码 checkout</li><li>更新最新源代码 update</li><li>提交修改 commit</li></ul><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><ul><li><a href="http://holy2010.blog.51cto.com/1086044/645944">清除svn保存的username用户名和paasword密码(windows和linux)</a></li><li><a href="http://www.runoob.com/svn/svn-tutorial.html">菜鸟教程 - SVN 教程</a></li></ul><hr>]]></content>
    
    
    <categories>
      
      <category>SVN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SVN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Node基础总结</title>
    <link href="/2020/08/18/11.%E6%80%BBNode%E7%AC%94%E8%AE%B0%E6%80%BB%E7%BB%93/"/>
    <url>/2020/08/18/11.%E6%80%BBNode%E7%AC%94%E8%AE%B0%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="为什么要学习Node-js"><a href="#为什么要学习Node-js" class="headerlink" title="为什么要学习Node.js"></a>为什么要学习Node.js</h2><ul><li>企业需求<ul><li>具有服务端开发经验更改</li><li>front-end</li><li>back-end</li><li>全栈开发工程师</li><li>基本的网站开发能力<ul><li>服务端</li><li>前端</li><li>运维部署</li></ul></li><li>多人社区</li></ul></li></ul><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20200317114503403.png" srcset="/img/loading.gif" alt="image-20200317114503403"></p><h2 id="Node-js是什么"><a href="#Node-js是什么" class="headerlink" title="Node.js是什么"></a>Node.js是什么</h2><ul><li>Node.js是JavaScript 运行时</li><li>通俗易懂的讲，Node.js是JavaScript的运行平台</li><li>Node.js既不是语言，也不是框架，它是一个平台</li><li>浏览器中的JavaScript<ul><li>EcmaScript<ul><li>基本语法</li><li>if</li><li>var</li><li>function</li><li>Object</li><li>Array</li></ul></li><li>Bom</li><li>Dom</li></ul></li><li>Node.js中的JavaScript<ul><li>没有Bom，Dom</li><li>EcmaScript</li><li>在Node中这个JavaScript执行环境为JavaScript提供了一些服务器级别的API<ul><li>例如文件的读写</li><li>网络服务的构建</li><li>网络通信</li><li>http服务器</li></ul></li></ul></li><li>构建与Chrome的V8引擎之上<ul><li>代码只是具有特定格式的字符串</li><li>引擎可以认识它，帮你解析和执行</li><li>Google Chrome的V8引擎是目前公认的解析执行JavaScript代码最快的</li><li>Node.js的作者把Google Chrome中的V8引擎移植出来，开发了一个独立的JavaScript运行时环境</li></ul></li><li>Node.js uses an envent-driven,non-blocking I/O mode that makes it lightweight and efficent.<ul><li> envent-driven    事件驱动</li><li>non-blocking I/O mode   非阻塞I/O模型（异步）</li><li>ightweight and efficent.   轻量和高效</li></ul></li><li>Node.js package ecosystem,npm,is the larget scosystem of open sourcr libraries in the world<ul><li>npm 是世界上最大的开源生态系统</li><li>绝大多数JavaScript相关的包都存放在npm上，这样做的目的是为了让开发人员更方便的去下载使用</li><li>npm install jquery</li></ul></li></ul><h2 id="Node能做什么"><a href="#Node能做什么" class="headerlink" title="Node能做什么"></a>Node能做什么</h2><ul><li>web服务器后台</li><li>命令行工具<ul><li>npm(node)</li><li>git(c语言)</li><li>hexo（node）</li><li>…</li></ul></li><li>对于前端工程师来讲，接触最多的是它的命令行工具<ul><li>自己写的很少，主要是用别人第三方的</li><li>webpack</li><li>gulp</li><li>npm</li></ul></li></ul><h1 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h1><h2 id="安装Node环境"><a href="#安装Node环境" class="headerlink" title="安装Node环境"></a>安装Node环境</h2><ul><li>查看Node环境的版本号</li><li>下载：<a href="https://nodejs.org/en/">https://nodejs.org/en/</a></li><li>安装：<ul><li>傻瓜式安装，一路<code>next</code></li><li>安装过再次安装会升级</li></ul></li><li>确认Node环境是否安装成功<ul><li>查看node的版本号：<code>node --version</code></li><li>或者<code>node -v</code></li></ul></li><li>配置环境变量</li></ul><h2 id="解析执行JavaScript"><a href="#解析执行JavaScript" class="headerlink" title="解析执行JavaScript"></a>解析执行JavaScript</h2><ol><li>创建编写JavaScript脚本文件</li><li>打开终端，定位脚本文件的所属目录</li><li>输入<code>node  文件名</code>执行对应的文件</li></ol><p>注意：文件名不要用<code>node.js</code>来命名，也就是说除了<code>node</code>这个名字随便起，最好不要使用中文。</p><h2 id="文件的读写"><a href="#文件的读写" class="headerlink" title="文件的读写"></a>文件的读写</h2><p>文件读取:</p><pre><code class="hljs javascript"><span class="hljs-comment">//浏览器中的JavaScript是没有文件操作能力的</span><span class="hljs-comment">//但是Node中的JavaScript具有文件操作能力</span><span class="hljs-comment">//fs是file-system的简写，就是文件系统的意思</span><span class="hljs-comment">//在Node中如果想要进行文件的操作就必须引用fs这个核心模块</span><span class="hljs-comment">//在fs这个核心模块中，就提供了人所有文件操作相关的API</span><span class="hljs-comment">//例如 fs.readFile就是用来读取文件的</span><span class="hljs-comment">//  1.使用fs核心模块</span><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<span class="hljs-comment">// 2.读取文件</span>fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./data/a.txt&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">err,data</span>)&#123;   <span class="hljs-keyword">if</span>(err)&#123;        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;文件读取失败&#x27;</span>);   &#125;    <span class="hljs-keyword">else</span>&#123;         <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data.<span class="hljs-title function_">toString</span>());    &#125;&#125;)</code></pre><p>文件写入：</p><pre><code class="hljs javascript"><span class="hljs-comment">//  1.使用fs核心模块</span><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<span class="hljs-comment">// 2.将数据写入文件</span>fs.<span class="hljs-title function_">writeFile</span>(<span class="hljs-string">&#x27;./data/a.txt&#x27;</span>,<span class="hljs-string">&#x27;我是文件写入的信息&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">err,data</span>)&#123;   <span class="hljs-keyword">if</span>(err)&#123;        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;文件写入失败&#x27;</span>);   &#125;    <span class="hljs-keyword">else</span>&#123;         <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data.<span class="hljs-title function_">toString</span>());    &#125;&#125;)</code></pre><h2 id="http"><a href="#http" class="headerlink" title="http"></a>http</h2><p>服务器：</p><pre><code class="hljs javascript"><span class="hljs-comment">// 1.加载http核心模块</span><span class="hljs-keyword">var</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>);<span class="hljs-comment">// 2.使用http.createServer()创建一个web服务器</span><span class="hljs-keyword">var</span> server = http.<span class="hljs-title function_">createServer</span>();<span class="hljs-comment">// 3.服务器要做的事儿</span><span class="hljs-comment">// 提供服务：对数据服务</span><span class="hljs-comment">// 发请求</span><span class="hljs-comment">//接收请求</span><span class="hljs-comment">//处理请求</span><span class="hljs-comment">//反馈（发送响应）</span><span class="hljs-comment">//当客户端请求过来，就会自动触发服务器的request请求事件，然后执行第二个参数：回调处理函数</span>server.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;request&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;收到客户的请求了&#x27;</span>)&#125;)<span class="hljs-comment">// 4.绑定端口号，启动服务</span>server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;runing...&#x27;</span>)&#125;)</code></pre><h1 id="Node中的模块系统"><a href="#Node中的模块系统" class="headerlink" title="Node中的模块系统"></a>Node中的模块系统</h1><p>使用Node编写应用程序主要就是在使用：</p><ul><li><p>EcmaScript语言</p><ul><li>和浏览器一样，在Node中没有Bom和Dom</li></ul></li><li><p>核心模块</p><ul><li>文件操作的fs</li><li>http服务操作的http</li><li>url路径操作模块</li><li>path路径处理模块</li><li>os操作系统信息</li></ul></li><li><p>第三方模块</p><ul><li>art-template</li><li>必须通过npm来下载才可以使用</li></ul></li><li><p>自己写的模块</p><ul><li>自己创建的文件</li></ul></li></ul><h2 id="什么是模块化"><a href="#什么是模块化" class="headerlink" title="什么是模块化"></a>什么是模块化</h2><ul><li>文件作用域(模块是独立的，在不同的文件使用必须要重新引用)【在node中没有全局作用域，它是文件模块作用域】</li><li>通信规则<ul><li>加载require</li><li>导出exports</li></ul></li></ul><h2 id="CommonJS模块规范"><a href="#CommonJS模块规范" class="headerlink" title="CommonJS模块规范"></a>CommonJS模块规范</h2><p>在Node中的JavaScript还有一个重要的概念，模块系统。</p><ul><li><p>模块作用域</p></li><li><p>使用require方法来加载模块</p></li><li><p>使用exports接口对象来导出模板中的成员</p><h3 id="加载require"><a href="#加载require" class="headerlink" title="加载require"></a>加载<code>require</code></h3><p>语法：</p><pre><code class="hljs java"><span class="hljs-keyword">var</span> 自定义变量名 = require(<span class="hljs-string">&#x27;模块&#x27;</span>)</code></pre><p>作用：</p><ul><li>执行被加载模块中的代码</li><li>得到被加载模块中的<code>exports</code>导出接口对象</li></ul><h3 id="导出exports"><a href="#导出exports" class="headerlink" title="导出exports"></a>导出<code>exports</code></h3><ul><li><p>Node中是模块作用域，默认文件中所有的成员只在当前模块有效</p></li><li><p>对于希望可以被其他模块访问到的成员，我们需要把这些公开的成员都挂载到<code>exports</code>接口对象中就可以了</p><p>导出多个成员（必须在对象中）：</p><pre><code class="hljs javascript"><span class="hljs-built_in">exports</span>.<span class="hljs-property">a</span> = <span class="hljs-number">123</span>;<span class="hljs-built_in">exports</span>.<span class="hljs-property">b</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;bbb&#x27;</span>)&#125;;<span class="hljs-built_in">exports</span>.<span class="hljs-property">c</span> = &#123;    <span class="hljs-attr">foo</span>:<span class="hljs-string">&quot;bar&quot;</span>&#125;;<span class="hljs-built_in">exports</span>.<span class="hljs-property">d</span> = <span class="hljs-string">&#x27;hello&#x27;</span>;</code></pre><p>导出单个成员（拿到的就是函数，字符串）：</p><pre><code class="hljs javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-string">&#x27;hello&#x27;</span>;</code></pre><p>以下情况会覆盖：</p><pre><code class="hljs javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-string">&#x27;hello&#x27;</span>;<span class="hljs-comment">//后者会覆盖前者</span><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x,y</span>) &#123;    <span class="hljs-keyword">return</span> x+y;&#125;</code></pre><p>也可以通过以下方法来导出多个成员：</p><pre><code class="hljs javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;    foo = <span class="hljs-string">&#x27;hello&#x27;</span>,    <span class="hljs-attr">add</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;        <span class="hljs-keyword">return</span> x+y;    &#125;&#125;;</code></pre></li></ul></li></ul><h2 id="模块原理"><a href="#模块原理" class="headerlink" title="模块原理"></a>模块原理</h2><p>exports和<code>module.exports</code>的一个引用：</p><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">exports</span> === <span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>);<span class="hljs-comment">//true</span><span class="hljs-built_in">exports</span>.<span class="hljs-property">foo</span> = <span class="hljs-string">&#x27;bar&#x27;</span>;<span class="hljs-comment">//等价于</span><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>.<span class="hljs-property">foo</span> = <span class="hljs-string">&#x27;bar&#x27;</span>;</code></pre><p><code>当给exports重新赋值后，exports！= module.exports.</code></p><p><code>最终return的是module.exports,无论exports中的成员是什么都没用。</code></p><pre><code class="hljs javascript">真正去使用的时候：导出单个成员：<span class="hljs-built_in">exports</span>.<span class="hljs-property">xxx</span> = xxx;导出多个成员：<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> 或者 modeule.<span class="hljs-property">exports</span> = &#123;&#125;;</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><pre><code class="hljs javascript"><span class="hljs-comment">// 引用服务</span><span class="hljs-keyword">var</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>);<span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<span class="hljs-comment">// 引用模板</span><span class="hljs-keyword">var</span> template = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;art-template&#x27;</span>);<span class="hljs-comment">// 创建服务</span><span class="hljs-keyword">var</span> server = http.<span class="hljs-title function_">createServer</span>();<span class="hljs-comment">// 公共路径</span><span class="hljs-keyword">var</span> wwwDir = <span class="hljs-string">&#x27;D:/app/www&#x27;</span>;server.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;request&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) &#123;    <span class="hljs-keyword">var</span> url = req.<span class="hljs-property">url</span>;    <span class="hljs-comment">// 读取文件</span>    fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./template-apche.html&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">err, data</span>) &#123;        <span class="hljs-keyword">if</span> (err) &#123;            <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">end</span>(<span class="hljs-string">&#x27;404 Not Found&#x27;</span>);        &#125;        fs.<span class="hljs-title function_">readdir</span>(wwwDir, <span class="hljs-keyword">function</span> (<span class="hljs-params">err, files</span>) &#123;            <span class="hljs-keyword">if</span> (err) &#123;                <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">end</span>(<span class="hljs-string">&#x27;Can not find www Dir.&#x27;</span>)            &#125;            <span class="hljs-comment">// 使用模板引擎解析替换data中的模板字符串</span>            <span class="hljs-comment">// 去xmpTempleteList.html中编写模板语法</span>            <span class="hljs-keyword">var</span> htmlStr = template.<span class="hljs-title function_">render</span>(data.<span class="hljs-title function_">toString</span>(), &#123;                 <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;D:/app/www/ 的索引&#x27;</span>,                <span class="hljs-attr">files</span>:files             &#125;);            <span class="hljs-comment">// 发送响应数据</span>            res.<span class="hljs-title function_">end</span>(htmlStr);        &#125;)    &#125;)&#125;);server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;running....&#x27;</span>);&#125;)</code></pre><pre><code class="hljs javascript"><span class="hljs-number">1.</span>jQuery中的each 和 原生<span class="hljs-title class_">JavaScript</span>方法forEach的区别：提供源头：    原生js是es5提供的（不兼容<span class="hljs-title class_">IE8</span>）,        jQuery的each是jQuery第三方库提供的（如果要使用需要用<span class="hljs-number">2</span>以下的版本也就是<span class="hljs-number">1.</span>版本）,它的each方法主要用来遍历jQuery实例对象（伪数组）,同时也可以做低版本forEach的替代品,jQuery的实例对象不能使用forEach方法，如果想要使用必须转为数组（[].<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(jQuery实例对象)）才能使用<span class="hljs-number">2.</span>模块中导出多个成员和导出单个成员<span class="hljs-number">3.301</span>和<span class="hljs-number">302</span>的区别：<span class="hljs-number">301</span>永久重定向,浏览器会记住    <span class="hljs-number">302</span>临时重定向<span class="hljs-number">4.</span><span class="hljs-built_in">exports</span>和<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>的区别:每个模块中都有一个<span class="hljs-variable language_">module</span>对象    <span class="hljs-variable language_">module</span>对象中有一个<span class="hljs-built_in">exports</span>对象    我们可以把需要导出的成员都挂载到<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>接口对象中也就是<span class="hljs-string">`module.exports.xxx = xxx`</span>的方式    但是每次写太多了就很麻烦，所以<span class="hljs-title class_">Node</span>为了简化代码，就在每一个模块中都提供了一个成员叫<span class="hljs-string">`exports`</span>    <span class="hljs-string">`exports === module.exports`</span>结果为<span class="hljs-literal">true</span>,所以完全可以<span class="hljs-string">`exports.xxx = xxx`</span>    当一个模块需要导出单个成员的时候必须使用<span class="hljs-string">`module.exports = xxx`</span>的方式，=,使用<span class="hljs-string">`exports = xxx`</span>不管用,因为每个模块最终<span class="hljs-keyword">return</span>的是<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>,而<span class="hljs-built_in">exports</span>只是<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>的一个引用,所以<span class="hljs-string">`exports`</span>即使重新赋值,也不会影响<span class="hljs-string">`module.exports`</span>。    有一种赋值方式比较特殊：<span class="hljs-string">`exports = module.exports`</span>这个用来新建立引用关系的。</code></pre><h1 id="require的加载规则"><a href="#require的加载规则" class="headerlink" title="require的加载规则"></a>require的加载规则</h1><ul><li><p>核心模块</p><ul><li>模块名</li></ul></li><li><p>第三方模块</p><ul><li>模块名</li></ul></li><li><p>用户自己写的</p><ul><li>路径</li></ul></li></ul><h2 id="require的加载规则："><a href="#require的加载规则：" class="headerlink" title="require的加载规则："></a>require的加载规则：</h2><ul><li><p>优先从缓存加载</p></li><li><p>判断模块标识符</p><ul><li>核心模块</li><li>自己写的模块（路径形式的模块）</li><li>第三方模块（node_modules）<ul><li>第三方模块的标识就是第三方模块的名称（不可能有第三方模块和核心模块的名字一致）</li><li>npm<ul><li>开发人员可以把写好的框架库发布到npm上</li><li>使用者通过npm命令来下载</li></ul></li><li>使用方式：<code>var 名称 = require(&#39;npm install【下载包】 的包名&#39;)</code><ul><li>node_modules/express/package.json main</li><li>如果package.json或者main不成立，则查找被选择项：index.js</li><li>如果以上条件都不满足，则继续进入上一级目录中的node_modules按照上面的规则依次查找，直到当前文件所属此盘根目录都找不到最后报错</li></ul></li></ul></li></ul></li></ul><pre><code class="hljs javascript"><span class="hljs-comment">// 如果非路径形式的标识</span><span class="hljs-comment">// 路径形式的标识：</span>    <span class="hljs-comment">// ./  当前目录 不可省略</span>    <span class="hljs-comment">// ../  上一级目录  不可省略</span>    <span class="hljs-comment">//  /xxx也就是D:/xxx</span>    <span class="hljs-comment">// 带有绝对路径几乎不用（D:/a/foo.js）</span><span class="hljs-comment">// 首位表示的是当前文件模块所属磁盘根目录</span><span class="hljs-comment">// require(&#x27;./a&#x27;); </span><span class="hljs-comment">// 核心模块</span><span class="hljs-comment">// 核心模块本质也是文件，核心模块文件已经被编译到了二进制文件中了，我们只需要按照名字来加载就可以了</span><span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>); <span class="hljs-comment">// 第三方模块</span><span class="hljs-comment">// 凡是第三方模块都必须通过npm下载（npm i node_modules），使用的时候就可以通过require(&#x27;包名&#x27;)来加载才可以使用</span><span class="hljs-comment">// 第三方包的名字不可能和核心模块的名字是一样的</span><span class="hljs-comment">// 既不是核心模块，也不是路径形式的模块</span><span class="hljs-comment">//      先找到当前文所述目录的node_modules</span><span class="hljs-comment">//      然后找node_modules/art-template目录</span><span class="hljs-comment">//      node_modules/art-template/package.json</span><span class="hljs-comment">//      node_modules/art-template/package.json中的main属性</span><span class="hljs-comment">//      main属性记录了art-template的入口模块</span><span class="hljs-comment">//      然后加载使用这个第三方包</span><span class="hljs-comment">//      实际上最终加载的还是文件</span><span class="hljs-comment">//      如果package.json不存在或者mian指定的入口模块不存在</span><span class="hljs-comment">//      则node会自动找该目录下的index.js</span><span class="hljs-comment">//      也就是说index.js是一个备选项，如果main没有指定，则加载index.js文件</span><span class="hljs-comment">//      </span>        <span class="hljs-comment">// 如果条件都不满足则会进入上一级目录进行查找</span><span class="hljs-comment">// 注意：一个项目只有一个node_modules，放在项目根目录中，子目录可以直接调用根目录的文件</span><span class="hljs-keyword">var</span> template = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;art-template&#x27;</span>);</code></pre><h2 id="模块标识符中的-和文件操作路径中的"><a href="#模块标识符中的-和文件操作路径中的" class="headerlink" title="模块标识符中的/和文件操作路径中的/"></a>模块标识符中的<code>/</code>和文件操作路径中的<code>/</code></h2><p>文件操作路径：</p><pre><code class="hljs javascript"><span class="hljs-comment">// 咱们所使用的所有文件操作的API都是异步的</span><span class="hljs-comment">// 就像ajax请求一样</span><span class="hljs-comment">// 读取文件</span><span class="hljs-comment">// 文件操作中 ./ 相当于当前模块所处磁盘根目录</span><span class="hljs-comment">// ./index.txt    相对于当前目录</span><span class="hljs-comment">// /index.txt    相对于当前目录</span><span class="hljs-comment">// /index.txt   绝对路径,当前文件模块所处根目录</span><span class="hljs-comment">// d:express/index.txt   绝对路径</span>fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./index.txt&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">err,data</span>)&#123;    <span class="hljs-keyword">if</span>(err)&#123;       <span class="hljs-keyword">return</span>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;读取失败&#x27;</span>);    &#125;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data.<span class="hljs-title function_">toString</span>());&#125;)</code></pre><p>模块操作路径：</p><pre><code class="hljs javascript"><span class="hljs-comment">// 在模块加载中，相对路径中的./不能省略</span><span class="hljs-comment">// 这里省略了.也是磁盘根目录</span><span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./index&#x27;</span>)(<span class="hljs-string">&#x27;hello&#x27;</span>)</code></pre><h1 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h1><ul><li>node package manage(node包管理器)</li><li>通过npm命令安装jQuery包（npm install –save jquery），在安装时加上–save会主动生成说明书文件信息（将安装文件的信息添加到package.json里面）</li></ul><h3 id="npm网站"><a href="#npm网站" class="headerlink" title="npm网站"></a>npm网站</h3><blockquote><p>​    npmjs.com    网站   是用来搜索npm包的</p></blockquote><h3 id="npm命令行工具"><a href="#npm命令行工具" class="headerlink" title="npm命令行工具"></a>npm命令行工具</h3><p>npm是一个命令行工具，只要安装了node就已经安装了npm。</p><p>npm也有版本概念，可以通过<code>npm --version</code>来查看npm的版本</p><p>升级npm(自己升级自己)：</p><pre><code class="hljs javascript">npm install --<span class="hljs-variable language_">global</span> npm</code></pre><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ul><li>npm init(生成package.json说明书文件)<ul><li>npm init -y(可以跳过向导，快速生成)</li></ul></li><li>npm install<ul><li>一次性把dependencies选项中的依赖项全部安装</li><li>简写（npm i）</li></ul></li><li>npm install 包名<ul><li>只下载</li><li>简写（npm i 包名）</li></ul></li><li>npm install –save 包名<ul><li>下载并且保存依赖项（package.json文件中的dependencies选项）</li><li>简写（npm i  包名）</li></ul></li><li>npm uninstall 包名<ul><li>只删除，如果有依赖项会依然保存</li><li>简写（npm un 包名）</li></ul></li><li>npm uninstall –save 包名<ul><li>删除的同时也会把依赖信息全部删除</li><li>简写（npm un 包名）</li></ul></li><li>npm help<ul><li>查看使用帮助</li></ul></li><li>npm 命令 –help<ul><li>查看具体命令的使用帮助（npm uninstall –help）</li></ul></li></ul><h3 id="解决npm被墙问题"><a href="#解决npm被墙问题" class="headerlink" title="解决npm被墙问题"></a>解决npm被墙问题</h3><p>npm存储包文件的服务器在国外，有时候会被墙，速度很慢，所以需要解决这个问题。</p><blockquote><p><a href="https://developer.aliyun.com/mirror/NPM?from=tnpm%E6%B7%98%E5%AE%9D%E7%9A%84%E5%BC%80%E5%8F%91%E5%9B%A2%E9%98%9F%E6%8A%8Anpm%E5%9C%A8%E5%9B%BD%E5%86%85%E5%81%9A%E4%BA%86%E4%B8%80%E4%B8%AA%E9%95%9C%E5%83%8F%EF%BC%88%E4%B9%9F%E5%B0%B1%E6%98%AF%E4%B8%80%E4%B8%AA%E5%A4%87%E4%BB%BD%EF%BC%89%E3%80%82">https://developer.aliyun.com/mirror/NPM?from=tnpm淘宝的开发团队把npm在国内做了一个镜像（也就是一个备份）。</a></p></blockquote><p>安装淘宝的cnpm：</p><pre><code class="hljs javascript">npm install -g cnpm --registry=<span class="hljs-attr">https</span>:<span class="hljs-comment">//registry.npm.taobao.org;</span></code></pre><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">在任意目录执行都可以</span><span class="hljs-meta prompt_">#</span><span class="language-bash">--global表示安装到全局，而非当前目录</span><span class="hljs-meta prompt_">#</span><span class="language-bash">--global不能省略，否则不管用</span>npm install --global cnpm</code></pre><p>安装包的时候把以前的<code>npm</code>替换成<code>cnpm</code>。</p><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">走国外的npm服务器下载jQuery包，速度比较慢</span>npm install jQuery;<span class="hljs-meta prompt_"></span><span class="hljs-meta prompt_">#</span><span class="language-bash">使用cnpm就会通过淘宝的服务器来下载jQuery</span>cnpm install jQuery;</code></pre><p>如果不想安装<code>cnpm</code>又想使用淘宝的服务器来下载：</p><pre><code class="hljs shell">npm install jquery --registry=https://npm.taobao.org;</code></pre><p>但是每次手动加参数就很麻烦，所以我们可以把这个选项加入到配置文件中：</p><pre><code class="hljs shell">npm config set registry https://npm.taobao.org;<span class="hljs-meta prompt_"></span><span class="hljs-meta prompt_">#</span><span class="language-bash">查看npm配置信息</span>npm config list;</code></pre><p>只要经过上面的配置命令，则以后所有的<code>npm install</code>都会通过淘宝的服务器来下载</p><h1 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h1><p>每一个项目都要有一个<code>package.json</code>文件（包描述文件，就像产品的说明书一样）</p><p>这个文件可以通过<code>npm init</code>自动初始化出来</p><pre><code class="hljs javascript"><span class="hljs-attr">D</span>:\code\node中的模块系统&gt;npm init<span class="hljs-title class_">This</span> utility will walk you through creating a package.<span class="hljs-property">json</span> file.<span class="hljs-title class_">It</span> only covers the most common items, and tries to guess sensible defaults.<span class="hljs-title class_">See</span> <span class="hljs-string">`npm help json`</span> <span class="hljs-keyword">for</span> definitive documentation on these fieldsand exactly what they <span class="hljs-keyword">do</span>.<span class="hljs-title class_">Use</span> <span class="hljs-string">`npm install &lt;pkg&gt;`</span> afterwards to install a package andsave it <span class="hljs-keyword">as</span> a dependency <span class="hljs-keyword">in</span> the package.<span class="hljs-property">json</span> file.<span class="hljs-title class_">Press</span> ^C at any time to quit.package <span class="hljs-attr">name</span>: (node中的模块系统)<span class="hljs-title class_">Sorry</span>, name can only contain <span class="hljs-variable constant_">URL</span>-friendly characters.package <span class="hljs-attr">name</span>: (node中的模块系统) cls<span class="hljs-attr">version</span>: (<span class="hljs-number">1.0</span><span class="hljs-number">.0</span>)<span class="hljs-attr">description</span>: 这是一个测试项目entry <span class="hljs-attr">point</span>: (main.<span class="hljs-property">js</span>)test <span class="hljs-attr">command</span>:git <span class="hljs-attr">repository</span>:<span class="hljs-attr">keywords</span>:<span class="hljs-attr">author</span>: xiaochen<span class="hljs-attr">license</span>: (<span class="hljs-variable constant_">ISC</span>)<span class="hljs-title class_">About</span> to write to <span class="hljs-attr">D</span>:\code\node中的模块系统\package.<span class="hljs-property">json</span>:&#123;  <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;cls&quot;</span>,  <span class="hljs-string">&quot;version&quot;</span>: <span class="hljs-string">&quot;1.0.0&quot;</span>,  <span class="hljs-string">&quot;description&quot;</span>: <span class="hljs-string">&quot;这是一个测试项目&quot;</span>,  <span class="hljs-string">&quot;main&quot;</span>: <span class="hljs-string">&quot;main.js&quot;</span>,  <span class="hljs-string">&quot;scripts&quot;</span>: &#123;    <span class="hljs-string">&quot;test&quot;</span>: <span class="hljs-string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span>  &#125;,  <span class="hljs-string">&quot;author&quot;</span>: <span class="hljs-string">&quot;xiaochen&quot;</span>,  <span class="hljs-string">&quot;license&quot;</span>: <span class="hljs-string">&quot;ISC&quot;</span>&#125;<span class="hljs-title class_">Is</span> <span class="hljs-variable language_">this</span> <span class="hljs-variable constant_">OK</span>? (yes) yes</code></pre><p>对于目前来讲，最有用的是<code>dependencies</code>选项，可以用来帮助我们保存第三方包的依赖信息。</p><p>如果<code>node_modules</code>删除了也不用担心，只需要在控制面板中<code>npm install</code>就会自动把<code>package.json</code>中的<code>dependencies</code>中所有的依赖项全部都下载回来。</p><ul><li>建议每个项目的根目录下都有一个<code>package.json</code>文件</li><li>建议执行<code>npm install 包名</code>的时候都加上<code>--save</code>选项，目的是用来保存依赖信息</li></ul><h2 id="package-json和package-lock-json"><a href="#package-json和package-lock-json" class="headerlink" title="package.json和package-lock.json"></a>package.json和package-lock.json</h2><p>npm 5以前是不会有<code>package-lock.json</code>这个文件</p><p>npm5以后才加入这个文件</p><p>当你安装包的时候，npm都会生成或者更新<code>package-lock.json</code>这个文件</p><ul><li>npm5以后的版本安装都不要加<code>--save</code>参数，它会自动保存依赖信息</li><li>当你安装包的时候，会自动创建或者更新<code>package-lock.json</code>文件</li><li><code>package-lock.json</code>这个文件会包含<code>node_modules</code>中所有包的信息（版本，下载地址。。。）<ul><li>这样的话重新<code>npm install</code>的时候速度就可以提升</li></ul></li><li>从文件来看，有一个<code>lock</code>称之为锁<ul><li>这个<code>lock</code>使用来锁版本的</li><li>如果项目依赖了<code>1.1.1</code>版本</li><li>如果你重新install其实会下载最细版本，而不是<code>1.1.1</code></li><li><code>package-lock.json</code>的另外一个作用就是锁定版本号，防止自动升级</li></ul></li></ul><h2 id="path路径操作模块"><a href="#path路径操作模块" class="headerlink" title="path路径操作模块"></a>path路径操作模块</h2><blockquote><p>参考文档：<a href="https://nodejs.org/docs/latest-v13.x/api/path.html">https://nodejs.org/docs/latest-v13.x/api/path.html</a></p></blockquote><ul><li>path.basename：获取路径的文件名，默认包含扩展名</li><li>path.dirname：获取路径中的目录部分</li><li>path.extname：获取一个路径中的扩展名部分</li><li>path.parse：把路径转换为对象<ul><li>root：根路径</li><li>dir：目录</li><li>base：包含后缀名的文件名</li><li>ext：后缀名</li><li>name：不包含后缀名的文件名</li></ul></li><li>path.join：拼接路径</li><li>path.isAbsolute：判断一个路径是否为绝对路径<img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20200315150610001.png" srcset="/img/loading.gif" alt="image-20200315150610001"></li></ul><h1 id="Node中的其它成员-dirname-filename"><a href="#Node中的其它成员-dirname-filename" class="headerlink" title="Node中的其它成员(__dirname,__filename)"></a>Node中的其它成员(__dirname,__filename)</h1><p>在每个模块中，除了<code>require</code>,<code>exports</code>等模块相关的API之外，还有两个特殊的成员：</p><ul><li><p><code>__dirname</code>，是一个成员，可以用来<strong>动态</strong>获取当前文件模块所属目录的绝对路径</p></li><li><p><code>__filename</code>，可以用来<strong>动态</strong>获取当前文件的绝对路径（包含文件名）</p></li><li><p><code>__dirname</code>和<code>filename</code>是不受执行node命令所属路径影响的</p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20200315151551873.png" srcset="/img/loading.gif" alt="image-20200315151551873"></p></li></ul><p>在文件操作中，使用相对路径是不可靠的，因为node中文件操作的路径被设计为相对于执行node命令所处的路径。</p><p>所以为了解决这个问题，只需要把相对路径变为绝对路径（绝对路径不受任何影响）就可以了。</p><p>就可以使用<code>__dirname</code>或者<code>__filename</code>来帮助我们解决这个问题</p><p>在拼接路径的过程中，为了避免手动拼接带来的一些低级错误，推荐使用<code>path.join()</code>来辅助拼接</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<span class="hljs-keyword">var</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<span class="hljs-comment">// console.log(__dirname + &#x27;a.txt&#x27;);</span><span class="hljs-comment">// path.join方法会将文件操作中的相对路径都统一的转为动态的绝对路径</span>fs.<span class="hljs-title function_">readFile</span>(path.<span class="hljs-title function_">join</span>(__dirname + <span class="hljs-string">&#x27;/a.txt&#x27;</span>),<span class="hljs-string">&#x27;utf8&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">err,data</span>)&#123;<span class="hljs-keyword">if</span>(err)&#123;<span class="hljs-keyword">throw</span> err&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);&#125;);</code></pre><blockquote><p>补充：模块中的路径标识和这里的路径没关系，不受影响（就是相对于文件模块）</p></blockquote><blockquote><p><strong>注意：</strong></p><p><strong>模块中的路径标识和文件操作中的相对路径标识不一致</strong></p><p><strong>模块中的路径标识就是相对于当前文件模块，不受node命令所处路径影响</strong></p></blockquote><h1 id="Express（快速的）"><a href="#Express（快速的）" class="headerlink" title="Express（快速的）"></a>Express（快速的）</h1><p>作者：Tj</p><p>原生的http在某些方面表现不足以应对我们的开发需求，所以就需要使用框架来加快我们的开发效率，框架的目的就是提高效率，让我们的代码高度统一。</p><p>在node中有很多web开发框架。主要学习express</p><ul><li><p><code>http://expressjs.com/</code>,其中主要封装的是http。</p></li><li><pre><code class="javascript">// 1 安装// 2 引包var express = require(&#39;express&#39;);// 3 创建服务器应用程序//      也就是原来的http.createServer();var app = express();// 公开指定目录// 只要通过这样做了，就可以通过/public/xx的方式来访问public目录中的所有资源// 在Express中开放资源就是一个API的事app.use(&#39;/public/&#39;,express.static(&#39;/public/&#39;));//模板引擎在Express中开放模板也是一个API的事// 当服务器收到get请求 / 的时候，执行回调处理函数app.get(&#39;/&#39;,function(req,res)&#123;    res.send(&#39;hello express&#39;);&#125;)// 相当于server.listenapp.listen(3000,function()&#123;    console.log(&#39;app is runing at port 3000&#39;);&#125;)<pre><code class="hljs clean">### 学习Express#### 起步##### 安装：![image<span class="hljs-number">-20200310123723079</span>](C:\Users\A\AppData\Roaming\Typora\typora-user-images\image<span class="hljs-number">-20200310123723079.</span>png)```javascriptcnpm install express</code></pre></code></pre></li></ul><h5 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world:"></a>hello world:<img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20200310124850557.png" srcset="/img/loading.gif" alt="image-20200310124850557"></h5><pre><code class="hljs javascript"><span class="hljs-comment">// 引入express</span><span class="hljs-keyword">var</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<span class="hljs-comment">// 1. 创建app</span><span class="hljs-keyword">var</span> app = <span class="hljs-title function_">express</span>();<span class="hljs-comment">//  2. </span>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">req,res</span>)&#123;    <span class="hljs-comment">// 1</span>    <span class="hljs-comment">// res.write(&#x27;Hello&#x27;);</span>    <span class="hljs-comment">// res.write(&#x27;World&#x27;);</span>    <span class="hljs-comment">// res.end()</span>    <span class="hljs-comment">// 2</span>    <span class="hljs-comment">// res.end(&#x27;hello world&#x27;);</span>    <span class="hljs-comment">// 3</span>    res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;hello world&#x27;</span>);&#125;)app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;express app is runing...&#x27;</span>);&#125;)</code></pre><h5 id="基本路由"><a href="#基本路由" class="headerlink" title="基本路由"></a>基本路由</h5><p>路由：</p><ul><li><p>请求方法</p></li><li><p>请求路径</p></li><li><p>请求处理函数</p></li></ul><p>get:</p><pre><code class="hljs javascript"><span class="hljs-comment">//当你以get方法请求/的时候，执行对应的处理函数</span>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">req,res</span>)&#123;    res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;hello world&#x27;</span>);&#125;)</code></pre><p>post:</p><pre><code class="hljs javascript"><span class="hljs-comment">//当你以post方法请求/的时候，执行对应的处理函数</span>app.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">req,res</span>)&#123;    res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;hello world&#x27;</span>);&#125;)</code></pre><h5 id="Express静态服务API"><a href="#Express静态服务API" class="headerlink" title="Express静态服务API"></a>Express静态服务API</h5><pre><code class="hljs javascript"><span class="hljs-comment">// app.use不仅仅是用来处理静态资源的，还可以做很多工作(body-parser的配置)</span>app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">static</span>(<span class="hljs-string">&#x27;public&#x27;</span>));app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">static</span>(<span class="hljs-string">&#x27;files&#x27;</span>));app.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;/stataic&#x27;</span>,express.<span class="hljs-title function_">static</span>(<span class="hljs-string">&#x27;public&#x27;</span>));</code></pre><pre><code class="hljs javascript"><span class="hljs-comment">// 引入express</span><span class="hljs-keyword">var</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<span class="hljs-comment">// 创建app</span><span class="hljs-keyword">var</span> app = <span class="hljs-title function_">express</span>();<span class="hljs-comment">// 开放静态资源</span><span class="hljs-comment">// 1.当以/public/开头的时候，去./public/目录中找对应资源</span><span class="hljs-comment">// 访问：http://127.0.0.1:3000/public/login.html</span>app.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;/public/&#x27;</span>,express.<span class="hljs-title function_">static</span>(<span class="hljs-string">&#x27;./public/&#x27;</span>)); <span class="hljs-comment">// 2.当省略第一个参数的时候，可以通过省略/public的方式来访问</span><span class="hljs-comment">// 访问：http://127.0.0.1:3000/login.html</span><span class="hljs-comment">// app.use(express.static(&#x27;./public/&#x27;));   </span><span class="hljs-comment">// 3.访问：http://127.0.0.1:3000/a/login.html</span><span class="hljs-comment">// a相当于public的别名</span><span class="hljs-comment">// app.use(&#x27;/a/&#x27;,express.static(&#x27;./public/&#x27;)); </span><span class="hljs-comment">//  </span>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">req,res</span>)&#123;    res.<span class="hljs-title function_">end</span>(<span class="hljs-string">&#x27;hello world&#x27;</span>);&#125;);app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;express app is runing...&#x27;</span>);&#125;);</code></pre><h5 id="在Express中配置使用art-templete模板引擎"><a href="#在Express中配置使用art-templete模板引擎" class="headerlink" title="在Express中配置使用art-templete模板引擎"></a>在Express中配置使用<code>art-templete</code>模板引擎</h5><ul><li><a href="https://aui.github.io/art-template/">art-template官方文档</a></li><li>在node中，有很多第三方模板引擎都可以使用，不是只有<code>art-template</code><ul><li>还有ejs，jade（pug），handlebars，nunjucks</li></ul></li></ul><p>安装：</p><pre><code class="hljs shell">npm install --save art-templatenpm install --save express-art-template//两个一起安装npm i --save art-template express-art-template</code></pre><p>配置：</p><pre><code class="hljs javascript">app.<span class="hljs-title function_">engine</span>(<span class="hljs-string">&#x27;html&#x27;</span>, <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express-art-template&#x27;</span>));</code></pre><p>使用：</p><pre><code class="hljs javascript">app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">req,res</span>)&#123;    <span class="hljs-comment">// express默认会去views目录找index.html</span>    res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;index.html&#x27;</span>,&#123;           <span class="hljs-attr">title</span>:<span class="hljs-string">&#x27;hello world&#x27;</span>         &#125;);&#125;)</code></pre><p>如果希望修改默认的<code>views</code>视图渲染存储目录，可以：</p><pre><code class="hljs javascript"><span class="hljs-comment">// 第一个参数views千万不要写错</span>app.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;views&#x27;</span>,目录路径);</code></pre><h5 id="在Express中获取表单请求数据"><a href="#在Express中获取表单请求数据" class="headerlink" title="在Express中获取表单请求数据"></a>在Express中获取表单请求数据</h5><h6 id="获取get请求数据："><a href="#获取get请求数据：" class="headerlink" title="获取get请求数据："></a>获取get请求数据：</h6><p>Express内置了一个api，可以直接通过<code>req.query</code>来获取数据</p><pre><code class="hljs javascript"><span class="hljs-comment">// 通过requery方法获取用户输入的数据</span><span class="hljs-comment">// req.query只能拿到get请求的数据</span> <span class="hljs-keyword">var</span> comment = req.<span class="hljs-property">query</span>;</code></pre><h6 id="获取post请求数据："><a href="#获取post请求数据：" class="headerlink" title="获取post请求数据："></a>获取post请求数据：</h6><p>在Express中没有内置获取表单post请求体的api，这里我们需要使用一个第三方包<code>body-parser</code>来获取数据。</p><p>安装：</p><pre><code class="hljs javascript">npm install --save body-parser;</code></pre><p>配置：</p><p>// 配置解析表单 POST 请求体插件（注意：一定要在 app.use(router) 之前 ）</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<span class="hljs-comment">// 引包</span><span class="hljs-keyword">var</span> bodyParser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;body-parser&#x27;</span>)<span class="hljs-keyword">var</span> app = <span class="hljs-title function_">express</span>()<span class="hljs-comment">// 配置body-parser</span><span class="hljs-comment">// 只要加入这个配置，则在req请求对象上会多出来一个属性：body</span><span class="hljs-comment">// 也就是说可以直接通过req.body来获取表单post请求数据</span><span class="hljs-comment">// parse application/x-www-form-urlencoded</span>app.<span class="hljs-title function_">use</span>(bodyParser.<span class="hljs-title function_">urlencoded</span>(&#123; <span class="hljs-attr">extended</span>: <span class="hljs-literal">false</span> &#125;))<span class="hljs-comment">// parse application/json</span>app.<span class="hljs-title function_">use</span>(bodyParser.<span class="hljs-title function_">json</span>())</code></pre><p>使用：</p><pre><code class="hljs javascript">app.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) &#123;  res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&#x27;Content-Type&#x27;</span>, <span class="hljs-string">&#x27;text/plain&#x27;</span>)  res.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27;you posted:\n&#x27;</span>)  <span class="hljs-comment">// 可以通过req.body来获取表单请求数据</span>  res.<span class="hljs-title function_">end</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(req.<span class="hljs-property">body</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">2</span>))&#125;)</code></pre><h3 id="在Express中配置使用express-session插件操作"><a href="#在Express中配置使用express-session插件操作" class="headerlink" title="在Express中配置使用express-session插件操作"></a>在Express中配置使用<code>express-session</code>插件操作</h3><blockquote><p>参考文档：<a href="https://github.com/expressjs/session">https://github.com/expressjs/session</a></p></blockquote><p>安装：</p><pre><code class="hljs javascript">npm install express-session</code></pre><p>配置：</p><pre><code class="hljs javascript"><span class="hljs-comment">//该插件会为req请求对象添加一个成员:req.session默认是一个对象</span><span class="hljs-comment">//这是最简单的配置方式</span><span class="hljs-comment">//Session是基于Cookie实现的</span>app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">session</span>(&#123;  <span class="hljs-comment">//配置加密字符串，他会在原有的基础上和字符串拼接起来去加密</span>  <span class="hljs-comment">//目的是为了增加安全性，防止客户端恶意伪造</span>  <span class="hljs-attr">secret</span>: <span class="hljs-string">&#x27;keyboard cat&#x27;</span>,  <span class="hljs-attr">resave</span>: <span class="hljs-literal">false</span>,  <span class="hljs-attr">saveUninitialized</span>: <span class="hljs-literal">true</span>,<span class="hljs-comment">//无论是否适用Session，都默认直接分配一把钥匙</span>  <span class="hljs-attr">cookie</span>: &#123; <span class="hljs-attr">secure</span>: <span class="hljs-literal">true</span> &#125;&#125;))</code></pre><p>使用：</p><pre><code class="hljs javascript"><span class="hljs-comment">// 读</span><span class="hljs-comment">//添加Session数据</span><span class="hljs-comment">//session就是一个对象</span>req.<span class="hljs-property">session</span>.<span class="hljs-property">foo</span> = <span class="hljs-string">&#x27;bar&#x27;</span>;<span class="hljs-comment">//写</span><span class="hljs-comment">//获取session数据</span>req.<span class="hljs-property">session</span>.<span class="hljs-property">foo</span><span class="hljs-comment">//删</span>req.<span class="hljs-property">session</span>.<span class="hljs-property">foo</span> = <span class="hljs-literal">null</span>;<span class="hljs-keyword">delete</span> req.<span class="hljs-property">session</span>.<span class="hljs-property">foo</span></code></pre><p>提示：</p><p>默认Session数据时内存储数据，服务器一旦重启，真正的生产环境会把Session进行持久化存储。</p><h3 id="利用Express实现ADUS项目"><a href="#利用Express实现ADUS项目" class="headerlink" title="利用Express实现ADUS项目"></a>利用Express实现ADUS项目</h3><h4 id="模块化思想"><a href="#模块化思想" class="headerlink" title="模块化思想"></a>模块化思想</h4><p>模块如何划分:</p><ul><li>模块职责要单一</li></ul><p>javascript模块化：</p><ul><li>Node 中的 CommonJS</li><li>浏览器中的：<ul><li>AMD    require.js</li><li>CMD     sea.js</li></ul></li><li>es6中增加了官方支持</li></ul><h4 id="起步-1"><a href="#起步-1" class="headerlink" title="起步"></a>起步</h4><ul><li>初始化</li><li>模板处理</li></ul><h4 id="路由设计"><a href="#路由设计" class="headerlink" title="路由设计"></a>路由设计</h4><table><thead><tr><th>请求方法</th><th align="left">请求路径</th><th align="left">get参数</th><th>post参数</th><th align="left">备注</th></tr></thead><tbody><tr><td>GET</td><td align="left">/students</td><td align="left"></td><td></td><td align="left">渲染首页</td></tr><tr><td>GET</td><td align="left">/students/new</td><td align="left"></td><td></td><td align="left">渲染添加学生页面</td></tr><tr><td>POST</td><td align="left">/students/new</td><td align="left"></td><td>name,age,gender,hobbies</td><td align="left">处理添加学生请求</td></tr><tr><td>GET</td><td align="left">/students/edit</td><td align="left">id</td><td></td><td align="left">渲染编辑页面</td></tr><tr><td>POST</td><td align="left">/students/edit</td><td align="left"></td><td>id,name,age,gender,hobbies</td><td align="left">处理编辑请求</td></tr><tr><td>GET</td><td align="left">/students/delete</td><td align="left">id</td><td></td><td align="left">处理删除请求</td></tr></tbody></table><h4 id="提取路由模块"><a href="#提取路由模块" class="headerlink" title="提取路由模块"></a>提取路由模块</h4><p>router.js:</p><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * router.js路由模块</span><span class="hljs-comment"> * 职责：</span><span class="hljs-comment"> *      处理路由</span><span class="hljs-comment"> *      根据不同的请求方法+请求路径设置具体的请求函数</span><span class="hljs-comment"> * 模块职责要单一，我们划分模块的目的就是增强代码的可维护性，提升开发效率</span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<span class="hljs-comment">// Express专门提供了一种更好的方式</span><span class="hljs-comment">// 专门用来提供路由的</span><span class="hljs-keyword">var</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<span class="hljs-comment">// 1 创建一个路由容器</span><span class="hljs-keyword">var</span> router = express.<span class="hljs-title class_">Router</span>();<span class="hljs-comment">// 2 把路由都挂载到路由容器中</span>router.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/students&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) &#123;    <span class="hljs-comment">// res.send(&#x27;hello world&#x27;);</span>    <span class="hljs-comment">// readFile的第二个参数是可选的，传入utf8就是告诉他把读取到的文件直接按照utf8编码，直接转成我们认识的字符</span>    <span class="hljs-comment">// 除了这样来转换，也可以通过data.toString（）来转换</span>    fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./db.json&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">err, data</span>) &#123;        <span class="hljs-keyword">if</span> (err) &#123;            <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">status</span>(<span class="hljs-number">500</span>).<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Server error.&#x27;</span>)        &#125;        <span class="hljs-comment">// 读取到的文件数据是string类型的数据</span>        <span class="hljs-comment">// console.log(data);</span>        <span class="hljs-comment">// 从文件中读取到的数据一定是字符串，所以一定要手动转换成对象</span>        <span class="hljs-keyword">var</span> students = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(data).<span class="hljs-property">students</span>;        res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;index.html&#x27;</span>, &#123;            <span class="hljs-comment">// 读取文件数据</span>            <span class="hljs-attr">students</span>:students        &#125;)    &#125;)&#125;);router.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/students/new&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">req,res</span>)&#123;    res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;new.html&#x27;</span>)&#125;);router.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/students/edit&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">req,res</span>)&#123;    &#125;);router.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/students/edit&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">req,res</span>)&#123;    &#125;);router.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/students/delete&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">req,res</span>)&#123;    &#125;);<span class="hljs-comment">// 3 把router导出</span><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = router;</code></pre><p>app.js:</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> router = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./router&#x27;</span>);<span class="hljs-comment">// router(app);</span><span class="hljs-comment">// 把路由容器挂载到app服务中</span><span class="hljs-comment">// 挂载路由</span>app.<span class="hljs-title function_">use</span>(router);</code></pre><h4 id="设计操作数据的API文件模块"><a href="#设计操作数据的API文件模块" class="headerlink" title="设计操作数据的API文件模块"></a>设计操作数据的API文件模块</h4><p>es6中的find和findIndex：</p><p>find接受一个方法作为参数，方法内部返回一个条件</p><p>find会便利所有的元素，执行你给定的带有条件返回值的函数</p><p>符合该条件的元素会作为find方法的返回值</p><p>如果遍历结束还没有符合该条件的元素，则返回undefined<img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20200313103810731.png" srcset="/img/loading.gif" alt="image-20200313103810731"></p><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * student.js</span><span class="hljs-comment"> * 数据操作文件模块</span><span class="hljs-comment"> * 职责：操作文件中的数据，只处理数据，不关心业务</span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>); <span class="hljs-comment">/**</span><span class="hljs-comment">  * 获取所有学生列表</span><span class="hljs-comment">  * return []</span><span class="hljs-comment">  */</span><span class="hljs-built_in">exports</span>.<span class="hljs-property">find</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;    &#125; <span class="hljs-comment">/**</span><span class="hljs-comment">  * 获取添加保存学生</span><span class="hljs-comment">  */</span><span class="hljs-built_in">exports</span>.<span class="hljs-property">save</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;        &#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 更新学生</span><span class="hljs-comment"> */</span><span class="hljs-built_in">exports</span>.<span class="hljs-property">update</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;        &#125; <span class="hljs-comment">/**</span><span class="hljs-comment"> * 删除学生</span><span class="hljs-comment"> */</span><span class="hljs-built_in">exports</span>.<span class="hljs-property">delete</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;        &#125;</code></pre><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ul><li><p>处理模板</p></li><li><p>配置静态开放资源</p></li><li><p>配置模板引擎</p></li><li><p>简单的路由，/studens渲染静态页出来</p></li><li><p>路由设计</p></li><li><p>提取路由模块</p></li><li><p>由于接下来的一系列业务操作都需要处理文件数据，所以我们需要封装Student.js’</p></li><li><p>先写好student.js文件结构</p><ul><li>查询所有学生列别哦的API</li><li>findById</li><li>save</li><li>updateById</li><li>deleteById</li></ul></li><li><p>实现具体功能</p><ul><li>通过路由收到请求</li><li>接受请求中的参数（get，post）<ul><li>req.query</li><li>req.body</li></ul></li><li>调用数据操作API处理数据</li><li>根据操作结果给客户端发送请求</li></ul></li><li><p>业务功能顺序</p><ul><li>列表</li><li>添加</li><li>编辑</li><li>删除</li></ul></li></ul><h4 id="子模板和模板的继承（模板引擎高级语法）【include，extend，block】"><a href="#子模板和模板的继承（模板引擎高级语法）【include，extend，block】" class="headerlink" title="子模板和模板的继承（模板引擎高级语法）【include，extend，block】"></a>子模板和模板的继承（模板引擎高级语法）【include，extend，block】</h4><p>注意:</p><p>模板页：</p><pre><code class="hljs javascript">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;&lt;html lang=&quot;zh&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;&lt;title&gt;模板页&lt;/title&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;/node_modules/bootstrap/dist/css/bootstrap.css&quot;/&gt;&#123;&#123; block &#x27;head&#x27; &#125;&#125;&#123;&#123; /block &#125;&#125;&lt;/head&gt;&lt;body&gt;&lt;!-- 通过include导入公共部分 --&gt;&#123;&#123;include &#x27;./header.html&#x27;&#125;&#125;&lt;!-- 留一个位置 让别的内容去填充 --&gt;&#123;&#123; block  &#x27;content&#x27; &#125;&#125;&lt;h1&gt;默认内容&lt;/h1&gt;&#123;&#123; /block &#125;&#125;&lt;!-- 通过include导入公共部分 --&gt;&#123;&#123;include &#x27;./footer.html&#x27;&#125;&#125;&lt;!-- 公共样式 --&gt;&lt;script src=&quot;/node_modules/jquery/dist/jquery.js&quot; &gt;&lt;/script&gt;&lt;script src=&quot;/node_modules/bootstrap/dist/js/bootstrap.js&quot; &gt;&lt;/script&gt;&#123;&#123; block &#x27;script&#x27; &#125;&#125;&#123;&#123; /block &#125;&#125;&lt;/body&gt;&lt;/html&gt;</code></pre><p>模板的继承：</p><p>​    header页面：</p><pre><code class="hljs javascript">&lt;div id=<span class="hljs-string">&quot;&quot;</span>&gt;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>公共的头部<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>&lt;/div&gt;</code></pre><p>​    footer页面：</p><pre><code class="hljs javascript">&lt;div id=<span class="hljs-string">&quot;&quot;</span>&gt;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>公共的底部<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>&lt;/div&gt;</code></pre><p>模板页的使用：</p><pre><code class="hljs javascript">&lt;!-- 继承(<span class="hljs-attr">extend</span>:延伸，扩展)模板也layout.<span class="hljs-property">html</span> --&gt;&lt;!-- 把layout.<span class="hljs-property">html</span>页面的内容都拿进来作为index.<span class="hljs-property">html</span>页面的内容 --&gt;&#123;&#123;extend <span class="hljs-string">&#x27;./layout.html&#x27;</span>&#125;&#125;&lt;!-- 向模板页面填充新的数据 --&gt;&lt;!-- 填充后就会替换掉layout页面content中的数据 --&gt;&lt;!-- style样式方面的内容 --&gt;&#123;&#123; block <span class="hljs-string">&#x27;head&#x27;</span> &#125;&#125;&lt;style type=<span class="hljs-string">&quot;text/css&quot;</span>&gt;body&#123;background-<span class="hljs-attr">color</span>: skyblue;&#125;&lt;/style&gt;&#123;&#123; /block &#125;&#125;&#123;&#123; block <span class="hljs-string">&#x27;content&#x27;</span> &#125;&#125;&lt;div id=<span class="hljs-string">&quot;&quot;</span>&gt;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Index页面的内容<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>&lt;/div&gt;&#123;&#123; /block &#125;&#125;&lt;!-- js部分的内容 --&gt;&#123;&#123; block <span class="hljs-string">&#x27;script&#x27;</span> &#125;&#125;&lt;script type=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;&lt;/script&gt;&#123;&#123; /block &#125;&#125;</code></pre><p>最终的显示效果：</p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20200316134759517.png" srcset="/img/loading.gif" alt="image-20200316134759517"></p><h1 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h1><h2 id="关系型和非关系型数据库"><a href="#关系型和非关系型数据库" class="headerlink" title="关系型和非关系型数据库"></a>关系型和非关系型数据库</h2><h3 id="关系型数据库（表就是关系，或者说表与表之间存在关系）。"><a href="#关系型数据库（表就是关系，或者说表与表之间存在关系）。" class="headerlink" title="关系型数据库（表就是关系，或者说表与表之间存在关系）。"></a>关系型数据库（表就是关系，或者说表与表之间存在关系）。</h3><ul><li>所有的关系型数据库都需要通过<code>sql</code>语言来操作</li><li>所有的关系型数据库在操作之前都需要设计表结构</li><li>而且数据表还支持约束<ul><li>唯一的</li><li>主键</li><li>默认值</li><li>非空</li></ul></li></ul><h3 id="非关系型数据库"><a href="#非关系型数据库" class="headerlink" title="非关系型数据库"></a>非关系型数据库</h3><ul><li>非关系型数据库非常的灵活</li><li>有的关系型数据库就是key-value对儿</li><li>但MongDB是长得最像关系型数据库的非关系型数据库<ul><li>数据库 -》 数据库</li><li>数据表 -》 集合（数组）</li><li>表记录 -》文档对象</li></ul></li></ul><p>一个数据库中可以有多个数据库，一个数据库中可以有多个集合（数组），一个集合中可以有多个文档（表记录）</p><pre><code class="hljs javascript">&#123;    <span class="hljs-attr">qq</span>:&#123;       <span class="hljs-attr">user</span>:[           &#123;&#125;,&#123;&#125;,&#123;&#125;...       ]    &#125;&#125;</code></pre><ul><li>也就是说你可以任意的往里面存数据，没有结构性这么一说</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul><li><p>下载</p><ul><li>下载地址：<a href="https://www.mongodb.com/download-center/community">https://www.mongodb.com/download-center/community</a></li></ul></li><li><p>安装</p><pre><code class="hljs javascript">npm i mongoose</code></pre></li><li><p>配置环境变量</p></li><li><p>最后输入<code>mongod --version</code>测试是否安装成功</p></li></ul><h2 id="启动和关闭数据库"><a href="#启动和关闭数据库" class="headerlink" title="启动和关闭数据库"></a>启动和关闭数据库</h2><p>启动：</p><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">mongodb 默认使用执行mongod 命令所处盼复根目录下的/data/db作为自己的数据存储目录</span><span class="hljs-meta prompt_"># </span><span class="language-bash">所以在第一次执行该命令之前先自己手动新建一个 /data/db</span>mongod</code></pre><p>如果想要修改默认的数据存储目录，可以：</p><pre><code class="hljs javascript">mongod --dbpath = 数据存储目录路径</code></pre><p>停止：</p><pre><code class="hljs javascript">在开启服务的控制台，直接<span class="hljs-title class_">Ctrl</span>+C;或者直接关闭开启服务的控制台。</code></pre><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20200314101047100.png" srcset="/img/loading.gif" alt="image-20200314101047100"></p><h2 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h2><p>连接：</p><pre><code class="hljs javascript"># 该命令默认连接本机的 <span class="hljs-title class_">MongoDB</span> 服务mongo</code></pre><p>退出：</p><pre><code class="hljs javascript"># 在连接状态输入 exit 退出连接exit</code></pre><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20200314100821112.png" srcset="/img/loading.gif" alt="image-20200314100821112"></p><h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><ul><li><code>show dbs</code><ul><li>查看数据库列表(数据库中的所有数据库)</li></ul></li><li><code>db</code><ul><li>查看当前连接的数据库</li></ul></li><li><code>use 数据库名称</code><ul><li>切换到指定的数据库，（如果没有会新建）</li></ul></li><li><code>show collections</code><ul><li>查看当前目录下的所有数据表</li></ul></li><li><code>db.表名.find()</code><ul><li>查看表中的详细信息</li></ul></li></ul><h2 id="在Node中如何操作MongoDB数据库"><a href="#在Node中如何操作MongoDB数据库" class="headerlink" title="在Node中如何操作MongoDB数据库"></a>在Node中如何操作MongoDB数据库</h2><h3 id="使用官方的MongoDB包来操作"><a href="#使用官方的MongoDB包来操作" class="headerlink" title="使用官方的MongoDB包来操作"></a>使用官方的<code>MongoDB</code>包来操作</h3><blockquote><p>​    <a href="http://mongodb.github.io/node-mongodb-native/">http://mongodb.github.io/node-mongodb-native/</a></p></blockquote><h3 id="使用第三方包mongoose来操作MongoDB数据库"><a href="#使用第三方包mongoose来操作MongoDB数据库" class="headerlink" title="使用第三方包mongoose来操作MongoDB数据库"></a>使用第三方包<code>mongoose</code>来操作MongoDB数据库</h3><p>​    第三方包：<code>mongoose</code>基于MongoDB官方的<code>mongodb</code>包再一次做了封装，名字叫<code>mongoose</code>，是WordPress项目团队开发的。</p><blockquote><p>​    <a href="https://mongoosejs.com/">https://mongoosejs.com/</a></p></blockquote><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20200314105632745.png" srcset="/img/loading.gif" alt="image-20200314105632745"></p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20200314105717993.png" srcset="/img/loading.gif" alt="image-20200314105717993"></p><h2 id="学习指南（步骤）"><a href="#学习指南（步骤）" class="headerlink" title="学习指南（步骤）"></a>学习指南（步骤）</h2><p>官方学习文档：<a href="https://mongoosejs.com/docs/index.html">https://mongoosejs.com/docs/index.html</a></p><h3 id="设计Scheme-发布Model-创建表"><a href="#设计Scheme-发布Model-创建表" class="headerlink" title="设计Scheme 发布Model (创建表)"></a>设计Scheme 发布Model (创建表)</h3><pre><code class="hljs javascript"><span class="hljs-comment">// 1.引包</span><span class="hljs-comment">// 注意：按照后才能require使用</span><span class="hljs-keyword">var</span> mongoose = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;mongoose&#x27;</span>);<span class="hljs-comment">// 拿到schema图表</span><span class="hljs-keyword">var</span> <span class="hljs-title class_">Schema</span> = mongoose.<span class="hljs-property">Schema</span>;<span class="hljs-comment">// 2.连接数据库</span><span class="hljs-comment">// 指定连接数据库后不需要存在，当你插入第一条数据库后会自动创建数据库</span>mongoose.<span class="hljs-title function_">connect</span>(<span class="hljs-string">&#x27;mongodb://localhost/test&#x27;</span>);<span class="hljs-comment">// 3.设计集合结构（表结构）</span><span class="hljs-comment">// 用户表</span><span class="hljs-keyword">var</span> userSchema = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Schema</span>(&#123;<span class="hljs-attr">username</span>: &#123; <span class="hljs-comment">//姓名</span><span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>,<span class="hljs-attr">require</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">//添加约束，保证数据的完整性，让数据按规矩统一</span>&#125;,<span class="hljs-attr">password</span>: &#123;<span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>,<span class="hljs-attr">require</span>: <span class="hljs-literal">true</span>&#125;,<span class="hljs-attr">email</span>: &#123;<span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>&#125;&#125;);<span class="hljs-comment">// 4.将文档结构发布为模型</span><span class="hljs-comment">// mongoose.model方法就是用来将一个架构发布为 model</span><span class="hljs-comment">// 第一个参数：传入一个大写名词单数字符串用来表示你的数据库的名称</span><span class="hljs-comment">// mongoose 会自动将大写名词的字符串生成 小写复数 的集合名称</span><span class="hljs-comment">// 例如 这里会变成users集合名称</span><span class="hljs-comment">// 第二个参数：架构</span><span class="hljs-comment">// 返回值：模型构造函数</span><span class="hljs-keyword">var</span> <span class="hljs-title class_">User</span> = mongoose.<span class="hljs-title function_">model</span>(<span class="hljs-string">&#x27;User&#x27;</span>, userSchema);</code></pre><h3 id="添加数据（增）"><a href="#添加数据（增）" class="headerlink" title="添加数据（增）"></a>添加数据（增）</h3><pre><code class="hljs javascript"><span class="hljs-comment">// 5.通过模型构造函数对User中的数据进行操作</span><span class="hljs-keyword">var</span> user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(&#123;<span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;admin&#x27;</span>,<span class="hljs-attr">password</span>: <span class="hljs-string">&#x27;123456&#x27;</span>,<span class="hljs-attr">email</span>: <span class="hljs-string">&#x27;xiaochen@qq.com&#x27;</span>&#125;);user.<span class="hljs-title function_">save</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">err, ret</span>) &#123;<span class="hljs-keyword">if</span> (err) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;保存失败&#x27;</span>);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;保存成功&#x27;</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ret);&#125;&#125;);</code></pre><h3 id="删除（删）"><a href="#删除（删）" class="headerlink" title="删除（删）"></a>删除（删）</h3><p>根据条件删除所有：</p><pre><code class="hljs javascript"><span class="hljs-title class_">User</span>.<span class="hljs-title function_">remove</span>(&#123;<span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;xiaoxiao&#x27;</span>&#125;, <span class="hljs-keyword">function</span>(<span class="hljs-params">err, ret</span>) &#123;<span class="hljs-keyword">if</span> (err) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;删除失败&#x27;</span>);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;删除成功&#x27;</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ret);&#125;&#125;);</code></pre><p>根据条件删除一个：</p><pre><code class="hljs javascript"><span class="hljs-title class_">Model</span>.<span class="hljs-title function_">findOneAndRemove</span>(conditions,[options],[callback]);</code></pre><p>根据id删除一个：</p><pre><code class="hljs javascript"><span class="hljs-title class_">User</span>.<span class="hljs-title function_">findByIdAndRemove</span>(id,[options],[callback]);</code></pre><h3 id="更新（改）"><a href="#更新（改）" class="headerlink" title="更新（改）"></a>更新（改）</h3><p>更新所有：</p><pre><code class="hljs javascript"><span class="hljs-title class_">User</span>.<span class="hljs-title function_">remove</span>(conditions,doc,[options],[callback]);</code></pre><p>根据指定条件更新一个：</p><pre><code class="hljs javascript"><span class="hljs-title class_">User</span>.<span class="hljs-title class_">FindOneAndUpdate</span>([conditions],[update],[options],[callback]);</code></pre><p>根据id更新一个：</p><pre><code class="hljs javascript"><span class="hljs-comment">// 更新根据id来修改表数据</span><span class="hljs-title class_">User</span>.<span class="hljs-title function_">findByIdAndUpdate</span>(<span class="hljs-string">&#x27;5e6c5264fada77438c45dfcd&#x27;</span>, &#123;<span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;junjun&#x27;</span>&#125;, <span class="hljs-keyword">function</span>(<span class="hljs-params">err, ret</span>) &#123;<span class="hljs-keyword">if</span> (err) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;更新失败&#x27;</span>);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;更新成功&#x27;</span>);&#125;&#125;);</code></pre><h3 id="查询（查）"><a href="#查询（查）" class="headerlink" title="查询（查）"></a>查询（查）</h3><p>查询所有：</p><pre><code class="hljs javascript"><span class="hljs-comment">// 查询所有</span><span class="hljs-title class_">User</span>.<span class="hljs-title function_">find</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">err,ret</span>)&#123;<span class="hljs-keyword">if</span>(err)&#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;查询失败&#x27;</span>);&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ret);&#125;&#125;);</code></pre><p>条件查询所有：</p><pre><code class="hljs javascript"><span class="hljs-comment">// 根据条件查询</span><span class="hljs-title class_">User</span>.<span class="hljs-title function_">find</span>(&#123; <span class="hljs-attr">username</span>:<span class="hljs-string">&#x27;xiaoxiao&#x27;</span> &#125;,<span class="hljs-keyword">function</span>(<span class="hljs-params">err,ret</span>)&#123;<span class="hljs-keyword">if</span>(err)&#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;查询失败&#x27;</span>);&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ret);&#125;&#125;);</code></pre><p>条件查询单个：</p><pre><code class="hljs javascript"><span class="hljs-comment">// 按照条件查询单个，查询出来的数据是一个对象（&#123;&#125;）</span><span class="hljs-comment">// 没有条件查询使用findOne方法，查询的是表中的第一条数据</span><span class="hljs-title class_">User</span>.<span class="hljs-title function_">findOne</span>(&#123;<span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;xiaoxiao&#x27;</span>&#125;, <span class="hljs-keyword">function</span>(<span class="hljs-params">err, ret</span>) &#123;<span class="hljs-keyword">if</span> (err) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;查询失败&#x27;</span>);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ret);&#125;&#125;);</code></pre><h1 id="使用Node操作MySQL数据库"><a href="#使用Node操作MySQL数据库" class="headerlink" title="使用Node操作MySQL数据库"></a>使用Node操作MySQL数据库</h1><p>文档：<a href="https://www.npmjs.com/package/mysql">https://www.npmjs.com/package/mysql</a></p><p>安装：</p><pre><code class="hljs shell">npm install --save  mysql</code></pre><pre><code class="hljs javascript"><span class="hljs-comment">// 引入mysql包</span><span class="hljs-keyword">var</span> mysql      = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;mysql&#x27;</span>);<span class="hljs-comment">// 创建连接</span><span class="hljs-keyword">var</span> connection = mysql.<span class="hljs-title function_">createConnection</span>(&#123;  host     : <span class="hljs-string">&#x27;localhost&#x27;</span>,<span class="hljs-comment">//本机</span>  user     : <span class="hljs-string">&#x27;me&#x27;</span>,<span class="hljs-comment">//账号root</span>  password : <span class="hljs-string">&#x27;secret&#x27;</span>,<span class="hljs-comment">//密码12345</span>  database : <span class="hljs-string">&#x27;my_db&#x27;</span><span class="hljs-comment">//数据库名</span>&#125;); <span class="hljs-comment">// 连接数据库（打开冰箱门）</span>connection.<span class="hljs-title function_">connect</span>(); <span class="hljs-comment">//执行数据操作（把大象放到冰箱）</span>connection.<span class="hljs-title function_">query</span>(<span class="hljs-string">&#x27;SELECT * FROM `users` &#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">error, results, fields</span>) &#123;  <span class="hljs-keyword">if</span> (error) <span class="hljs-keyword">throw</span> error;<span class="hljs-comment">//抛出异常阻止代码往下执行</span>  <span class="hljs-comment">// 没有异常打印输出结果</span>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;The solution is: &#x27;</span>,results);&#125;);<span class="hljs-comment">//关闭连接（关闭冰箱门）</span>connection.<span class="hljs-title function_">end</span>();</code></pre><h1 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h1><h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>不成立的情况下：</p><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x,y</span>)&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);        <span class="hljs-keyword">var</span> ret = x + y;        <span class="hljs-keyword">return</span> ret;    &#125;,<span class="hljs-number">1000</span>);    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>);    <span class="hljs-comment">//到这里执行就结束了，不会i等到前面的定时器，所以直接返回了默认值 undefined</span>&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>));<span class="hljs-comment">// 结果是 1 3 undefined 4</span></code></pre><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20200313085008929.png" srcset="/img/loading.gif" alt="image-20200313085008929"></p><p>使用回调函数解决：</p><p>回调函数：通过一个函数，获取函数内部的操作。（根据输入得到输出结果）</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> ret;<span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x,y,callback</span>)&#123;    <span class="hljs-comment">// callback就是回调函数</span>    <span class="hljs-comment">// var x = 10;</span>    <span class="hljs-comment">// var y = 20;</span>    <span class="hljs-comment">// var callback = function(ret)&#123;console.log(ret);&#125;</span>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;        <span class="hljs-keyword">var</span> ret = x + y;        <span class="hljs-title function_">callback</span>(ret);    &#125;,<span class="hljs-number">1000</span>);    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>);&#125;<span class="hljs-title function_">add</span>(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">ret</span>)&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ret);&#125;);</code></pre><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20200313084746701.png" srcset="/img/loading.gif" alt="image-20200313084746701" style="zoom:100%;" /><p>注意：</p><p>​    凡是需要得到一个函数内部异步操作的结果（setTimeout,readFile,writeFile,ajax,readdir）</p><p>​    这种情况必须通过   回调函数 (异步API都会伴随着一个回调函数)</p><p>ajax:</p><p>基于原生XMLHttpRequest封装get方法：</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> oReq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<span class="hljs-comment">// 当请求加载成功要调用指定的函数</span>oReq.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(oReq.<span class="hljs-property">responseText</span>);&#125;oReq.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;请求路径&quot;</span>,<span class="hljs-literal">true</span>);oReq.<span class="hljs-title function_">send</span>();</code></pre><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">url,callback</span>)&#123;    <span class="hljs-keyword">var</span> oReq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();    <span class="hljs-comment">// 当请求加载成功要调用指定的函数</span>    oReq.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;        <span class="hljs-comment">//console.log(oReq.responseText);</span>        <span class="hljs-title function_">callback</span>(oReq.<span class="hljs-property">responseText</span>);    &#125;    oReq.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;GET&quot;</span>, url,<span class="hljs-literal">true</span>);    oReq.<span class="hljs-title function_">send</span>();&#125;<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;data.json&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);&#125;);</code></pre><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>callback  hell（回调地狱）:</p><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20200314143410972.png" srcset="/img/loading.gif" alt="image-20200314143410972"></p><p>文件的读取无法判断执行顺序（文件的执行顺序是依据文件的大小来决定的）(异步api无法保证文件的执行顺序)</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./data/a.text&#x27;</span>,<span class="hljs-string">&#x27;utf8&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">err,data</span>)&#123;<span class="hljs-keyword">if</span>(err)&#123;<span class="hljs-comment">// 1 读取失败直接打印输出读取失败</span><span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;读取失败&#x27;</span>);<span class="hljs-comment">// 2 抛出异常</span><span class="hljs-comment">// 阻止程序的执行</span><span class="hljs-comment">// 把错误信息打印到控制台</span><span class="hljs-keyword">throw</span> err;&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);&#125;);fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./data/b.text&#x27;</span>,<span class="hljs-string">&#x27;utf8&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">err,data</span>)&#123;<span class="hljs-keyword">if</span>(err)&#123;<span class="hljs-comment">// 1 读取失败直接打印输出读取失败</span><span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;读取失败&#x27;</span>);<span class="hljs-comment">// 2 抛出异常</span><span class="hljs-comment">// 阻止程序的执行</span><span class="hljs-comment">// 把错误信息打印到控制台</span><span class="hljs-keyword">throw</span> err;&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);&#125;);</code></pre><p>通过回调嵌套的方式来保证顺序：</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./data/a.text&#x27;</span>,<span class="hljs-string">&#x27;utf8&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">err,data</span>)&#123;<span class="hljs-keyword">if</span>(err)&#123;<span class="hljs-comment">// 1 读取失败直接打印输出读取失败</span><span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;读取失败&#x27;</span>);<span class="hljs-comment">// 2 抛出异常</span><span class="hljs-comment">// 阻止程序的执行</span><span class="hljs-comment">// 把错误信息打印到控制台</span><span class="hljs-keyword">throw</span> err;&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./data/b.text&#x27;</span>,<span class="hljs-string">&#x27;utf8&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">err,data</span>)&#123;<span class="hljs-keyword">if</span>(err)&#123;<span class="hljs-comment">// 1 读取失败直接打印输出读取失败</span><span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;读取失败&#x27;</span>);<span class="hljs-comment">// 2 抛出异常</span><span class="hljs-comment">// 阻止程序的执行</span><span class="hljs-comment">// 把错误信息打印到控制台</span><span class="hljs-keyword">throw</span> err;&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./data/a.text&#x27;</span>,<span class="hljs-string">&#x27;utf8&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">err,data</span>)&#123;<span class="hljs-keyword">if</span>(err)&#123;<span class="hljs-comment">// 1 读取失败直接打印输出读取失败</span><span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;读取失败&#x27;</span>);<span class="hljs-comment">// 2 抛出异常</span><span class="hljs-comment">// 阻止程序的执行</span><span class="hljs-comment">// 把错误信息打印到控制台</span><span class="hljs-keyword">throw</span> err;&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);&#125;);&#125;);&#125;);</code></pre><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20200314144807008.png" srcset="/img/loading.gif" alt="image-20200314144807008">为了解决以上编码方式带来的问题（回调地狱嵌套），所以在EcmaScript6新增了一个API:<code>Promise</code>。<img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20200314150050839.png" srcset="/img/loading.gif" alt="image-20200314150050839"></p><ul><li>Promise：承诺，保证</li><li>Promise本身不是异步的，但往往都是内部封装一个异步任务</li></ul><p>基本语法：</p><pre><code class="hljs javascript"><span class="hljs-comment">// 在EcmaScript 6中新增了一个API Promise</span><span class="hljs-comment">// Promise 是一个构造函数</span><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<span class="hljs-comment">// 1 创建Promise容器resolve:解决   reject：失败</span><span class="hljs-keyword">var</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) &#123;fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./a.text&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">err, data</span>) &#123;<span class="hljs-keyword">if</span> (err) &#123;<span class="hljs-comment">// console.log(err);</span><span class="hljs-comment">// 把容器的Pending状态变为rejected</span><span class="hljs-title function_">reject</span>(err);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// console.log(data);</span><span class="hljs-comment">// 把容器的Pending状态变为resolve</span><span class="hljs-title function_">resolve</span>(<span class="hljs-number">1234</span>);&#125;&#125;);&#125;);<span class="hljs-comment">// 当p1成功了，然后就（then）做指定的操作</span><span class="hljs-comment">// then方法接收的function就是容器中的resolve函数</span>p1.<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);&#125;, <span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;读取文件失败了&#x27;</span>, err);&#125;);</code></pre><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20200315100611620.png" srcset="/img/loading.gif" alt="image-20200315100611620"></p><p>链式循环：<img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20200315125559136.png" srcset="/img/loading.gif" alt="image-20200315125559136"></p><p>封装Promise的<code>readFile</code>：</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<span class="hljs-keyword">function</span> <span class="hljs-title function_">pReadFile</span>(<span class="hljs-params">filePath</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) &#123;fs.<span class="hljs-title function_">readFile</span>(filePath, <span class="hljs-string">&#x27;utf8&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">err, data</span>) &#123;<span class="hljs-keyword">if</span> (err) &#123;<span class="hljs-title function_">reject</span>(err);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-title function_">resolve</span>(data);&#125;&#125;);&#125;);&#125;<span class="hljs-title function_">pReadFile</span>(<span class="hljs-string">&#x27;./a.txt&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<span class="hljs-keyword">return</span> <span class="hljs-title function_">pReadFile</span>(<span class="hljs-string">&#x27;./b.txt&#x27;</span>);&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<span class="hljs-keyword">return</span> <span class="hljs-title function_">pReadFile</span>(<span class="hljs-string">&#x27;./a.txt&#x27;</span>);&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);&#125;)</code></pre><p>mongoose所有的API都支持Promise：</p><pre><code class="hljs javascript"><span class="hljs-comment">// 查询所有</span><span class="hljs-title class_">User</span>.<span class="hljs-title function_">find</span>().<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)&#123;        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data)    &#125;)</code></pre><p>注册：</p><pre><code class="hljs javascript"><span class="hljs-title class_">User</span>.<span class="hljs-title function_">findOne</span>(&#123;<span class="hljs-attr">username</span>:<span class="hljs-string">&#x27;admin&#x27;</span>&#125;,<span class="hljs-keyword">function</span>(<span class="hljs-params">user</span>)&#123;    <span class="hljs-keyword">if</span>(user)&#123;        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;用户已存在&#x27;</span>)    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(&#123;             <span class="hljs-attr">username</span>:<span class="hljs-string">&#x27;aaa&#x27;</span>,             <span class="hljs-attr">password</span>:<span class="hljs-string">&#x27;123&#x27;</span>,             <span class="hljs-attr">email</span>:<span class="hljs-string">&#x27;fffff&#x27;</span>        &#125;).<span class="hljs-title function_">save</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;注册成功&#x27;</span>);        &#125;)    &#125;&#125;)</code></pre><pre><code class="hljs javascript"><span class="hljs-title class_">User</span>.<span class="hljs-title function_">findOne</span>(&#123;    <span class="hljs-attr">username</span>:<span class="hljs-string">&#x27;admin&#x27;</span>&#125;)    .<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">user</span>)&#123;        <span class="hljs-keyword">if</span>(user)&#123;            <span class="hljs-comment">// 用户已经存在不能注册</span>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;用户已存在&#x27;</span>);        &#125;        <span class="hljs-keyword">else</span>&#123;            <span class="hljs-comment">// 用户不存在可以注册</span>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(&#123;                <span class="hljs-attr">username</span>:<span class="hljs-string">&#x27;aaa&#x27;</span>,                <span class="hljs-attr">password</span>:<span class="hljs-string">&#x27;123&#x27;</span>,                <span class="hljs-attr">email</span>:<span class="hljs-string">&#x27;fffff&#x27;</span>            &#125;).<span class="hljs-title function_">save</span>();        &#125;    &#125;)    .<span class="hljs-title function_">then</span>(<span class="hljs-title function_">funciton</span>(<span class="hljs-params">ret</span>)&#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;注册成功&#x27;</span>);    &#125;)</code></pre><h2 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h2><p>async函数</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="修改完代码自动重启"><a href="#修改完代码自动重启" class="headerlink" title="修改完代码自动重启"></a>修改完代码自动重启</h2><p>我们在这里可以使用一个第三方命名行工具：<code>nodemon</code>来帮助我们解决频繁修改代码重启服务器的问题。</p><p><code>nodemon</code>是一个基于Node.js开发的一个第三方命令行工具，我们使用的时候需要独立安装：</p><pre><code class="hljs javascript">#在任意目录执行该命令都可以#也就是说，所有需要 --<span class="hljs-variable language_">global</span>安装的包都可以在任意目录执行npm install --<span class="hljs-variable language_">global</span> nodemonnpm install -g nodemon#如果安装不成功的话，可以使用cnpm安装cnpm install -g nodemon</code></pre><p>安装完毕之后使用：</p><pre><code class="hljs javascript">node app.<span class="hljs-property">js</span>#使用nodemonnodemon app.<span class="hljs-property">js</span></code></pre><p>只要是通过<code>nodemon</code>启动的服务，则他会监视你的文件变化，当文件发生变化的时候，会自动帮你重启服务器。</p><h2 id="封装异步API"><a href="#封装异步API" class="headerlink" title="封装异步API"></a>封装异步API</h2><p>回调函数：获取异步操作的结果</p><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">callback</span>)&#123;    <span class="hljs-comment">// var callback = funtion(data)&#123; console.log(data); &#125;</span><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;        <span class="hljs-keyword">var</span> data = <span class="hljs-string">&#x27;hello&#x27;</span>;        <span class="hljs-title function_">callback</span>(data);    &#125;,<span class="hljs-number">1000</span>);&#125;<span class="hljs-comment">// 如果需要获取一个函数中异步操作的结果，则必须通过回调函数的方式来获取</span><span class="hljs-title function_">fn</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);&#125;)</code></pre><h2 id="数组的遍历方法，都是对函数作为一种参数"><a href="#数组的遍历方法，都是对函数作为一种参数" class="headerlink" title="数组的遍历方法，都是对函数作为一种参数"></a>数组的遍历方法，都是对函数作为一种参数</h2><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20200314094620191.png" srcset="/img/loading.gif" alt="image-20200314094620191"></p><h2 id="EcmaScript-6"><a href="#EcmaScript-6" class="headerlink" title="EcmaScript 6"></a>EcmaScript 6</h2><blockquote><p>参考文档：<a href="https://es6.ruanyifeng.com/">https://es6.ruanyifeng.com/</a></p></blockquote><h1 id="项目案例"><a href="#项目案例" class="headerlink" title="项目案例"></a>项目案例</h1><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><pre><code class="hljs javascript">.app.<span class="hljs-property">js</span>项目的入口文件controllersmodels存储使用mongoose设计的数据模型node_modules第三方包package.<span class="hljs-property">json</span>包描述文件package-lock.<span class="hljs-property">json</span>第三方包版本锁定文件（npm5之后才有）public公共静态资源routesviews存储视图目录</code></pre><h2 id="模板页"><a href="#模板页" class="headerlink" title="模板页"></a>模板页</h2><ul><li>子模板</li><li>模板继承</li></ul><h2 id="路由设计-1"><a href="#路由设计-1" class="headerlink" title="路由设计"></a>路由设计</h2><table><thead><tr><th>路由</th><th>方法</th><th>get参数</th><th>post参数</th><th>是否需要登录</th><th>备注</th></tr></thead><tbody><tr><td>/</td><td>get</td><td></td><td></td><td></td><td>渲染首页</td></tr><tr><td>/register(登录)</td><td>get</td><td></td><td></td><td></td><td>渲染注册页面</td></tr><tr><td>/register</td><td>post</td><td></td><td>email,nickname,password</td><td></td><td>处理注册请求</td></tr><tr><td>/login</td><td>get</td><td></td><td></td><td></td><td>渲染登陆界面</td></tr><tr><td>/login</td><td>post</td><td></td><td>email,password</td><td></td><td>处理登录请求</td></tr><tr><td>/loginout</td><td>get</td><td></td><td></td><td></td><td>处理退出请求</td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h2 id="模型设计"><a href="#模型设计" class="headerlink" title="模型设计"></a>模型设计</h2><h2 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h2><h2 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h2><ul><li>创建目录结构</li><li>整合静态也-模板页<ul><li>include</li><li>block</li><li>extend</li></ul></li><li>设计用户登陆，退出，注册的路由</li><li>用户注册<ul><li>先处理客户端页面的内容（表单控件的name，收集表单数据，发起请求）</li><li>服务端<ul><li>获取从客户端收到的数据</li><li>操作数据库<ul><li>如果有错，发送500告诉客户端服务器错了‘</li><li>其他的根据业务发送不同的响应数据</li></ul></li></ul></li></ul></li><li>登录</li><li>退出</li></ul><h1 id="Express中间件"><a href="#Express中间件" class="headerlink" title="Express中间件"></a>Express中间件</h1><h2 id="中间件的概念"><a href="#中间件的概念" class="headerlink" title="中间件的概念"></a>中间件的概念</h2><blockquote><p>参考文档：<a href="http://expressjs.com/en/guide/using-middleware.html">http://expressjs.com/en/guide/using-middleware.html</a></p></blockquote><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20200316202757617.png" srcset="/img/loading.gif" alt="image-20200316202757617"></p><p>中间件：把很复杂的事情分割成单个，然后依次有条理的执行。就是一个中间处理环节，有输入，有输出。</p><p>说的通俗易懂点儿，中间件就是一个（从请求到响应调用的方法）方法。</p><p>把数据从请求到响应分步骤来处理，每一个步骤都是一个中间处理环节。</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>);<span class="hljs-keyword">var</span> url = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;url&#x27;</span>);<span class="hljs-keyword">var</span> cookie = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./expressPtoject/cookie&#x27;</span>);<span class="hljs-keyword">var</span> query = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./expressPtoject/query&#x27;</span>);<span class="hljs-keyword">var</span> postBody = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./expressPtoject/post-body&#x27;</span>);<span class="hljs-keyword">var</span> server = http.<span class="hljs-title function_">createServer</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-comment">// 解析请求地址中的get参数</span><span class="hljs-comment">// var obj = url.parse(req.url,true);</span><span class="hljs-comment">// req.query = obj.query;</span><span class="hljs-title function_">query</span>(req,res);<span class="hljs-comment">//中间件</span><span class="hljs-comment">// 解析请求地址中的post参数</span>req.<span class="hljs-property">body</span> = &#123;<span class="hljs-attr">foo</span>:<span class="hljs-string">&#x27;bar&#x27;</span>&#125;&#125;);<span class="hljs-keyword">if</span>(req.<span class="hljs-property">url</span> === <span class="hljs-string">&#x27;xxx&#x27;</span>)&#123;<span class="hljs-comment">// 处理请求</span>...&#125;server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;3000 runing...&#x27;</span>);&#125;);</code></pre><p>同一个请求对象所经过的中间件都是同一个请求对象和响应对象。</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<span class="hljs-keyword">var</span> app = <span class="hljs-title function_">express</span>();app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/abc&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">req,res,next</span>)&#123;<span class="hljs-comment">// 同一个请求的req和res是一样的，</span><span class="hljs-comment">// 可以前面存储下面调用</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;/abc&#x27;</span>);<span class="hljs-comment">// req.foo = &#x27;bar&#x27;;</span>req.<span class="hljs-property">body</span> = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;xiaoxiao&#x27;</span>,<span class="hljs-attr">age</span>:<span class="hljs-number">18</span>&#125;<span class="hljs-title function_">next</span>();&#125;);app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/abc&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">req,res,next</span>)&#123;<span class="hljs-comment">// console.log(req.foo);</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(req.<span class="hljs-property">body</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;/abc&#x27;</span>);&#125;);app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;app is running at port 3000.&#x27;</span>);&#125;);</code></pre><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20200317110520098.png" srcset="/img/loading.gif" alt="image-20200317110520098"></p><h2 id="中间件的分类"><a href="#中间件的分类" class="headerlink" title="中间件的分类:"></a>中间件的分类:</h2><h3 id="应用程序级别的中间件"><a href="#应用程序级别的中间件" class="headerlink" title="应用程序级别的中间件"></a>应用程序级别的中间件</h3><p>万能匹配（不关心任何请求路径和请求方法的中间件）：</p><pre><code class="hljs javascript">app.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">req,res,next</span>)&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Time&#x27;</span>,<span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>());    <span class="hljs-title function_">next</span>();&#125;);</code></pre><p>关心请求路径和请求方法的中间件：</p><pre><code class="hljs javascript">app.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;/a&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">req,res,next</span>)&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Time&#x27;</span>,<span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>());    <span class="hljs-title function_">next</span>();&#125;);</code></pre><h3 id="路由级别的中间件"><a href="#路由级别的中间件" class="headerlink" title="路由级别的中间件"></a>路由级别的中间件</h3><p>严格匹配请求路径和请求方法的中间件</p><p>get:</p><pre><code class="hljs javascript">app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">req,res</span>)&#123;res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;get&#x27;</span>);&#125;);</code></pre><p>post：</p><pre><code class="hljs javascript">app.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/a&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">req,res</span>)&#123;res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;post&#x27;</span>);&#125;);</code></pre><p>put:</p><pre><code class="hljs javascript">app.<span class="hljs-title function_">put</span>(<span class="hljs-string">&#x27;/user&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">req,res</span>)&#123;res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;put&#x27;</span>);&#125;);</code></pre><p>delete:</p><pre><code class="hljs javascript">app.<span class="hljs-title function_">delete</span>(<span class="hljs-string">&#x27;/delete&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">req,res</span>)&#123;res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;delete&#x27;</span>);&#125;);</code></pre><h3 id="总"><a href="#总" class="headerlink" title="总"></a>总</h3><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<span class="hljs-keyword">var</span> app = <span class="hljs-title function_">express</span>();<span class="hljs-comment">// 中间件：处理请求，本质就是个函数</span><span class="hljs-comment">// 在express中，对中间件有几种分类</span><span class="hljs-comment">// 1 不关心任何请求路径和请求方法的中间件</span><span class="hljs-comment">// 也就是说任何请求都会进入这个中间件</span><span class="hljs-comment">// 中间件本身是一个方法，该方法接收三个参数</span><span class="hljs-comment">// Request 请求对象</span><span class="hljs-comment">// Response 响应对象</span><span class="hljs-comment">// next 下一个中间件</span><span class="hljs-comment">// // 全局匹配中间件</span><span class="hljs-comment">// app.use(function(req, res, next) &#123;</span><span class="hljs-comment">// console.log(&#x27;1&#x27;);</span><span class="hljs-comment">// // 当一个请求进入中间件后</span><span class="hljs-comment">// // 如果需要请求另外一个方法则需要使用next（）方法</span><span class="hljs-comment">// next();</span><span class="hljs-comment">// // next是一个方法，用来调用下一个中间件</span><span class="hljs-comment">//  // 注意：next（）方法调用下一个方法的时候，也会匹配（不是调用紧挨着的哪一个）</span><span class="hljs-comment">// &#125;);</span><span class="hljs-comment">// app.use(function(req, res, next) &#123;</span><span class="hljs-comment">// console.log(&#x27;2&#x27;);</span><span class="hljs-comment">// &#125;);</span><span class="hljs-comment">// // 2 关心请求路径的中间件</span><span class="hljs-comment">// // 以/xxx开头的中间件</span><span class="hljs-comment">// app.use(&#x27;/a&#x27;,function(req, res, next) &#123;</span><span class="hljs-comment">// console.log(req.url);</span><span class="hljs-comment">// &#125;);</span><span class="hljs-comment">// 3 严格匹配请求方法和请求路径的中间件</span>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;/&#x27;</span>);&#125;);app.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/a&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;/a&#x27;</span>);&#125;);app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;app is running at port 3000.&#x27;</span>);&#125;);</code></pre><h2 id="错误处理中间件"><a href="#错误处理中间件" class="headerlink" title="错误处理中间件"></a>错误处理中间件</h2><pre><code class="hljs javascript">app.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">err,req,res,next</span>)&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(err,stack);    res.<span class="hljs-title function_">status</span>(<span class="hljs-number">500</span>).<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Something broke&#x27;</span>);&#125;);</code></pre><p>配置使用404中间件：</p><pre><code class="hljs javascript">app.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">req,res</span>)&#123;    res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;404.html&#x27;</span>);&#125;);</code></pre><p>配置全局错误处理中间件:</p><pre><code class="hljs javascript">app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/a&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">req, res, next</span>) &#123;fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;.a/bc&#x27;</span>, <span class="hljs-title function_">funtion</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">if</span> (err) &#123;        <span class="hljs-comment">// 当调用next()传参后，则直接进入到全局错误处理中间件方法中</span>        <span class="hljs-comment">// 当发生全局错误的时候，我们可以调用next传递错误对象</span>        <span class="hljs-comment">// 然后被全局错误处理中间件匹配到并进行处理</span><span class="hljs-title function_">next</span>(err);&#125;&#125;)&#125;);<span class="hljs-comment">//全局错误处理中间件</span>app.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">err,req,res,next</span>)&#123;    res.<span class="hljs-title function_">status</span>(<span class="hljs-number">500</span>).<span class="hljs-title function_">json</span>(&#123;        <span class="hljs-attr">err_code</span>:<span class="hljs-number">500</span>,        <span class="hljs-attr">message</span>:err.<span class="hljs-property">message</span>    &#125;);&#125;);</code></pre><h2 id="内置中间件"><a href="#内置中间件" class="headerlink" title="内置中间件"></a>内置中间件</h2><ul><li>express.static(提供静态文件)<ul><li><a href="http://expressjs.com/en/starter/static-files.html#serving-static-files-in-express">http://expressjs.com/en/starter/static-files.html#serving-static-files-in-express</a></li></ul></li></ul><h2 id="第三方中间件"><a href="#第三方中间件" class="headerlink" title="第三方中间件"></a>第三方中间件</h2><blockquote><p>参考文档：<a href="http://expressjs.com/en/resources/middleware.html">http://expressjs.com/en/resources/middleware.html</a></p></blockquote><ul><li>body-parser</li><li>compression</li><li>cookie-parser</li><li>mogran</li><li>response-time</li><li>server-static</li><li>session</li></ul>]]></content>
    
    
    <categories>
      
      <category>Nodejs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mongoose</tag>
      
      <tag>promise</tag>
      
      <tag>es6</tag>
      
      <tag>node</tag>
      
      <tag>express</tag>
      
      <tag>body-parse</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回调地狱（callback hell） 和 promise</title>
    <link href="/2020/08/12/10.promise/"/>
    <url>/2020/08/12/10.promise/</url>
    
    <content type="html"><![CDATA[<h2 id="1-callback-hell-回调地狱"><a href="#1-callback-hell-回调地狱" class="headerlink" title="1. callback hell  回调地狱"></a>1. callback hell  回调地狱</h2><h3 id="1-1-没有顺序的读取-a-b-c-三个文件"><a href="#1-1-没有顺序的读取-a-b-c-三个文件" class="headerlink" title="1.1 没有顺序的读取 a  b  c 三个文件"></a>1.1 没有顺序的读取 a  b  c 三个文件</h3><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./a.txt&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">err, data</span>) &#123;    <span class="hljs-keyword">if</span> (err) &#123;        <span class="hljs-comment">// return console.log(&#x27;读取错误&#x27;);</span>        <span class="hljs-comment">// 抛出异常</span>        <span class="hljs-comment">// 1.阻止程序的执行  2. 把错误消息打印到控制台  </span>        <span class="hljs-keyword">throw</span> err    &#125;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);&#125;)fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./b.txt&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">err, data</span>) &#123;    <span class="hljs-keyword">if</span> (err) &#123;        <span class="hljs-comment">// return console.log(&#x27;读取错误&#x27;);</span>        <span class="hljs-comment">// 抛出异常</span>        <span class="hljs-comment">// 1.阻止程序的执行  2. 把错误消息打印到控制台  </span>        <span class="hljs-keyword">throw</span> err    &#125;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);&#125;)fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./c.txt&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">err, data</span>) &#123;    <span class="hljs-keyword">if</span> (err) &#123;        <span class="hljs-comment">// return console.log(&#x27;读取错误&#x27;);</span>        <span class="hljs-comment">// 抛出异常</span>        <span class="hljs-comment">// 1.阻止程序的执行  2. 把错误消息打印到控制台  </span>        <span class="hljs-keyword">throw</span> err    &#125;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);&#125;)</code></pre><pre><code class="hljs shell">PS F:\nodejs\Node_test&gt; node .\13.回调地狱.jshello aaaahello bbbbhello ccccPS F:\nodejs\Node_test&gt; node .\13.回调地狱.jshello aaaahello cccchello bbbbPS F:\nodejs\Node_test&gt; node .\13.回调地狱.jshello aaaahello cccchello bbbb</code></pre><h3 id="1-2-想要有顺序的分别-读取-a-b-c-三个文件"><a href="#1-2-想要有顺序的分别-读取-a-b-c-三个文件" class="headerlink" title="1.2 想要有顺序的分别 读取 a b c 三个文件"></a>1.2 想要有顺序的分别 读取 a b c 三个文件</h3><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./a.txt&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">err, data</span>) &#123;    <span class="hljs-keyword">if</span> (err) &#123;        <span class="hljs-comment">// return console.log(&#x27;读取错误&#x27;);</span>        <span class="hljs-comment">// 抛出异常</span>        <span class="hljs-comment">// 1.阻止程序的执行  2. 把错误消息打印到控制台  </span>        <span class="hljs-keyword">throw</span> err    &#125;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);    fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./b.txt&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">err, data</span>) &#123;        <span class="hljs-keyword">if</span> (err) &#123;            <span class="hljs-comment">// return console.log(&#x27;读取错误&#x27;);</span>            <span class="hljs-comment">// 抛出异常</span>            <span class="hljs-comment">// 1.阻止程序的执行  2. 把错误消息打印到控制台  </span>            <span class="hljs-keyword">throw</span> err        &#125;        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);        fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./c.txt&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">err, data</span>) &#123;            <span class="hljs-keyword">if</span> (err) &#123;                <span class="hljs-comment">// return console.log(&#x27;读取错误&#x27;);</span>                <span class="hljs-comment">// 抛出异常</span>                <span class="hljs-comment">// 1.阻止程序的执行  2. 把错误消息打印到控制台  </span>                <span class="hljs-keyword">throw</span> err            &#125;            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);        &#125;)    &#125;)&#125;)</code></pre><pre><code class="hljs shell">PS F:\nodejs\Node_test&gt; node .\13.回调地狱.jshello aaaahello bbbbhello ccccPS F:\nodejs\Node_test&gt; node .\13.回调地狱.jshello aaaahello bbbbhello ccccPS F:\nodejs\Node_test&gt; node .\13.回调地狱.jshello aaaahello bbbbhello cccc</code></pre><blockquote><p> 想要有顺序的读取异步操作中的文件 就需要回调函数嵌套，但这样的代码 看起来很乱且维护性低 </p></blockquote><blockquote><p>为了解决这样的问题，（回调地狱嵌套） 这时我们就需要用ES6中的API  <code>promise </code></p></blockquote><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><blockquote><p>参考文档 <a href="https://es6.ruanyifeng.com/#docs/promise">promise 阮一峰</a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise">promise MDN</a></p></blockquote><h3 id="为什么需要用promise？"><a href="#为什么需要用promise？" class="headerlink" title="为什么需要用promise？"></a>为什么需要用promise？</h3><p>我个人理解有三点：</p><ol><li>在使用ajax调用成功和失败方法时，命名不够规范。</li><li>容易出现回调地狱</li><li>很难进行错误处理</li><li>解决异步</li></ol><h3 id="promise是什么？"><a href="#promise是什么？" class="headerlink" title="promise是什么？"></a>promise是什么？</h3><p>打印出来看看：<br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4bb8ec4f75084af59036203bd363d7e9~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="promise是什么"></p><p>很显然，promise是一个构造函数，它除了自身有 <strong>resolve 、 reject、 all 、race</strong>方法等，原型上还有<strong>then 、catch</strong> 等我们最常用到的方法。 所以我们 new promise 里面是肯定有 then 、 catch 方法的。</p><h3 id="如何创建一个promise"><a href="#如何创建一个promise" class="headerlink" title="如何创建一个promise"></a>如何创建一个promise</h3><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">runAsync</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;    <span class="hljs-comment">// 异步操作</span>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;执行成功&#x27;</span>);      <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;数据&#x27;</span>)    &#125;, <span class="hljs-number">1000</span>)  &#125;)  <span class="hljs-keyword">return</span> p&#125;<span class="hljs-title function_">runAsync</span>()</code></pre><p>其中Promise构造函数接受一个参数，就是<strong>函数</strong>。并且会传入俩个参数：<strong>resolve，reject</strong> 。 分别表示异步操作<strong>执行成功后的回调函数和执行失败后的回调函数</strong>。</p><p>我们将包装一个函数，把promise放在里面并返回它， <strong>这样做的意义在于我们可以使用promise原型上的then,catch方法</strong></p><pre><code class="hljs js"><span class="hljs-title function_">runAsync</span>().<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);    <span class="hljs-comment">//后面可以用传过来的数据做些其他操作</span>&#125;);</code></pre><p>效果展示<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/424e9af706c841ee8533e78e42743644~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="效果展示"></p><p>以上就是Promise的作用了，简单的说，<strong>就是能把原来的回调写法分离出来，在异步操作执行完后，用链式操作的形式执行回调函数。</strong></p><h3 id="promise-all-用法"><a href="#promise-all-用法" class="headerlink" title="promise.all 用法"></a>promise.all 用法</h3><p>all方法提供了并行执行异步操作的能力，并且在所有异步操作执行完毕后才执行回调。</p><p>请看下面例子:</p><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">runAsync1</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;    <span class="hljs-comment">// 异步操作</span>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;执行成功&#x27;</span>);      <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;数据1&#x27;</span>)    &#125;, <span class="hljs-number">1000</span>)  &#125;)  <span class="hljs-keyword">return</span> p&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">runAsync2</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;    <span class="hljs-comment">// 异步操作</span>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;执行成功&#x27;</span>);      <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;数据2&#x27;</span>)    &#125;, <span class="hljs-number">1500</span>)  &#125;)  <span class="hljs-keyword">return</span> p&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">runAsync3</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;    <span class="hljs-comment">// 异步操作</span>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;执行成功&#x27;</span>);      <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;数据3&#x27;</span>)    &#125;, <span class="hljs-number">2000</span>)  &#125;)  <span class="hljs-keyword">return</span> p&#125;<span class="hljs-title class_">Promise</span>  .<span class="hljs-title function_">all</span>([    <span class="hljs-title function_">runAsync1</span>(),    <span class="hljs-title function_">runAsync2</span>(),    <span class="hljs-title function_">runAsync3</span>()  ])  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result))</code></pre><p><strong>我们用Promise.all 来执行， 并且接受三个数组，里面的值都返回的是Promise对象，然后这三个异步操作并行执行，等它们都执行完毕后，数据才会在then方法里面。即all方法会把所有异步操作的结果放在一个属猪中再传给then。</strong></p><p> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c4cefd2b822e4df787213b60947d1d46~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt="call方法"></p><h3 id="Promise-race-用法"><a href="#Promise-race-用法" class="headerlink" title="Promise.race 用法"></a>Promise.race 用法</h3><p>用法和Promise.all 一样，只不过all方法是<strong>谁跑得慢，就以谁为准执行回调</strong>， 而race方法就是<strong>谁跑得快，就以谁为准执行回调</strong></p><p>将上面展示的代码 的all方法换成race看看是什么效果</p><pre><code class="hljs js"><span class="hljs-title class_">Promise</span>  .<span class="hljs-title function_">race</span>([    <span class="hljs-title function_">runAsync1</span>(),    <span class="hljs-title function_">runAsync2</span>(),    <span class="hljs-title function_">runAsync3</span>()  ])  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result))</code></pre><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9db2c77f359241849d2de2e8d84a7c15~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" alt=" Promise.race "></p><p>瞧！他会去优先输出最快（1s）的runAsync1函数的数据，</p><p><strong>原因是因为异步处理问题，runAsync1函数的数据并不会等待上面的Promise执行完在开始执行，所以由于时间延迟，优先输出‘数据1’。</strong></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>promise</tag>
      
      <tag>es6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mongodb数据库的基本使用</title>
    <link href="/2020/08/12/09.Mongodb%20%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <url>/2020/08/12/09.Mongodb%20%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h2 id="Mongodb数据库的基本概念"><a href="#Mongodb数据库的基本概念" class="headerlink" title="Mongodb数据库的基本概念"></a>Mongodb数据库的基本概念</h2><ul><li>可以有多个数据库</li><li>一个数据库中可以有多个集合（表）</li><li>一个集合中可以有多个文档（表记录）</li><li>文档结构灵活，没有任何限制</li><li>Mongodb非常灵活，不需要像  MySQL 一样先创建数据库、表、设计表结构<ul><li>这里只需要：当你需要插入数据的时候，只需要指定往哪个数据库的哪个集合操作就可以了</li><li>一切都有Mongodb 来帮你自动完成建库建表这些事儿<pre><code class="hljs JavaScript">&#123;    <span class="hljs-attr">qq</span>:&#123;  <span class="hljs-comment">// 集合  </span>        <span class="hljs-attr">user</span>:[         &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;张三&#x27;</span>&#125;,  <span class="hljs-comment">// 文档</span>        &#123;&#125;,        &#123;&#125;,        &#123;&#125;,        &#123;&#125;        ]          <span class="hljs-attr">products</span>:[        &#123;&#125;,        &#123;&#125;        ]    &#125;,    <span class="hljs-attr">taobao</span>:&#123;            &#125;,    ....&#125;</code></pre><h2 id="1-启动和关闭数据库"><a href="#1-启动和关闭数据库" class="headerlink" title="1.启动和关闭数据库"></a>1.启动和关闭数据库</h2><h3 id="1-1启动"><a href="#1-1启动" class="headerlink" title="1.1启动"></a>1.1启动</h3><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"> mongodb 默认使用执行 mongod 命令 所处盘符根目录下的 /data/db 作为自己的数据存储目录</span><span class="hljs-meta prompt_"># </span><span class="language-bash">所以在第一次执行该命令之前先自己手动创建一个 /data/db</span>mongod</code></pre></li></ul></li></ul><h3 id="如果想要修改默认的数据存储目录，可以："><a href="#如果想要修改默认的数据存储目录，可以：" class="headerlink" title="如果想要修改默认的数据存储目录，可以："></a>如果想要修改默认的数据存储目录，可以：</h3><pre><code class="hljs shell">mongod --dbpath = 数据存储目录路径</code></pre><h3 id="1-2-关闭"><a href="#1-2-关闭" class="headerlink" title="1.2 关闭"></a>1.2 关闭</h3><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">在开始服务的控制台（cmd） 直接 Ctrl+c 即可停止退出，</span><span class="hljs-meta prompt_"># </span><span class="language-bash">或者直接关闭 开启服务的控制台</span></code></pre><h2 id="2-连接和退出数据库"><a href="#2-连接和退出数据库" class="headerlink" title="2.连接和退出数据库"></a>2.连接和退出数据库</h2><h3 id="2-1-连接"><a href="#2-1-连接" class="headerlink" title="2.1 连接"></a>2.1 连接</h3><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">在 数据库 bin 的目录下 开启cmd</span><span class="hljs-meta prompt_"># </span><span class="language-bash">该命令默认连接本机的 mongodb 服务</span>mongo</code></pre><h3 id="2-2-退出"><a href="#2-2-退出" class="headerlink" title="2.2 退出"></a>2.2 退出</h3><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">在连接状态输入 <span class="hljs-built_in">exit</span> 退出连接</span>exit</code></pre><h3 id="2-3基本命令"><a href="#2-3基本命令" class="headerlink" title="2.3基本命令"></a>2.3基本命令</h3><ul><li><code>show dbs</code><ul><li>查看显示所有数据库</li></ul></li><li><code>show collections</code><ul><li>显示当前所有集合</li></ul></li><li><code>db</code><ul><li>查看当前操作的数据库</li></ul></li><li><code>use 数据库名称</code><ul><li>切换到指定的数据库（如果没有会新建）</li></ul></li><li>插入数据</li></ul><h2 id="3-在Nodejs中如何操作使用Mongodb数据"><a href="#3-在Nodejs中如何操作使用Mongodb数据" class="headerlink" title="3.在Nodejs中如何操作使用Mongodb数据"></a>3.在Nodejs中如何操作使用Mongodb数据</h2><h3 id="3-1-使用官方的-mongodb-包来操作"><a href="#3-1-使用官方的-mongodb-包来操作" class="headerlink" title="3.1 使用官方的 mongodb 包来操作"></a>3.1 使用官方的 <code>mongodb</code> 包来操作</h3><ul><li><p>不推荐使用， 太原生了</p></li><li><p><a href="https://www.npmjs.com/package/mongodb">npm mongodb包 下载及指导地址</a></p><h3 id="3-2-使用第三方包-mongoose-来操作-Mongodb-数据库"><a href="#3-2-使用第三方包-mongoose-来操作-Mongodb-数据库" class="headerlink" title="3.2 使用第三方包 mongoose 来操作  Mongodb 数据库"></a>3.2 使用第三方包 <code>mongoose</code> 来操作  Mongodb 数据库</h3><pre><code class="hljs sell">npm i mongoose</code></pre></li><li><p>第三方包 : <code>mongoose</code> 基于 MongoDB 官方的 <code>mongodb</code> 包再一次做了封装</p></li><li><p><a href="https://mongoosejs.com/"><code>mongoose 网址</code></a></p><h3 id="3-3-简单体验-hello-world"><a href="#3-3-简单体验-hello-world" class="headerlink" title="3.3 简单体验  hello world"></a>3.3 简单体验  hello world</h3><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> mongoose = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;mongoose&#x27;</span>);<span class="hljs-comment">// 连接 MongoDB数据库     </span><span class="hljs-comment">//  mongodb://localhost:27017/test  以下创建的数据库数据都在 这个 test里</span>mongoose.<span class="hljs-title function_">connect</span>(<span class="hljs-string">&#x27;mongodb://localhost:27017/test&#x27;</span>, &#123;    <span class="hljs-attr">useNewUrlParser</span>: <span class="hljs-literal">true</span>,    <span class="hljs-attr">useUnifiedTopology</span>: <span class="hljs-literal">true</span>&#125;);<span class="hljs-comment">// 创建了一个模型  就是在设计数据库</span><span class="hljs-comment">// MongoDB 是动态的，非常灵活。只需要在代码中设计你的数据库就可以了</span><span class="hljs-comment">// mongoose 这个包就可以让你的设计编写过程变得非常简单</span><span class="hljs-keyword">const</span> <span class="hljs-title class_">Cat</span> = mongoose.<span class="hljs-title function_">model</span>(<span class="hljs-string">&#x27;Cat&#x27;</span>, &#123;    <span class="hljs-attr">name</span>: <span class="hljs-title class_">String</span>&#125;);<span class="hljs-comment">// 实例化了一个 Cat</span><span class="hljs-keyword">const</span> kitty = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>(&#123;    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Zildjian&#x27;</span>&#125;);<span class="hljs-comment">// 持久化保存了  kitty 实例</span>kitty.<span class="hljs-title function_">save</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;meow&#x27;</span>));</code></pre><h3 id="3-4-创建数据库-并创建架构"><a href="#3-4-创建数据库-并创建架构" class="headerlink" title="3.4 创建数据库 并创建架构"></a>3.4 创建数据库 并创建架构</h3><pre><code class="hljs JavaScript"> <span class="hljs-keyword">var</span> mongoose = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;mongoose&#x27;</span>);<span class="hljs-comment">// 1.连接数据库</span>mongoose.<span class="hljs-title function_">connect</span>(<span class="hljs-string">&#x27;mongodb://localhost:27017/test&#x27;</span>, &#123;    <span class="hljs-attr">useNewUrlParser</span>: <span class="hljs-literal">true</span>,    <span class="hljs-attr">useUnifiedTopology</span>: <span class="hljs-literal">true</span>&#125;);<span class="hljs-comment">//  架构</span><span class="hljs-keyword">var</span> <span class="hljs-title class_">Schema</span> = mongoose.<span class="hljs-property">Schema</span>;<span class="hljs-comment">//  2.设计文档结构/架构（表结构）</span><span class="hljs-comment">// 字段名称就是表结构中的属性名称</span><span class="hljs-comment">// 约束的目的是为了保证数据的完整性， 不要有脏数据</span><span class="hljs-keyword">var</span> userSchema = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Schema</span>(&#123;    <span class="hljs-attr">userName</span>: &#123;        <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>,        <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">// 这个意思是  该属性不能为空 必须有</span>    &#125;,    <span class="hljs-attr">password</span>: &#123;        <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>,        <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>    &#125;,    <span class="hljs-attr">email</span>: &#123;        <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>    &#125;&#125;);<span class="hljs-comment">// 3.将文档结构发布为 模型 model</span><span class="hljs-comment">//  mongoose.model 方法就是用来将一个 架构Schema 发布为一个 model</span><span class="hljs-comment">//  第一参数： 传入一个大写的名词单数 字符串  用来表示你的数据库名称</span><span class="hljs-comment">//              mongoose 会自动将大写名字的字符串生成 小写复数 的集合名称</span><span class="hljs-comment">//             例如 这里的 User  会生成一个 users 集合名称</span><span class="hljs-comment">// 返回值: 模型架构函数</span><span class="hljs-keyword">const</span> <span class="hljs-title class_">User</span> = mongoose.<span class="hljs-title function_">model</span>(<span class="hljs-string">&#x27;User&#x27;</span>, userSchema)<span class="hljs-comment">// 4. 当我们有了模型构造函数之后 ， 就可以用这个构造函数 对 users 集合中的数据进行 增删改查（CURD）</span></code></pre><h4 id="新增数据"><a href="#新增数据" class="headerlink" title="新增数据"></a>新增数据</h4><pre><code class="hljs JavaScript"> <span class="hljs-comment">//  新增数据</span><span class="hljs-keyword">let</span> admin = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(&#123;    <span class="hljs-attr">userName</span>: <span class="hljs-string">&#x27;admin&#x27;</span>,    <span class="hljs-attr">password</span>: <span class="hljs-string">&#x27;123456&#x27;</span>,    <span class="hljs-attr">email</span>: <span class="hljs-string">&#x27;admin@qq.com&#x27;</span>&#125;)admin.<span class="hljs-title function_">save</span>(<span class="hljs-function">(<span class="hljs-params">err, ret</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (err) &#123;        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;存储失败&#x27;</span>);    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;存储成功&#x27;</span>);        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ret);   <span class="hljs-comment">// ret 就是 存储的数据</span>    &#125;&#125;)<span class="hljs-comment">// 下面的就是 ret</span><span class="hljs-comment">// &#123;</span><span class="hljs-comment">//     _id: 5f32a2c76be62230a099314b,</span><span class="hljs-comment">//     userName: &#x27;admin&#x27;,</span><span class="hljs-comment">//     password: &#x27;123456&#x27;,</span><span class="hljs-comment">//     email: &#x27;admin@qq.com&#x27;,</span><span class="hljs-comment">//     __v: 0</span><span class="hljs-comment">//   &#125;</span></code></pre><h4 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h4><h5 id="查询所有数据-find"><a href="#查询所有数据-find" class="headerlink" title="查询所有数据  find"></a>查询所有数据  find</h5><pre><code class="hljs JavaScript"> <span class="hljs-title class_">User</span>.<span class="hljs-title function_">find</span>(<span class="hljs-function">(<span class="hljs-params">err, ret</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (err) &#123;        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;查询失败&#x27;</span>);    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ret);    &#125;&#125;)</code></pre><h5 id="按条件查询所有符合的数据-find"><a href="#按条件查询所有符合的数据-find" class="headerlink" title="按条件查询所有符合的数据  find"></a>按条件查询所有符合的数据  find</h5><pre><code class="hljs JavaScript"><span class="hljs-title class_">User</span>.<span class="hljs-title function_">find</span>(&#123;    <span class="hljs-attr">userName</span>: <span class="hljs-string">&#x27;朱元璋&#x27;</span>&#125;, <span class="hljs-function">(<span class="hljs-params">err, ret</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (err) &#123;        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;查询失败&#x27;</span>);    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ret);    &#125;&#125;)</code></pre><h5 id="按条件查询单个的数据-（如果有相同的返回第一个）-findOne"><a href="#按条件查询单个的数据-（如果有相同的返回第一个）-findOne" class="headerlink" title="按条件查询单个的数据 （如果有相同的返回第一个） findOne"></a>按条件查询单个的数据 （如果有相同的返回第一个） findOne</h5><pre><code class="hljs JavaScript"> <span class="hljs-title class_">User</span>.<span class="hljs-title function_">findOne</span>(&#123;    <span class="hljs-attr">userName</span>: <span class="hljs-string">&#x27;朱元璋&#x27;</span>&#125;, <span class="hljs-function">(<span class="hljs-params">err, ret</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (err) &#123;        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;查询失败&#x27;</span>);    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ret);    &#125;&#125;)</code></pre><h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><pre><code class="hljs JavaScript"> <span class="hljs-comment">// 3.删除数据</span><span class="hljs-title class_">User</span>.<span class="hljs-title function_">remove</span>(&#123;    <span class="hljs-attr">userName</span>: <span class="hljs-string">&#x27;朱元璋&#x27;</span>&#125;, <span class="hljs-function">(<span class="hljs-params">err, ret</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (err) &#123;        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;删除失败&#x27;</span>);    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ret);    &#125;&#125;)</code></pre><h4 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h4><pre><code class="hljs JavaScript"><span class="hljs-comment">// 4.更新数据</span><span class="hljs-comment">// 第一个参数  需要更新的  第二个参数 更新什么</span><span class="hljs-title class_">User</span>.<span class="hljs-title function_">update</span>(&#123;    <span class="hljs-attr">userName</span>: <span class="hljs-string">&#x27;朱元璋&#x27;</span>&#125;, &#123;    <span class="hljs-attr">password</span>: <span class="hljs-string">&#x27;123456&#x27;</span>&#125;, <span class="hljs-function">(<span class="hljs-params">err, ret</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (err) &#123;        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;更新失败&#x27;</span>);    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ret);    &#125;&#125;)</code></pre></li></ul>]]></content>
    
    
    <categories>
      
      <category>Mongodb</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Node</tag>
      
      <tag>Mongodb</tag>
      
      <tag>mongoose</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Express的使用⭐⭐⭐</title>
    <link href="/2020/08/08/07.Express%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/08/08/07.Express%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="07-Express-的使用"><a href="#07-Express-的使用" class="headerlink" title="07.Express 的使用"></a>07.Express 的使用</h1><h2 id="1-安装express"><a href="#1-安装express" class="headerlink" title="1.安装express"></a>1.安装express</h2><pre><code class="hljs shell">npm install express --save</code></pre><h2 id="2-简单使用express"><a href="#2-简单使用express" class="headerlink" title="2.简单使用express"></a>2.简单使用express</h2><pre><code class="hljs JavaScript"><span class="hljs-comment">//0.安装</span><span class="hljs-comment">//1. 引入包</span><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<span class="hljs-comment">// 2. 创建服务器应用程序  也就是原来的 http.createServer</span><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();<span class="hljs-comment">// 以get的请求方式来 请求 /   </span>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;    res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;hello express!!!&#x27;</span>);&#125;)<span class="hljs-comment">// 相当于 之前的 server.linten</span>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Example app listening on port 3000!`</span>))</code></pre><h2 id="3-基本路由"><a href="#3-基本路由" class="headerlink" title="3.基本路由"></a>3.基本路由</h2><h3 id="get"><a href="#get" class="headerlink" title="get:"></a>get:</h3><pre><code class="hljs JavaScript">app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">req,res</span>)=&gt;</span>&#123;    res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Hello World!&#x27;</span>)&#125;)</code></pre><h3 id="post"><a href="#post" class="headerlink" title="post:"></a>post:</h3><pre><code class="hljs JavaScript">app.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">req,res</span>)=&gt;</span>&#123;    res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Hello World!&#x27;</span>)&#125;)</code></pre><h2 id="4-获取静态资源"><a href="#4-获取静态资源" class="headerlink" title="4.获取静态资源"></a>4.获取静态资源</h2><pre><code class="hljs JavaScript"><span class="hljs-comment">//  直接可以获取 /public 中的资源</span>app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">static</span>(<span class="hljs-string">&#x27;public&#x27;</span>))<span class="hljs-comment">//  直接可以获取 /files 中的资源</span>app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">static</span>(<span class="hljs-string">&#x27;files&#x27;</span>))<span class="hljs-comment">//  需要通过 /public/xxx 来获取 public 文件中的资源 推荐使用这种</span>app.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;/public&#x27;</span>,express.<span class="hljs-title function_">static</span>(<span class="hljs-string">&#x27;public&#x27;</span>))<span class="hljs-comment">//  需要通过 /static/xxx 来获取 public 文件中的资源 </span>app.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;/static&#x27;</span>,express.<span class="hljs-title function_">static</span>(<span class="hljs-string">&#x27;public&#x27;</span>))</code></pre><h2 id="5-在Express-中配置-art-template-模板引擎"><a href="#5-在Express-中配置-art-template-模板引擎" class="headerlink" title="5.在Express 中配置 art-template 模板引擎"></a>5.在Express 中配置 <code>art-template</code> 模板引擎</h2><ul><li><a href="https://github.com/aui/art-template">art-template Github仓库</a></li><li><a href="https://aui.github.io/art-template/">art-template 官网文档</a></li><li>安装：<pre><code class="hljs shell">npm install --save art-templatenpm install --save express-art-template</code></pre></li><li>配置：<pre><code class="hljs JavaScript">app.<span class="hljs-title function_">engine</span>(<span class="hljs-string">&#x27;art&#x27;</span>,<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express-art-template&#x27;</span>))<span class="hljs-comment">// 这里的html 要和 views 的文件 匹配</span>app.<span class="hljs-title function_">engine</span>(<span class="hljs-string">&#x27;html&#x27;</span>,<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express-art-template&#x27;</span>))</code></pre></li><li>使用：<pre><code class="hljs JavaScript">app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">req,res</span>)=&gt;</span>&#123;<span class="hljs-comment">// express 默认会去项目views 目录中 查找 idenx.html</span>    res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;index.html&#x27;</span>,&#123;        <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;heelo world&#x27;</span>    &#125;)&#125;)</code></pre></li><li>如果希望修改默认的 views 视图渲染存储目录， 可以：<pre><code class="hljs JavaScript"><span class="hljs-comment">// 注意  第一个参数 views 不能写错</span>app.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;views&#x27;</span>,目录路径)</code></pre></li></ul><h2 id="6-在Express-配置使用-express-session-插件"><a href="#6-在Express-配置使用-express-session-插件" class="headerlink" title="6.在Express 配置使用 express-session 插件"></a>6.在Express 配置使用 <code>express-session</code> 插件</h2><h4 id="在-Express-框架中，默认不支持-Session-和-Cookie"><a href="#在-Express-框架中，默认不支持-Session-和-Cookie" class="headerlink" title="在 Express 框架中，默认不支持 Session 和 Cookie"></a>在 Express 框架中，默认不支持 Session 和 Cookie</h4><h4 id="但是我们可以使用第三方中间件-：-express-session-来解决"><a href="#但是我们可以使用第三方中间件-：-express-session-来解决" class="headerlink" title="但是我们可以使用第三方中间件 ： express-session 来解决"></a>但是我们可以使用第三方中间件 ： express-session 来解决</h4><blockquote><p>参考文档：<a href="https://www.npmjs.com/package/express-session">https://www.npmjs.com/package/express-session</a><br>安装：</p></blockquote><pre><code class="hljs shell">npm install express-session</code></pre><p>配置：</p><pre><code class="hljs JavaScript"><span class="hljs-comment">// 该插件会为 req 请求对象添加一个成员：req.session 默认是一个对象</span><span class="hljs-comment">// 这是最简单的配置方式， 暂且不用关心里面的参数含义</span>app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">session</span>(&#123;    <span class="hljs-comment">// 配置加密字符串， 它会在原有的加密基础之上 和 这个字符串&#x27;node&#x27; 拼起来加密</span>    <span class="hljs-comment">// 目的是为了增加安全性， 防止客户端恶意伪造</span>    <span class="hljs-attr">secret</span>: <span class="hljs-string">&#x27;node&#x27;</span>,    <span class="hljs-attr">resave</span>: <span class="hljs-literal">false</span>,    <span class="hljs-attr">saveUninitialized</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">// 默认为true  意思是无论你是否使用了 Session， 都默认的直接给你分配一把钥匙</span>&#125;))</code></pre><p>使用：</p><pre><code class="hljs JavaScript"><span class="hljs-comment">// 添加 Session 数据： </span>req.<span class="hljs-property">session</span>.<span class="hljs-property">foo</span> = <span class="hljs-string">&#x27;bar&#x27;</span><span class="hljs-comment">//  访问 Session 数据： </span>req.<span class="hljs-property">session</span>.<span class="hljs-property">foo</span></code></pre><h5 id="提示：默认的-Session-数据是内存存储的，服务器一旦重启就会丢失，真正的生产环境会把Session进行持久化存储。"><a href="#提示：默认的-Session-数据是内存存储的，服务器一旦重启就会丢失，真正的生产环境会把Session进行持久化存储。" class="headerlink" title="提示：默认的 Session 数据是内存存储的，服务器一旦重启就会丢失，真正的生产环境会把Session进行持久化存储。"></a>提示：默认的 Session 数据是内存存储的，服务器一旦重启就会丢失，真正的生产环境会把Session进行持久化存储。</h5><h2 id="7-在Express-中获取表单GET请求参数"><a href="#7-在Express-中获取表单GET请求参数" class="headerlink" title="7.在Express 中获取表单GET请求参数"></a>7.在Express 中获取表单GET请求参数</h2><p>Express 内置了一个 API ， 可以直接通过 <code>req.query</code>来获取</p><h2 id="8-在Express-中获取表单-POST-请求体数据"><a href="#8-在Express-中获取表单-POST-请求体数据" class="headerlink" title="8.在Express 中获取表单 POST 请求体数据"></a>8.在Express 中获取表单 POST 请求体数据</h2><p>在Express 中没有内置获取表单 POST 请求体的 API， 所以我们要使用一个第三方包 ： <code>bdoy-parser</code></p><ul><li>安装<pre><code class="hljs shell">npm install --save body-parser</code></pre></li><li>配置<pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<span class="hljs-comment">// 0.引包</span><span class="hljs-keyword">var</span> bodyParser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;body-parser&#x27;</span>)<span class="hljs-keyword">var</span> app = <span class="hljs-title function_">express</span>()<span class="hljs-comment">// 配置 body-parser</span><span class="hljs-comment">// 只要加入下面俩行代码，则在req 请求对象上会多出来一个属性: body</span><span class="hljs-comment">// 也就是说你就可以直接通过 req.body 来获取表单 POST 请求体数据了</span><span class="hljs-comment">// create application/json parser</span>app.<span class="hljs-title function_">use</span>(bodyParser.<span class="hljs-title function_">json</span>())<span class="hljs-comment">// create application/x-www-form-urlencoded parser</span>app.<span class="hljs-title function_">use</span>(bodyParser.<span class="hljs-title function_">urlencoded</span>(&#123; <span class="hljs-attr">extended</span>: <span class="hljs-literal">false</span> &#125;))</code></pre></li><li>使用：<pre><code class="hljs JavaScript">app.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">req,res</span>)&#123;    res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&#x27;Content-Type&#x27;</span>,<span class="hljs-string">&#x27;text/plain&#x27;</span>)    res.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27;you posted: \n&#x27;</span>)    <span class="hljs-comment">// 可以通过 req.body 来获取表单 post 请求体数据</span>    res.<span class="hljs-title function_">end</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(req.<span class="hljs-property">body</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">2</span>))&#125;)</code></pre><h2 id="9-Express-中间件"><a href="#9-Express-中间件" class="headerlink" title="9.Express 中间件"></a>9.Express 中间件</h2><blockquote><p>参考文档： <a href="http://expressjs.com/en/guide/using-middleware.html#using-middleware">http://expressjs.com/en/guide/using-middleware.html#using-middleware</a></p></blockquote></li></ul><p><img src="https://image.baidu.com/search/detail?ct=503316480&z=0&ipn=d&word=%E8%87%AA%E6%9D%A5%E6%B0%B4%E5%8E%82&step_word=&hs=0&pn=17&spn=0&di=3960&pi=0&rn=1&tn=baiduimagedetail&is=0,0&istype=0&ie=utf-8&oe=utf-8&in=&cl=2&lm=-1&st=undefined&cs=3663111018,2872047785&os=2674119153,3091905494&simid=4252039746,522837713&adpicid=0&lpn=0&ln=1748&fr=&fmq=1597577857986_R&fm=&ic=undefined&s=undefined&hd=undefined&latest=undefined&copyright=undefined&se=&sme=&tab=0&width=undefined&height=undefined&face=undefined&ist=&jit=&cg=&bdtype=0&oriquery=&objurl=http://thumb.1010pic.com/pic3/quiz/images/201504/222/673f4ce9.png&fromurl=ippr_z2C$qAzdH3FAzdH3Fooo_z&e3B8a8a3tw3tw5_z&e3Bv54AzdH3FvzixAzdH3Ffitpt_t1_1d1mc1lwl00majd0kujdjvducl1u1vmm&gsm=13&rpstart=0&rpnum=0&islist=&querylist=&force=undefined" srcset="/img/loading.gif" alt="中间件 类似于自来水厂的流程"></p><p>中间件的本质就是一个请求处理方法，我们把用户从请求到响应的整个过程分发到多个中间件中去处理，这样做的目的是提高代码的灵活性，动态可扩展的</p><h3 id="9-1-应用程序级别的中间件"><a href="#9-1-应用程序级别的中间件" class="headerlink" title="9.1 应用程序级别的中间件"></a>9.1 应用程序级别的中间件</h3><p>万能匹配（不关心任何请求路径和请求方法）</p><pre><code class="hljs JavaScript">app.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">req,res,next</span>)&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Time&#x27;</span>,<span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>())    <span class="hljs-title function_">next</span>()&#125;)</code></pre><p>以 ‘/xxx/‘ 开头的 条件的 才能匹配</p><pre><code class="hljs JavaScript">app.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;/xxx/&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">req,res,next</span>)&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Time&#x27;</span>,<span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>())    <span class="hljs-title function_">next</span>()&#125;)</code></pre><h3 id="9-2-路由级别的中间件"><a href="#9-2-路由级别的中间件" class="headerlink" title="9.2 路由级别的中间件"></a>9.2 路由级别的中间件</h3><p>get：</p><pre><code class="hljs JavaScript">app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) &#123;    res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27; Got a POST request&#x27;</span>)&#125;)</code></pre><p>post:</p><pre><code class="hljs JavaScript">app.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) &#123;    res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Hello world&#x27;</span>)&#125;)</code></pre><p>put :</p><pre><code class="hljs JavaScript">app.<span class="hljs-title function_">put</span>(<span class="hljs-string">&#x27;/user&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) &#123;    res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27; Got a PUT request at /user&#x27;</span>)&#125;)</code></pre><p>delete :</p><pre><code class="hljs JavaScript">app.<span class="hljs-title function_">delete</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) &#123;    res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27; Got a DELETE request at /user&#x27;</span>) &#125;)</code></pre><h3 id="9-3错误处理中间件"><a href="#9-3错误处理中间件" class="headerlink" title="9.3错误处理中间件"></a>9.3错误处理中间件</h3><pre><code class="hljs JavaScript">app.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">err,req,res,next</span>)&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(err,stack);    res.<span class="hljs-title function_">status</span>(<span class="hljs-number">500</span>).<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Something broke&#x27;</span>);&#125;);</code></pre><p>配置使用404中间件：</p><pre><code class="hljs JavaScript">app.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">req,res</span>)&#123;    res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;404.html&#x27;</span>);&#125;);</code></pre><p>配置全局错误处理中间件:</p><pre><code class="hljs JavaScript">app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/a&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">req, res, next</span>) &#123;fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;.a/bc&#x27;</span>, <span class="hljs-title function_">funtion</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">if</span> (err) &#123;        <span class="hljs-comment">// 当调用next()传参后，则直接进入到全局错误处理中间件方法中</span>        <span class="hljs-comment">// 当发生全局错误的时候，我们可以调用next传递错误对象</span>        <span class="hljs-comment">// 然后被全局错误处理中间件匹配到并进行处理</span><span class="hljs-title function_">next</span>(err);&#125;&#125;)&#125;);<span class="hljs-comment">//全局错误处理中间件</span>app.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">err,req,res,next</span>)&#123;    res.<span class="hljs-title function_">status</span>(<span class="hljs-number">500</span>).<span class="hljs-title function_">json</span>(&#123;        <span class="hljs-attr">err_code</span>:<span class="hljs-number">500</span>,        <span class="hljs-attr">message</span>:err.<span class="hljs-property">message</span>    &#125;);&#125;);</code></pre><h3 id="9-4-内置中间件"><a href="#9-4-内置中间件" class="headerlink" title="9.4 内置中间件"></a>9.4 内置中间件</h3><ul><li>express.static(提供静态文件)<ul><li><a href="http://expressjs.com/en/starter/static-files.html#serving-static-files-in-express">http://expressjs.com/en/starter/static-files.html#serving-static-files-in-express</a><h3 id="9-5-第三方中间件"><a href="#9-5-第三方中间件" class="headerlink" title="9.5 第三方中间件"></a>9.5 第三方中间件</h3><blockquote><p>参考文档：<a href="http://expressjs.com/en/resources/middleware.html">http://expressjs.com/en/resources/middleware.html</a></p></blockquote></li></ul></li><li>body-parser</li><li>compression</li><li>cookie-parser</li><li>mogran</li><li>response-time</li><li>server-static</li><li>session</li></ul>]]></content>
    
    
    <categories>
      
      <category>Nodejs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Node</tag>
      
      <tag>Express</tag>
      
      <tag>art-template</tag>
      
      <tag>express-session</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Node的模板系统</title>
    <link href="/2020/08/08/06.%E6%A8%A1%E5%9D%97%E7%B3%BB%E7%BB%9F/"/>
    <url>/2020/08/08/06.%E6%A8%A1%E5%9D%97%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="06-模块系统"><a href="#06-模块系统" class="headerlink" title="06.模块系统"></a>06.模块系统</h1><p>在node中JavaScript还有一个很重要的概念：模块系统</p><ul><li>模块作用域</li><li>使用require方法用来加载模块</li><li>使用exports 接口对象用来到处模块中的成员<h2 id="1-加载require"><a href="#1-加载require" class="headerlink" title="1.加载require"></a>1.加载<code>require</code></h2>语法：<pre><code class="hljs javaScript"><span class="hljs-keyword">const</span> 自定义变量名称 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;模块&#x27;</span>)</code></pre>俩个作用：</li><li>执行被加载模块中的代码</li><li>得到被加载模块中的 <code>exports</code>导出接口对象<h2 id="2-导出-exports"><a href="#2-导出-exports" class="headerlink" title="2.导出 exports"></a>2.导出 <code>exports</code></h2></li><li>node中的模块作用域，默认文件中所有成员只在当前文件模块有效</li><li>对于希望可以被其他模块访问的信息，我们就需要把这些公共的成员都挂载到 <code>exports</code> 接口对象中就可以导出多个成员（必须在对象中）</li></ul><p>导出多个成员（必须在对象中:此时exports是个对象）：</p><pre><code class="hljs javaScript"><span class="hljs-built_in">exports</span>.<span class="hljs-property">a</span>=<span class="hljs-number">123</span><span class="hljs-built_in">exports</span>.<span class="hljs-property">b</span>=<span class="hljs-string">&#x27;hello&#x27;</span><span class="hljs-built_in">exports</span>.<span class="hljs-property">c</span>=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;ccc&#x27;</span>)&#125;</code></pre><p>导出单个成员（就是拿到：函数，字符串等）</p><pre><code class="hljs JavaScript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-string">&#x27;hello&#x27;</span></code></pre><p>以下情况会覆盖：最下边会覆盖上边的</p><pre><code class="hljs JavaScript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-string">&#x27;hello&#x27;</span><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;ccc&#x27;</span>)&#125;</code></pre><p>也可以导出多个成员：就是把它变为对象了</p><pre><code class="hljs JavaScript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;    <span class="hljs-attr">add</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;            &#125;    str : <span class="hljs-string">&#x27;heelo&#x27;</span>&#125;</code></pre><h2 id="3-导出-module-exports-原理解析"><a href="#3-导出-module-exports-原理解析" class="headerlink" title="3.导出 module.exports 原理解析"></a>3.导出 <code>module.exports</code> 原理解析</h2><p><code>exports</code> 和 <code>module.exports</code> 的一个引用<br>内部隐藏代码实际是这样子的：</p><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> <span class="hljs-variable language_">module</span> = &#123;    <span class="hljs-built_in">exports</span>  = &#123;            &#125;&#125;<span class="hljs-keyword">let</span> <span class="hljs-built_in">exports</span> = <span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span><span class="hljs-comment">// console.log(exports === module.exports)  // true</span><span class="hljs-keyword">return</span> <span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span></code></pre><h2 id="4-exports-和-module-exports-的-区别"><a href="#4-exports-和-module-exports-的-区别" class="headerlink" title="4.exports 和 module.exports 的 区别"></a>4.exports 和 module.exports 的 区别</h2><ul><li><p>每个模块中都有一个<code>module</code>对象</p></li><li><p><code>module</code>对象中都有一个<code>exports</code>对象</p></li><li><p>我们可以把需要导出的成员都挂载到<code>module.exports</code>接口对象中</p></li><li><p>也就是， <code>module.exports.xxx= xxx</code> 的方式</p></li><li><p>但是每次都 <code>module.exports.xxx = xxx</code> 很麻烦</p></li><li><p>所以 node 为了使用方便， 同时在每一个模块中都提供了一个成员叫 <code>exports</code></p></li><li><p><code>exports = module.exports</code>   结果为 true 就证明了此点</p></li><li><p>所以对于： <code>module.exports.xxx= xxx</code> 的方式完全可以 <code>exports.xxx= xxx</code></p></li><li><p>当每一个模块需要导出单个成员的时候，这个时候必须使用： <code>module.exports= xxx</code> 的方式， </p></li><li><p>不要使用 <code>exports = xxx</code> 不管用</p></li><li><p>因为每个模块最终向外 <code>return</code> 的是 <code>module.exports</code> </p></li><li><p>而<code>exports</code> 只是 <code>module.exports</code> 的一个引用</p></li><li><p>所以即便你为 <code>exports =xxx</code> 重新赋值，也不会影响到<code>module.exports</code> </p></li><li><p>但是有一种赋值比较特殊 : <code>exports = module.exports</code>这个可以重新建立引用关系</p></li><li><h2 id="5-模块查找机制"><a href="#5-模块查找机制" class="headerlink" title="5.模块查找机制"></a>5.模块查找机制</h2></li><li><p>自己的定义的模块 （路径形式的模块）</p><ul><li>自定义模块形式的书写：</li><li> ./  代表 当前目录，不可省略</li><li> ../ 代表 上一级目录， 不可省略</li><li> /xxx  和 d:/a/foo.js  这种形式的 不用</li><li>首位的 / 在这里表示的是当前文件模块所属磁盘根路径</li><li>.js 后缀名可以省略</li><li>require(‘./foo.js’)</li></ul></li><li><p>优先从缓存加载</p></li><li><p>核心模块</p><ul><li>核心模块已经被编译到了二进制二文件中，我们只需要按照名字来加载模块就可以了</li><li>require(‘fs’)</li><li>require(‘http’)</li></ul></li><li><p>第三方模块</p><ul><li>查找步骤：以为 第三方<code> express</code> 模块为例</li><li>node_modules/express/</li><li>node_modules/express/package.json</li><li>node_modules/express/package.json/文件中找main属性</li><li>如果找不到main属性 就 默认 index.js 为备选项</li><li>以上找不到 就 进入上一级目录 node_modules 再次查找</li><li>按照这个规则依次往上找，类似于 <code>js中的原型链</code>， 直到磁盘根目录还找不到，就会报错 :cannot find module xxxx</li></ul></li></ul><h2 id="6-npm"><a href="#6-npm" class="headerlink" title="6.npm"></a>6.npm</h2><ul><li>node package manager   意思就是 node 包管理者，帮助我们去安装一些第三方包的<h3 id="6-1npm-网站"><a href="#6-1npm-网站" class="headerlink" title="6.1npm 网站"></a>6.1npm 网站</h3></li><li>[npmjs.com]   用来搜索第三方包， 所有的第三方包都在这里<h3 id="6-2-npm命令行工具"><a href="#6-2-npm命令行工具" class="headerlink" title="6.2 npm命令行工具"></a>6.2 npm命令行工具</h3></li><li>npm 的第二次含义就是一个命令行工具，只要你安装了 node 就已经安装了npm</li><li>npm也有版本这个概念  可以通过在命令行中输入 查看版本号<pre><code class="hljs shell">npm --version   //查看版本号npm install --global npm   // 升级npm</code></pre><h3 id="6-3解决npm被墙的问题"><a href="#6-3解决npm被墙的问题" class="headerlink" title="6.3解决npm被墙的问题"></a>6.3解决npm被墙的问题</h3>npm存储包文件的服务器在国外，有时候会被强，速度会很慢。</li><li>[<a href="http://npm.taobao.org/]">http://npm.taobao.org/]</a> 淘宝的开发团队把npm在国内做了一个备份</li><li>安装淘宝的npm<pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">在任意目录执行都可以</span><span class="hljs-meta prompt_"># </span><span class="language-bash">-- global 表示安装到全局， 而非当前目录  注意不能省略 --global</span>npm install --global cnpm</code></pre>接下来你安装包的时候把之前的<code>npm</code>替换成<code>cnpm</code>就行了<pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">这里 还是走国外的服务器，速度慢</span>npm install jquert<span class="hljs-meta prompt_"># </span><span class="language-bash">使用cnpm 就会通过淘宝的服务器来下载jquery</span>cnpm install jquert</code></pre>如果不想安装 <code>cnpm</code> 又想使用淘宝的服务器下载：<pre><code class="hljs shell">npm install jquery --registry=https://registry.npm.taobao.org</code></pre>但是每一次手都这样会很麻烦，所有可以把这个选项加入配置文件中<pre><code class="hljs shell">npm config set registry https://registry.npm.taobao.org<span class="hljs-meta prompt_"># </span><span class="language-bash">查看npm配置信息</span>npm config list</code></pre>只要经过上面的命令配置，则以后你所有的 <code>npm install</code> 都会默认通过淘宝的服务器来下载</li></ul><h2 id="7-package-json"><a href="#7-package-json" class="headerlink" title="7.package.json"></a>7.package.json</h2><ul><li>我们建议每一个项目都需要有一个 <code>package.json</code>文件（包描述文件，就像产品的说明书一样）</li><li>这个文件可以通过<code>npm init</code> 的方式来自动化出来， 但现在的版本都可以自动生成了。</li><li>对于我们新手来说，最有用的是 <code>dependencies</code> 选项，可以用来帮我们保存第三方包的依赖信息</li><li>如果你的 <code>node_module</code> 删除了也不用担心，我们只需要： <code>npm install</code> 就会自动把 <code>package.json</code> 中的 <code>dependencies</code>中所有依赖项都会下载回来</li><li>要求每个项目的根目录下都有一个 <code>package,json</code>文件</li><li>建议执行 <code>npm install 包名</code> 时候 都加上<code>--save</code>（新版本也就不用啦） 来保存依赖项信息 </li></ul><h3 id="7-1-package-lock-json-和-package-json"><a href="#7-1-package-lock-json-和-package-json" class="headerlink" title="7.1 package-lock.json 和 package.json"></a>7.1 package-lock.json 和 package.json</h3><p>npm 5 版本 以前是不会有 <code>package-lock.json </code>这个文件</p><p>npm 5 版本之后才加入这个文件<br>当你安装包的时候，npm都会生成或者更新 <code>package-lock.json </code>这个文件</p><ul><li>npm 5版本以后的 安装包不需要加 <code>--save</code>参数就会自动保存依赖信息</li><li>当你安装包的时候，会自动创建或者是更新 <code>package-lock.json </code>这个文件</li><li><code>package-lock.json </code>这个文件会保存 <code>node_modules</code>中所有包的信息（版本，下载地址等）<ul><li>这样的话，重新 <code>npm install</code> 的时候 速度会提升</li></ul></li><li>从文件名来看 <code>lock</code> 称 为 锁<ul><li>这个 <code>lock</code>用来锁定版本的</li><li>如果项目 依赖这个包 <code>1.1.1</code>这个版本， 重新 <code>npm install</code>时候就会下载最新版本 ，而不是 1.1.1 版本</li><li>所以我们希望 锁 住 这个 版本</li><li>所以<code>package-lock.json </code>这个文件的其中作用就是 锁定版本号，防止自动升级版本<h2 id="8-文件操作路径和模块路径"><a href="#8-文件操作路径和模块路径" class="headerlink" title="8.文件操作路径和模块路径"></a>8.文件操作路径和模块路径</h2></li></ul></li><li>文件操作路径</li><li><pre><code class="hljs JavaScript"><span class="hljs-comment">// 在文件操作的相对路径中</span><span class="hljs-comment">// ./data/a.txt  相当于当前目录</span><span class="hljs-comment">// data/a.txt  相当于当前目录</span><span class="hljs-comment">// 以下俩种几乎不用 （不要用）</span><span class="hljs-comment">//  /data/a.txt   绝对路径，当前文件模块所处磁盘根目录</span><span class="hljs-comment">//  c;/xx/xx  绝对路径</span>fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-params"><span class="hljs-string">&#x27;./data/a.txt&#x27;</span>,(err)=&gt;&#123;data&#125;</span>)&#123;    &#125;</code></pre></li></ul><ul><li>模块操作路径<pre><code class="hljs JavaScript"><span class="hljs-comment">// 如果这里忽略了 .   则也是磁盘根目录</span><span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;/data/foo.js&#x27;</span>)<span class="hljs-comment">// 相当路径  在模块路径中 一定不能省略 ./  </span><span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./data/foo.js&#x27;</span>)</code></pre><h2 id="9-nodemon-修改代码自动重启服务器"><a href="#9-nodemon-修改代码自动重启服务器" class="headerlink" title="9.nodemon 修改代码自动重启服务器"></a>9.nodemon 修改代码自动重启服务器</h2></li><li>我们这里可以使用一个nodemon 第三方命令行工具 来解决我们频繁修改代码重启服务器的问题</li><li><code>nodemon</code> 是一个基于Node.js开发的一个第三方命令行工具，需要独立安装<pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">在任意目录中执行该命令都行</span>npm  install --global nodemon</code></pre></li><li>安装完毕后，使用:<pre><code class="hljs shell"><span class="hljs-meta prompt_"> # </span><span class="language-bash">使用nodemon</span>nodemon app.js</code></pre><h2 id="10-path-路径操作模块"><a href="#10-path-路径操作模块" class="headerlink" title="10.path 路径操作模块"></a>10.path 路径操作模块</h2></li><li>path.basename <ul><li>获取一个路径的文件名  （默认包含扩展名）<pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">path.basename(<span class="hljs-string">&#x27;c:/a/b/c/index.js&#x27;</span>)</span>&#x27;index.js&#x27;<span class="hljs-meta prompt_"></span><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">path.basename(<span class="hljs-string">&#x27;c:/a/b/c/index.js&#x27;</span>,<span class="hljs-string">&#x27;.js&#x27;</span>)</span>&#x27;index&#x27;</code></pre></li></ul></li><li>path.dirname<ul><li>获取一个路径中的目录部分<pre><code class="hljs shell"><span class="hljs-meta prompt_"> &gt; </span><span class="language-bash">path.dirname(<span class="hljs-string">&#x27;c:/a/b/c/index.js&#x27;</span>)</span>&#x27;c:/a/b/c&#x27;</code></pre></li></ul></li><li>path.extname<ul><li>获取一个路径中的扩展名部分<pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">path.extname(<span class="hljs-string">&#x27;c:/a/b/c/index.js&#x27;</span>)</span>&#x27;.js&#x27;</code></pre></li></ul></li><li>path.pars<ul><li>把一个路径转为对象<ul><li>root 根路径</li><li>dir 目录</li><li>base  包含后缀名的文件名</li><li>ext 后缀名</li><li>name 不包含后缀名的文件名<pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">path.parse(<span class="hljs-string">&#x27;c:/a/b/c/index.js&#x27;</span>)</span>&#123;  root: &#x27;c:/&#x27;,  dir: &#x27;c:/a/b/c&#x27;,  base: &#x27;index.js&#x27;,  ext: &#x27;.js&#x27;,  name: &#x27;index&#x27;&#125;</code></pre></li></ul></li></ul></li><li>path.join<ul><li>当你需要进行路径拼接的时候， 推荐使用<pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">path.join(<span class="hljs-string">&#x27;c:/a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>)</span>&#x27;c:\\a\\b&#x27;</code></pre></li></ul></li><li>path.isAbsolute<ul><li>判断一个路径是否为绝对路径<pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">path.isAbsolute(<span class="hljs-string">&#x27;c:/a/b/c/index.js&#x27;</span>)</span>true<span class="hljs-meta prompt_">&gt; </span><span class="language-bash">path.isAbsolute(<span class="hljs-string">&#x27;/a/b/c/index.js&#x27;</span>)</span>true<span class="hljs-meta prompt_">&gt; </span><span class="language-bash">path.isAbsolute(<span class="hljs-string">&#x27;./a/b/c/index.js&#x27;</span>)</span>false</code></pre><h2 id="11-Node中的其他成员-（-dirname-和-filename）"><a href="#11-Node中的其他成员-（-dirname-和-filename）" class="headerlink" title="11.Node中的其他成员 （__dirname 和 __filename）"></a>11.Node中的其他成员 （__dirname 和 __filename）</h2>在每个模块中， 除了 <code>require</code> 和 <code>exports</code> 等模块相关AIP之外，还有俩个特殊成员：</li></ul></li><li><code>__dirname</code> <strong>动态获取</strong> 可以用来获取当前文件的所属目录的绝对路径 （这个没有加文件 只是文件的绝对目录）</li><li><code>__filename</code> <strong>动态获取</strong> 可以用来获取当前文件的绝对路径 （这个加上了文件）</li><li> <code>__dirname</code> 和<code>__filename</code>是不受执行node命令所属路径影响的</li></ul><p>在文件操作中，使用相对路径是不可靠的，因为<strong>在Node 中 文件操作 的路径被设计为相对于执行node命令所处的路径</strong>（不是bug，人家这样设计是有使用场景）<br>所以为了解决这个问题，只需要把 <strong>相对路径变为绝对路径</strong> 就可以了<br>所以我们可以使用<code>__dirname</code>和<code>__filename</code>来帮我们解决这个问题</p><p>在拼接路径过程中，为了 避免手动凭借带来的一些低级错误， 我们推荐使用： <code>path.join()</code> 来辅助拼接。</p><p>所以为了尽量避免刚才所描述的问题，以后必须在文件操作中使用相对路径都统一转换为 <strong>动态的绝对路径</strong></p><blockquote><p>注意： 模块中的路径标识 和 文件操作 中的 相对路径标识 不一致</p></blockquote><blockquote><p>模块中的路径表示就是相当于当前文件模块，不受执行node 命令所处路径影响</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Nodejs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Node来简单结合fs模块来访问不同资源实例</title>
    <link href="/2020/08/06/03.%E7%AE%80%E5%8D%95%E7%BB%93%E5%90%88fs%E6%A8%A1%E5%9D%97%E6%9D%A5%E8%AE%BF%E9%97%AE%E4%B8%8D%E5%90%8C%E8%B5%84%E6%BA%90%E5%AE%9E%E4%BE%8B/"/>
    <url>/2020/08/06/03.%E7%AE%80%E5%8D%95%E7%BB%93%E5%90%88fs%E6%A8%A1%E5%9D%97%E6%9D%A5%E8%AE%BF%E9%97%AE%E4%B8%8D%E5%90%8C%E8%B5%84%E6%BA%90%E5%AE%9E%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="简单结合fs模块来访问不同资源实例"><a href="#简单结合fs模块来访问不同资源实例" class="headerlink" title="简单结合fs模块来访问不同资源实例"></a>简单结合fs模块来访问不同资源实例</h1><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>);<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<span class="hljs-keyword">const</span> server = http.<span class="hljs-title function_">createServer</span>();server.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;request&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;    <span class="hljs-keyword">const</span> url = req.<span class="hljs-property">url</span>;    <span class="hljs-keyword">if</span> (url === <span class="hljs-string">&#x27;/&#x27;</span>) &#123;        fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./resource/index.html&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">error, data</span>) =&gt;</span> &#123;            <span class="hljs-keyword">if</span> (error) &#123;                res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&#x27;Content-Type&#x27;</span>, <span class="hljs-string">&#x27;text/plain,charset=utf-8&#x27;</span>);                res.<span class="hljs-title function_">end</span>(<span class="hljs-string">&#x27;文件读取失败，请稍后再试&#x27;</span>);            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">// data 默认是 二进制数据， 可以通过   toString 转换为咱们能识别的字符串</span>                <span class="hljs-comment">// res.end()  支持俩种数据格式    一种是 二进制，  一种是 字符串</span>                res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&#x27;Content-Type&#x27;</span>, <span class="hljs-string">&#x27;text/html,charset=utf-8&#x27;</span>);                res.<span class="hljs-title function_">end</span>(data);            &#125;;        &#125;);    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (url === <span class="hljs-string">&#x27;/images&#x27;</span>) &#123;        fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./resource/images/3.jpg&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">error, data</span>) =&gt;</span> &#123;            <span class="hljs-keyword">if</span> (error) &#123;                res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&#x27;Content-Type&#x27;</span>, <span class="hljs-string">&#x27;text/plain,charset=utf-8&#x27;</span>);                res.<span class="hljs-title function_">end</span>(<span class="hljs-string">&#x27;图片读取失败，请稍后再试&#x27;</span>);            &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 注意：尽量图片尽量不要跟编码格式，它有自己独有的编码格式</span>                res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&#x27;Content-Type&#x27;</span>, <span class="hljs-string">&#x27;image/jpeg&#x27;</span>);                res.<span class="hljs-title function_">end</span>(data);            &#125;;        &#125;);    &#125;&#125;);server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;服务器启动成功，可以通过 http://127.0.0.1:3000/ 来访问&#x27;</span>);&#125;)</code></pre><h5 id="简化了以上的代码"><a href="#简化了以上的代码" class="headerlink" title="简化了以上的代码"></a>简化了以上的代码</h5><blockquote><p>运用了逆向思维，这样可以不用一一对应的把每个文件读出来</p></blockquote><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>);<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<span class="hljs-keyword">const</span> server = http.<span class="hljs-title function_">createServer</span>();server.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;request&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;    <span class="hljs-keyword">let</span> url = req.<span class="hljs-property">url</span>;    <span class="hljs-keyword">let</span> wwwDir = <span class="hljs-string">&#x27;F:/nodejs/Node_test/resource&#x27;</span>;    <span class="hljs-keyword">let</span> filePath = <span class="hljs-string">&#x27;/index.html&#x27;</span>;    <span class="hljs-comment">//  默认的 是 /   所以 客户端中出现的就是 /index.html 这个文件内容</span>    <span class="hljs-keyword">if</span> (url !== <span class="hljs-string">&#x27;/&#x27;</span>) &#123;        filePath = url;    &#125;;    fs.<span class="hljs-title function_">readFile</span>(wwwDir + filePath, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (err) &#123;            <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">end</span>(<span class="hljs-string">&#x27;404 Not Found.&#x27;</span>);        &#125;        res.<span class="hljs-title function_">end</span>(data);    &#125;);&#125;);server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;服务器启动成功，可以通过 http://127.0.0.1:3000/ 来访问&#x27;</span>);&#125;);</code></pre>]]></content>
    
    
    <categories>
      
      <category>Nodejs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Node来模仿Apache功能来完成目录列表渲染</title>
    <link href="/2020/08/05/04.%E6%A8%A1%E4%BB%BFApache%E5%8A%9F%E8%83%BD%E6%9D%A5%E5%AE%8C%E6%88%90%E7%9B%AE%E5%BD%95%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93/"/>
    <url>/2020/08/05/04.%E6%A8%A1%E4%BB%BFApache%E5%8A%9F%E8%83%BD%E6%9D%A5%E5%AE%8C%E6%88%90%E7%9B%AE%E5%BD%95%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93/</url>
    
    <content type="html"><![CDATA[<h1 id="模仿Apache功能来完成目录列表渲染"><a href="#模仿Apache功能来完成目录列表渲染" class="headerlink" title="模仿Apache功能来完成目录列表渲染"></a>模仿Apache功能来完成目录列表渲染</h1><hr><h4 id="fs-readdir-这个API用来读取文件目录"><a href="#fs-readdir-这个API用来读取文件目录" class="headerlink" title="fs.readdir   这个API用来读取文件目录"></a>fs.readdir   这个API用来读取文件目录</h4><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);fs.<span class="hljs-title function_">readdir</span>(<span class="hljs-string">&#x27;F:/nodejs/Node_test&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, files</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (err) &#123;        <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">end</span>(<span class="hljs-string">&#x27;文件目录不存在.&#x27;</span>)    &#125;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(files);&#125;);</code></pre><h4 id="返回的值是-一个数组"><a href="#返回的值是-一个数组" class="headerlink" title="返回的值是 一个数组"></a>返回的值是 一个数组</h4><ul><li>[<br>‘02.module-a.js’,<br>‘02.module-b.js’,<br>‘03.module-exports.js’,<br>‘03.require.js’,<br>‘04.写文件.js’,<br>‘04.读取文件.js’,<br>‘05.简单的http请求.js’,<br>‘06.响应类型内容Content-Type.js’,<br>‘07.简单结合fs模块来访问不同资源.js’,<br>‘08.简化07代码，模仿Apache功能.js’,<br>‘09.Apache目录列表.js’,<br>‘09.读取目录（fs.readdir  API）.js’,<br>‘1.heeloword.js’,<br>‘data.txt’,<br>‘nodejs资料（7天）’,<br>‘resource’,<br>‘你好.txt’<br>]</li></ul><hr><h2 id="简单的来实现了-目录列表"><a href="#简单的来实现了-目录列表" class="headerlink" title="简单的来实现了 目录列表"></a>简单的来实现了 目录列表</h2><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>)<span class="hljs-keyword">const</span> server = http.<span class="hljs-title function_">createServer</span>()<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)server.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;request&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;    <span class="hljs-keyword">let</span> url = req.<span class="hljs-property">url</span>    <span class="hljs-keyword">let</span> wwwDir = <span class="hljs-string">&#x27;F:/nodejs/Node_test/resource&#x27;</span>    fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./resource/index.html&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> &#123;    <span class="hljs-comment">// data 是 index.html 的二进制数据</span>        <span class="hljs-keyword">if</span> (err) &#123;            <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">end</span>(<span class="hljs-string">&#x27;404 Not Foun.&#x27;</span>)        &#125;        <span class="hljs-comment">// 1. 如何得到 wwwDir 目录列表中的文件名和目录名</span>        <span class="hljs-comment">//    fs.readdir  这个API可以读取目录列表中的文件名和目录名</span>        <span class="hljs-comment">// 2. 如何将得到的文件名和目录名替换到 template.html 中</span>        <span class="hljs-comment">//    2.1 在 template.html 中需要替换的位置预留一个特殊的标记（就像以前使用模板引擎的标记一样）</span>        <span class="hljs-comment">//    2.2 根据 files 生成需要的 HTML 内容</span>        <span class="hljs-comment">// 只要你做了这两件事儿，那这个问题就解决了</span>        fs.<span class="hljs-title function_">readdir</span>(wwwDir, <span class="hljs-function">(<span class="hljs-params">err, files</span>) =&gt;</span> &#123;            <span class="hljs-keyword">if</span> (err) &#123;                <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">end</span>(<span class="hljs-string">&#x27;文件不存在.&#x27;</span>)            &#125;            <span class="hljs-comment">// 2.1 生成需要替换的内容</span>            <span class="hljs-keyword">let</span> content = <span class="hljs-string">&#x27;&#x27;</span>;            files.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;                <span class="hljs-comment">// 在 EcmaScript 6 的 ` 字符串中，可以使用 $&#123;&#125; 来引用变量</span>                content += <span class="hljs-string">` &lt;tr&gt;</span><span class="hljs-string">                &lt;td data-value=&quot;nodejs资料（7天）/&quot;&gt;&lt;a class=&quot;icon dir&quot;</span><span class="hljs-string">                        href=&quot;/F:/nodejs/Node_test/nodejs%E8%B5%84%E6%96%99%EF%BC%887%E5%A4%A9%EF%BC%89/&quot;&gt;<span class="hljs-subst">$&#123;item&#125;</span>&lt;/a&gt;</span><span class="hljs-string">                &lt;/td&gt;</span><span class="hljs-string">                &lt;td class=&quot;detailsColumn&quot; data-value=&quot;0&quot;&gt;&lt;/td&gt;</span><span class="hljs-string">                &lt;td class=&quot;detailsColumn&quot; data-value=&quot;1596634470&quot;&gt;2020/8/5 下午9:34:30&lt;/td&gt;</span><span class="hljs-string">            &lt;/tr&gt;`</span>            &#125;);            <span class="hljs-comment">// 2.3 替换</span>            <span class="hljs-comment">// data 是 index.html 的二进制数据，要想渲染到页面先转换为字符串格式</span>            data = data.<span class="hljs-title function_">toString</span>();                        <span class="hljs-comment">// 将 index.html 中的内容的 *** 替换成 我们想要的目录列表内容</span>            data = data.<span class="hljs-title function_">replace</span>(<span class="hljs-string">&#x27;***&#x27;</span>, content);            <span class="hljs-comment">// 3. 发送解析替换过后的响应数据</span>            res.<span class="hljs-title function_">end</span>(data);        &#125;)    &#125;)&#125;);server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;服务器启动成功，可以通过 http://127.0.0.1:3000/ 来访问&#x27;</span>);&#125;)</code></pre>]]></content>
    
    
    <categories>
      
      <category>Nodejs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Node来留言板功能的简单实现</title>
    <link href="/2020/08/05/05.%E7%95%99%E8%A8%80%E6%9D%BF%E5%8A%9F%E8%83%BD%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/"/>
    <url>/2020/08/05/05.%E7%95%99%E8%A8%80%E6%9D%BF%E5%8A%9F%E8%83%BD%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="留言板功能的简单实现"><a href="#留言板功能的简单实现" class="headerlink" title="留言板功能的简单实现"></a>留言板功能的简单实现</h1><ul><li>先来说一下url模块</li><li><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> url = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;url&#x27;</span>)<span class="hljs-keyword">let</span> obj = url.<span class="hljs-title function_">parse</span>(<span class="hljs-string">&#x27;http://localhost:3000/pinglun?name=%E7%8E%8B%E9%B9%8F%E9%A3%9E&amp;message=%E7%8E%8B%E9%B9%8F%E9%A3%9E%E7%8E%8B%E9%B9%8F%E9%A3%9E%E7%8E%8B%E9%B9%8F%E9%A3%9E&#x27;</span>, <span class="hljs-literal">true</span>)  <span class="hljs-comment">//加个true， 可以把 query对象 解析为 对象  这样就可以拿到提交表单的 名字 和 评论 了</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj);  <span class="hljs-comment">// 返回的是 url模块中 的相关信息</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">query</span>); <span class="hljs-comment">// 返回的是 url路径 ? 之后的信息</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">query</span>.<span class="hljs-property">name</span>); </code></pre></li></ul><h2 id="留言板-服务器端代码实现"><a href="#留言板-服务器端代码实现" class="headerlink" title="留言板 服务器端代码实现"></a>留言板 服务器端代码实现</h2><h4 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h4><pre><code class="hljs JavaScript"><span class="hljs-comment">// 1. / index.html</span><span class="hljs-comment">// 2. 开放 public 目录中的静态资源</span><span class="hljs-comment">//    当请求 /public/xxx 的时候，读取响应 public 目录中的具体资源</span><span class="hljs-comment">// 3. /post post.html</span><span class="hljs-comment">// 4. /pinglun</span><span class="hljs-comment">//    4.1 接收表单提交数据</span><span class="hljs-comment">//    4.2 存储表单提交的数据</span><span class="hljs-comment">//    4.3 让表单重定向到 /</span><span class="hljs-comment">//        statusCode</span><span class="hljs-comment">//        setHeader</span></code></pre><pre><code class="hljs JavaScript"><span class="hljs-comment">// 把当前模块所有的依赖项都声明再文件模块最上面</span><span class="hljs-keyword">var</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>)<span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<span class="hljs-keyword">var</span> url = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;url&#x27;</span>)   <span class="hljs-comment">// 利用url 模块 中的方法 来 解析 req.url </span><span class="hljs-keyword">var</span> template = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;art-template&#x27;</span>)<span class="hljs-keyword">var</span> comments = [  &#123;    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;张三&#x27;</span>,    <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;今天天气不错！&#x27;</span>,    <span class="hljs-attr">dateTime</span>: <span class="hljs-string">&#x27;2015-10-16&#x27;</span>  &#125;,  &#123;    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;张三2&#x27;</span>,    <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;今天天气不错！&#x27;</span>,    <span class="hljs-attr">dateTime</span>: <span class="hljs-string">&#x27;2015-10-16&#x27;</span>  &#125;,  &#123;    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;张三3&#x27;</span>,    <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;今天天气不错！&#x27;</span>,    <span class="hljs-attr">dateTime</span>: <span class="hljs-string">&#x27;2015-10-16&#x27;</span>  &#125;,  &#123;    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;张三4&#x27;</span>,    <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;今天天气不错！&#x27;</span>,    <span class="hljs-attr">dateTime</span>: <span class="hljs-string">&#x27;2015-10-16&#x27;</span>  &#125;,  &#123;    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;张三5&#x27;</span>,    <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;今天天气不错！&#x27;</span>,    <span class="hljs-attr">dateTime</span>: <span class="hljs-string">&#x27;2015-10-16&#x27;</span>  &#125;]<span class="hljs-comment">// /pinglun?name=的撒的撒&amp;message=的撒的撒的撒</span><span class="hljs-comment">// 对于这种表单提交的请求路径，由于其中具有用户动态填写的内容</span><span class="hljs-comment">// 所以你不可能通过去判断完整的 url 路径来处理这个请求</span><span class="hljs-comment">// </span><span class="hljs-comment">// 结论：对于我们来讲，其实只需要判定，如果你的请求路径是 /pinglun 的时候，那我就认为你提交表单的请求过来了</span>http  .<span class="hljs-title function_">createServer</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) &#123; <span class="hljs-comment">// 简写方式，该函数会直接被注册为 server 的 request 请求事件处理函数</span>    <span class="hljs-comment">// 使用 url.parse 方法将路径解析为一个方便操作的对象，第二个参数为 true 表示直接将查询字符串转为一个对象（通过 query 属性来访问）</span>    <span class="hljs-keyword">var</span> parseObj = url.<span class="hljs-title function_">parse</span>(req.<span class="hljs-property">url</span>, <span class="hljs-literal">true</span>)    <span class="hljs-comment">// 单独获取不包含查询字符串的路径部分（该路径不包含 ? 之后的内容）</span>    <span class="hljs-keyword">var</span> pathname = parseObj.<span class="hljs-property">pathname</span>  <span class="hljs-comment">// 其实这个就相当于了 req.url</span>    <span class="hljs-keyword">if</span> (pathname === <span class="hljs-string">&#x27;/&#x27;</span>) &#123;      fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./views/index.html&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">err, data</span>) &#123;        <span class="hljs-keyword">if</span> (err) &#123;          <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">end</span>(<span class="hljs-string">&#x27;404 Not Found.&#x27;</span>)        &#125;        <span class="hljs-keyword">var</span> htmlStr = template.<span class="hljs-title function_">render</span>(data.<span class="hljs-title function_">toString</span>(), &#123;          <span class="hljs-attr">comments</span>: comments        &#125;)        res.<span class="hljs-title function_">end</span>(htmlStr)      &#125;)    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pathname === <span class="hljs-string">&#x27;/post&#x27;</span>) &#123;      <span class="hljs-comment">// 其它的都处理成 404 找不到</span>      fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./views/post.html&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">err, data</span>) &#123;        <span class="hljs-keyword">if</span> (err) &#123;          <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">end</span>(<span class="hljs-string">&#x27;404 Not Found.&#x27;</span>)        &#125;        res.<span class="hljs-title function_">end</span>(data)      &#125;)    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pathname.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&#x27;/public/&#x27;</span>) === <span class="hljs-number">0</span>) &#123;      <span class="hljs-comment">//    如果请求路径是以 /public/ 开头的，则我认为你要获取 public 中的某个资源</span>      <span class="hljs-comment">//    所以我们就直接可以把请求路径当作文件路径来直接进行读取</span>            <span class="hljs-comment">// 注意 读取 文件 一定要 加 . 这样才能找到该路径</span>      fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;.&#x27;</span> + pathname, <span class="hljs-keyword">function</span> (<span class="hljs-params">err, data</span>) &#123;        <span class="hljs-keyword">if</span> (err) &#123;          <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">end</span>(<span class="hljs-string">&#x27;404 Not Found.&#x27;</span>)        &#125;        res.<span class="hljs-title function_">end</span>(data)      &#125;)    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pathname === <span class="hljs-string">&#x27;/pinglun&#x27;</span>) &#123;      <span class="hljs-comment">// 注意：这个时候无论 /pinglun?xxx 之后是什么，我都不用担心了，因为我的 pathname 是不包含 ? 之后的那个路径</span>      <span class="hljs-comment">// 一次请求对应一次响应，响应结束这次请求也就结束了</span>      <span class="hljs-comment">// res.end(JSON.stringify(parseObj.query))</span>      <span class="hljs-comment">// 我们已经使用 url 模块的 parse 方法把请求路径中的查询字符串给解析成一个对象了</span>      <span class="hljs-comment">// 所以接下来要做的就是：</span>      <span class="hljs-comment">//    1. 获取表单提交的数据 parseObj.query</span>      <span class="hljs-comment">//    2. 将当前时间日期添加到数据对象中，然后存储到数组中</span>      <span class="hljs-comment">//    3. 让用户重定向跳转到首页 /</span>      <span class="hljs-comment">//       当用户重新请求 / 的时候，我数组中的数据已经发生变化了，所以用户看到的页面也就变了</span>      <span class="hljs-keyword">var</span> comment = parseObj.<span class="hljs-property">query</span>      comment.<span class="hljs-property">dateTime</span> = <span class="hljs-string">&#x27;2017-11-2 17:11:22&#x27;</span>      comments.<span class="hljs-title function_">unshift</span>(comment)      <span class="hljs-comment">// 服务端这个时候已经把数据存储好了，接下来就是让用户重新请求 / 首页，就可以看到最新的留言内容了</span>      <span class="hljs-comment">// 如何通过服务器让客户端重定向？</span>      <span class="hljs-comment">//    1. 状态码设置为 302 临时重定向</span>      <span class="hljs-comment">//        statusCode</span>      <span class="hljs-comment">//    2. 在响应头中通过 Location 告诉客户端往哪儿重定向</span>      <span class="hljs-comment">//        setHeader</span>      <span class="hljs-comment">// 如果客户端发现收到服务器的响应的状态码是 302 就会自动去响应头中找 Location ，然后对该地址发起新的请求</span>      <span class="hljs-comment">// 所以你就能看到客户端自动跳转了</span>      res.<span class="hljs-property">statusCode</span> = <span class="hljs-number">302</span>      res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&#x27;Location&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>)      res.<span class="hljs-title function_">end</span>()    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-comment">// 其它的都处理成 404 找不到</span>      fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./views/404.html&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">err, data</span>) &#123;        <span class="hljs-keyword">if</span> (err) &#123;          <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">end</span>(<span class="hljs-string">&#x27;404 Not Found.&#x27;</span>)        &#125;        res.<span class="hljs-title function_">end</span>(data)      &#125;)    &#125;  &#125;)  .<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;running...&#x27;</span>)  &#125;)</code></pre>]]></content>
    
    
    <categories>
      
      <category>Nodejs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Node</tag>
      
      <tag>art-template模板引擎</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Node来实现简单的HTTP响应请求</title>
    <link href="/2020/08/05/02.%E7%AE%80%E5%8D%95%E7%9A%84HTTP%E5%93%8D%E5%BA%94%E8%AF%B7%E6%B1%82/"/>
    <url>/2020/08/05/02.%E7%AE%80%E5%8D%95%E7%9A%84HTTP%E5%93%8D%E5%BA%94%E8%AF%B7%E6%B1%82/</url>
    
    <content type="html"><![CDATA[<h1 id="简单的HTTP响应请求"><a href="#简单的HTTP响应请求" class="headerlink" title="简单的HTTP响应请求"></a>简单的HTTP响应请求</h1><h4 id="1-引入http模块"><a href="#1-引入http模块" class="headerlink" title="1. 引入http模块"></a>1. 引入http模块</h4><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>);</code></pre><h4 id="2-创建-server"><a href="#2-创建-server" class="headerlink" title="2.创建 server"></a>2.创建 server</h4><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> server = http.<span class="hljs-title function_">createServer</span>();</code></pre><h4 id="3-当客户端请求过来，就会自动触发服务器的-request-请求事件，-然后执行第二个参数：回调函数"><a href="#3-当客户端请求过来，就会自动触发服务器的-request-请求事件，-然后执行第二个参数：回调函数" class="headerlink" title="3. 当客户端请求过来，就会自动触发服务器的 request 请求事件， 然后执行第二个参数：回调函数"></a>3. 当客户端请求过来，就会自动触发服务器的 request 请求事件， 然后执行第二个参数：回调函数</h4><blockquote><ul><li>  request 请求事件处理函数 需要接受俩个参数：  </li><li>  request 请求对象：请求对象可以用来获取客户端的一些请求信息，例如请求路径</li><li> response 响应对象 ：响应对象可以用来给客户端发送响应信息</li></ul></blockquote><pre><code class="hljs JavaScript">server.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;request&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;收到了客户端的请求了,请求路径是：&#x27;</span> + req.<span class="hljs-property">url</span>);    <span class="hljs-comment">// 要根据不同的请求立即发送不同的响应结果</span>    <span class="hljs-comment">//  1. 获取请求路径</span>    <span class="hljs-keyword">const</span> url = req.<span class="hljs-property">url</span>;    <span class="hljs-comment">//     req.url  获得到的是端口号之后的那一部分路径</span>    <span class="hljs-comment">//     也就是说 所有的 url 都是以 / 开头的</span>    <span class="hljs-comment">//  2. 判断路径来处理响应</span>    <span class="hljs-keyword">if</span> (url == <span class="hljs-string">&#x27;/&#x27;</span>) &#123;        res.<span class="hljs-title function_">end</span>(<span class="hljs-string">&#x27;index page&#x27;</span>);    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (url == <span class="hljs-string">&#x27;/login&#x27;</span>) &#123;        res.<span class="hljs-title function_">end</span>(<span class="hljs-string">&#x27;login page&#x27;</span>);    &#125; <span class="hljs-keyword">else</span> &#123;        res.<span class="hljs-title function_">end</span>(<span class="hljs-string">&#x27;404 Not found.&#x27;</span>)    &#125;&#125;);</code></pre><hr><p>不推荐使用 wirte  因为end的参数就可以接受，并且开发中基本都是一对一的响应</p><pre><code class="hljs JavaScript">    <span class="hljs-comment">// response 对象有一个方法： write 可以用来给客户端发送响应数据</span>    <span class="hljs-comment">// write 可以使用多次 ，但是最后一次一定要使用 end 来结束响应， 否则客户端会一直等待</span>     <span class="hljs-keyword">if</span> (req.<span class="hljs-property">url</span> == <span class="hljs-string">&#x27;/&#x27;</span>) &#123;         res.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27;heelo&#x27;</span>);         res.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27; nonejs&#x27;</span>);     &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (req.<span class="hljs-property">url</span> == <span class="hljs-string">&#x27;/login&#x27;</span>) &#123;         res.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27;login&#x27;</span>);     &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (req.<span class="hljs-property">url</span> == <span class="hljs-string">&#x27;/index&#x27;</span>) &#123;         res.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27;index&#x27;</span>);     &#125;    res.<span class="hljs-title function_">end</span>();     <span class="hljs-comment">//  以上的代码方式比较麻烦， 推荐使用直接 end 的同时 加请求信息</span><span class="hljs-comment">// res.end(&#x27;hello nodejs&#x27;);</span></code></pre><hr><h5 id="以下例子证明了-响应内容只能是-字符串-和-二进制-。-对象，数组，布尔值，数值等等都是不行的"><a href="#以下例子证明了-响应内容只能是-字符串-和-二进制-。-对象，数组，布尔值，数值等等都是不行的" class="headerlink" title="以下例子证明了 响应内容只能是 字符串 和 二进制 。  对象，数组，布尔值，数值等等都是不行的"></a>以下例子证明了 响应内容只能是 字符串 和 二进制 。  对象，数组，布尔值，数值等等都是不行的</h5><pre><code class="hljs JavaScript"><span class="hljs-keyword">if</span> (url == <span class="hljs-string">&#x27;/products&#x27;</span>) &#123;    <span class="hljs-keyword">let</span> products = [&#123;       <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;苹果&#x27;</span>,        <span class="hljs-attr">price</span>: <span class="hljs-number">5</span>    &#125;, &#123;        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;香蕉&#x27;</span>,        <span class="hljs-attr">price</span>: <span class="hljs-number">3</span>    &#125;];    res.<span class="hljs-title function_">end</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(products));&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Nodejs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于Express 下的 增删改查项目</title>
    <link href="/2020/08/05/08.%E5%9F%BA%E4%BA%8EExpress%20%E4%B8%8B%E7%9A%84%20%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E9%A1%B9%E7%9B%AE/"/>
    <url>/2020/08/05/08.%E5%9F%BA%E4%BA%8EExpress%20%E4%B8%8B%E7%9A%84%20%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="基于Express-下的-增删改查项目"><a href="#基于Express-下的-增删改查项目" class="headerlink" title="基于Express 下的 增删改查项目"></a>基于Express 下的 增删改查项目</h1><h2 id="整体步骤："><a href="#整体步骤：" class="headerlink" title="整体步骤："></a>整体步骤：</h2><ul><li>处理模块</li><li>配置开放静态资源</li><li>配置模板引擎</li><li>简单路由： /students 渲染静态页面</li><li>路由设计</li><li>提取路由模块</li><li>由于接下来一系列的业务操作都需要处理文件数据，所以我们需要封装一个 students.js 模块</li><li>写好  students.js 文件结构<ul><li> find  查询所有学生列表的 API </li><li>  findById 查询单个学生的ID</li><li> save   保存学生信息</li><li> updateById   更新学生信息</li><li> deleteById  删除学生信息</li></ul></li><li>实现具体功能<ul><li>通过路由收到请求</li><li>接受请求中的数据（get, post）<ul><li>req.query </li><li>rqe.body</li></ul></li><li>调用数据操作API 处理数据</li><li>根据数据结果给客户端发送响应</li></ul></li><li>业务功能处理顺序<ul><li>列表</li><li>添加</li><li>编辑</li><li>删除</li></ul></li></ul><h2 id="路由设计"><a href="#路由设计" class="headerlink" title="路由设计"></a>路由设计</h2><table><thead><tr><th>请求方法</th><th>请求路径</th><th>get参数</th><th>post参数</th><th>备注</th></tr></thead><tbody><tr><td>GET</td><td>/</td><td></td><td></td><td>渲染首页</td></tr><tr><td>GET</td><td>/new</td><td></td><td></td><td>渲染添加页面</td></tr><tr><td>POST</td><td>/new</td><td></td><td>name、age、gender、hobbies</td><td>处理添加请求</td></tr><tr><td>GET</td><td>/edit</td><td>id</td><td></td><td>渲染编辑页面</td></tr><tr><td>POST</td><td>/edit</td><td></td><td>id、name、age、gender、hobbies</td><td>处理编辑请求</td></tr><tr><td>GET</td><td>/delete</td><td>id</td><td></td><td>处理编辑请求</td></tr></tbody></table><h2 id="1-app-js"><a href="#1-app-js" class="headerlink" title="1.app.js"></a>1.app.js</h2><h3 id="用来加载模块和模板引擎"><a href="#用来加载模块和模板引擎" class="headerlink" title="用来加载模块和模板引擎"></a>用来加载模块和模板引擎</h3><pre><code class="hljs JavaScript"><span class="hljs-comment">//  引入express 模块</span><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>()<span class="hljs-keyword">const</span> bodyParser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;body-parser&#x27;</span>)<span class="hljs-comment">// 引入 touter.js 模块（自定义模块）</span><span class="hljs-keyword">const</span> router = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./router&#x27;</span>)<span class="hljs-comment">// 在express中使用 art-template 模块引擎</span>app.<span class="hljs-title function_">engine</span>(<span class="hljs-string">&#x27;html&#x27;</span>, <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express-art-template&#x27;</span>))<span class="hljs-comment">// 开放静态资源</span>app.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;/node_modules/&#x27;</span>, express.<span class="hljs-title function_">static</span>(<span class="hljs-string">&#x27;./node_modules/&#x27;</span>))app.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;/public/&#x27;</span>, express.<span class="hljs-title function_">static</span>(<span class="hljs-string">&#x27;./public/&#x27;</span>))<span class="hljs-comment">//一定要放在 app.use(router) 挂载路由之前</span><span class="hljs-comment">// create application/json parser</span>app.<span class="hljs-title function_">use</span>(bodyParser.<span class="hljs-title function_">json</span>())<span class="hljs-comment">// create application/x-www-form-urlencoded parser</span>app.<span class="hljs-title function_">use</span>(bodyParser.<span class="hljs-title function_">urlencoded</span>(&#123;    <span class="hljs-attr">extended</span>: <span class="hljs-literal">false</span>&#125;))<span class="hljs-comment">// 把 router模块中 的 路由容器挂载在app这个服务上</span>app.<span class="hljs-title function_">use</span>(router)app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;running...&#x27;</span>);&#125;)</code></pre><h2 id="2-router-js"><a href="#2-router-js" class="headerlink" title="2.router.js"></a>2.router.js</h2><h3 id="用来挂载路由"><a href="#用来挂载路由" class="headerlink" title="用来挂载路由"></a>用来挂载路由</h3><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<span class="hljs-keyword">const</span> <span class="hljs-title class_">Student</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./students.js&#x27;</span>)<span class="hljs-comment">// 创建一个路由容器</span><span class="hljs-keyword">const</span> router = express.<span class="hljs-title class_">Router</span>()<span class="hljs-comment">// 把路由都挂载到 router 路由容器中</span>router.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;   &#125;)router.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/new&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;    &#125;)router.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/new&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;&#125;)router.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/edit&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;&#125;)router.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/edit&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;&#125;)router.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/delete&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;&#125;)<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = router</code></pre><h3 id="2-1-调用-获取学生信息的封装函数"><a href="#2-1-调用-获取学生信息的封装函数" class="headerlink" title="2.1  调用  获取学生信息的封装函数"></a>2.1  调用  获取学生信息的封装函数</h3><pre><code class="hljs JavaScript">router.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;    <span class="hljs-title class_">Student</span>.<span class="hljs-title function_">find</span>(<span class="hljs-function">(<span class="hljs-params">err,students</span>)=&gt;</span>&#123;        <span class="hljs-keyword">if</span>(err)&#123;        <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">status</span>(<span class="hljs-number">500</span>).<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Servererr..&#x27;</span>)        &#125;        res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;index.html&#x27;</span>,&#123;            <span class="hljs-attr">comments</span>: [<span class="hljs-string">&#x27;苹果&#x27;</span>, <span class="hljs-string">&#x27;橘子&#x27;</span>, <span class="hljs-string">&#x27;香蕉&#x27;</span>, <span class="hljs-string">&#x27;菠萝&#x27;</span>],            <span class="hljs-attr">students</span>: students        &#125;)    &#125;)&#125;)</code></pre><h3 id="2-2-调用-添加并保存学生信息的封装函数"><a href="#2-2-调用-添加并保存学生信息的封装函数" class="headerlink" title="2.2 调用 添加并保存学生信息的封装函数"></a>2.2 调用 添加并保存学生信息的封装函数</h3><pre><code class="hljs JavaScript">router.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/new&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;   <span class="hljs-title class_">Student</span>.<span class="hljs-title function_">save</span>(req.<span class="hljs-property">body</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (err) &#123;            <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">status</span>(<span class="hljs-number">500</span>).<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Server err..&#x27;</span>)        &#125;        res.<span class="hljs-title function_">redirect</span>(<span class="hljs-string">&#x27;/&#x27;</span>)    &#125;)&#125;)</code></pre><h3 id="2-3-1-修改前-前调取-修改该学生的ID"><a href="#2-3-1-修改前-前调取-修改该学生的ID" class="headerlink" title="2.3 1.修改前 前调取 修改该学生的ID"></a>2.3 1.修改前 前调取 修改该学生的ID</h3><pre><code class="hljs JavaScript">router.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/edit&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;    <span class="hljs-comment">// 1. 在客户端的列表页中处理链接问题 （需要有 id 的参数）</span>    <span class="hljs-comment">// 2. 获取要编辑的 id</span>    <span class="hljs-comment">// console.log(req.query.id);</span>    <span class="hljs-comment">// 3. 渲染编辑页面   </span>    <span class="hljs-comment">//   根据id 吧学生信息查出来</span>    <span class="hljs-comment">//   使用模板引擎来渲染页面</span>    <span class="hljs-title class_">Student</span>.<span class="hljs-title function_">findById</span>(<span class="hljs-built_in">parseInt</span>(req.<span class="hljs-property">query</span>.<span class="hljs-property">id</span>), <span class="hljs-function">(<span class="hljs-params">err, student</span>) =&gt;</span> &#123;        <span class="hljs-comment">// req.query.id 是字符串 而我们要的 id 是个 数字型 所以要转换</span>        <span class="hljs-keyword">if</span> (err) &#123;            <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">status</span>(<span class="hljs-number">500</span>).<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Server err..&#x27;</span>)        &#125;        <span class="hljs-comment">// console.log(studnet);   id 是多 传过来的数据 就是 该 id 的对象</span>        <span class="hljs-comment">// 把 所取到该 id 对象的 值 来渲染到页面上</span>        res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;edit.html&#x27;</span>, &#123;            <span class="hljs-attr">student</span>: student        &#125;)    &#125;)&#125;)</code></pre><h3 id="2-3-2-调用-修改学生信息的封装函数"><a href="#2-3-2-调用-修改学生信息的封装函数" class="headerlink" title="2.3 2.调用 修改学生信息的封装函数"></a>2.3 2.调用 修改学生信息的封装函数</h3><pre><code class="hljs JavaScript">router.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/edit&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;    <span class="hljs-comment">// 1. 获取表单数据  req.body </span>    <span class="hljs-comment">// console.log(req.body);</span>    <span class="hljs-comment">// 2.  更新       Student.updataById()</span>    <span class="hljs-comment">//  3.  发送响应</span>    <span class="hljs-title class_">Student</span>.<span class="hljs-title function_">updateById</span>(req.<span class="hljs-property">body</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (err) &#123;            <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">status</span>(<span class="hljs-number">500</span>).<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Server err..&#x27;</span>)        &#125;        res.<span class="hljs-title function_">redirect</span>(<span class="hljs-string">&#x27;/&#x27;</span>)    &#125;)&#125;)</code></pre><h3 id="2-4-调用-删除学生信息的封装函数"><a href="#2-4-调用-删除学生信息的封装函数" class="headerlink" title="2.4 调用 删除学生信息的封装函数"></a>2.4 调用 删除学生信息的封装函数</h3><pre><code class="hljs JavaScript">router.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/delete&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;    <span class="hljs-comment">// 1. 在客户端的列表页中处理链接问题 （需要有 id 的参数）</span>    <span class="hljs-comment">// 2. 获取要编辑的 id</span>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(req.<span class="hljs-property">query</span>.<span class="hljs-property">id</span>);    <span class="hljs-comment">// 3. 渲染编辑页面   </span>    <span class="hljs-comment">//   根据id 把学生信息查出来</span>    <span class="hljs-comment">//   使用模板引擎来渲染页面</span>    <span class="hljs-title class_">Student</span>.<span class="hljs-title function_">deleteById</span>(<span class="hljs-built_in">parseInt</span>(req.<span class="hljs-property">query</span>.<span class="hljs-property">id</span>), <span class="hljs-function">(<span class="hljs-params">err, student</span>) =&gt;</span> &#123;        <span class="hljs-comment">// req.query.id 是字符串 而我们要的 id 是个 数字型 所以要转换</span>        <span class="hljs-keyword">if</span> (err) &#123;            <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">status</span>(<span class="hljs-number">500</span>).<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Server err..&#x27;</span>)        &#125;        res.<span class="hljs-title function_">redirect</span>(<span class="hljs-string">&#x27;/&#x27;</span>)    &#125;)&#125;)</code></pre><h2 id="3-students-js"><a href="#3-students-js" class="headerlink" title="3.students.js"></a>3.students.js</h2><h3 id="设计操作文件数据的API模块"><a href="#设计操作文件数据的API模块" class="headerlink" title="设计操作文件数据的API模块"></a>设计操作文件数据的API模块</h3><h4 id="用来处理增删改查数据"><a href="#用来处理增删改查数据" class="headerlink" title="用来处理增删改查数据"></a>用来处理增删改查数据</h4><pre><code class="hljs JavaScript">/  数据文件操作模块<span class="hljs-comment">// 职责： 操作文件中的数据： 只处理数据 不处理业务</span><span class="hljs-comment">// 1. 获取所有学生信息列表</span><span class="hljs-built_in">exports</span>.<span class="hljs-property">find</span> = <span class="hljs-function">() =&gt;</span> &#123; &#125;<span class="hljs-comment">// 1.1 通过ID 来获取 该学生的信息</span><span class="hljs-built_in">exports</span>.<span class="hljs-property">findById</span> = <span class="hljs-function">() =&gt;</span> &#123; &#125;<span class="hljs-comment">// 2. 添加保存学生信息</span><span class="hljs-built_in">exports</span>.<span class="hljs-property">save</span> = <span class="hljs-function">() =&gt;</span> &#123; &#125;<span class="hljs-comment">// 3. 更新学生信息</span><span class="hljs-built_in">exports</span>.<span class="hljs-property">updateById</span> = <span class="hljs-function">() =&gt;</span> &#123; &#125;<span class="hljs-comment">// 4. 删除学生信息</span><span class="hljs-built_in">exports</span>.<span class="hljs-property">delete</span> = <span class="hljs-function">() =&gt;</span> &#123; &#125;</code></pre><h3 id="3-1-获取所有学生信息封装函数"><a href="#3-1-获取所有学生信息封装函数" class="headerlink" title="3.1 获取所有学生信息封装函数"></a>3.1 获取所有学生信息封装函数</h3><pre><code class="hljs JavaScript"><span class="hljs-built_in">exports</span>.<span class="hljs-property">find</span> = <span class="hljs-function">(<span class="hljs-params">callback</span>) =&gt;</span> &#123;    fs.<span class="hljs-title function_">readFile</span>(dbPath, <span class="hljs-string">&#x27;utf8&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (err) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-title function_">callback</span>(err)        &#125;        <span class="hljs-comment">// err  成功时返回 null  错误返回 err</span>        <span class="hljs-comment">// data  成功时返回 data  错误返回 undefined</span>        <span class="hljs-title function_">callback</span>(<span class="hljs-literal">null</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(data).<span class="hljs-property">students</span>)    &#125;)&#125;</code></pre><h3 id="3-2-添加并保存学生信息"><a href="#3-2-添加并保存学生信息" class="headerlink" title="3.2 添加并保存学生信息"></a>3.2 添加并保存学生信息</h3><pre><code class="hljs JavaScript"><span class="hljs-comment">// student 表示 添加的值</span><span class="hljs-built_in">exports</span>.<span class="hljs-property">save</span> = <span class="hljs-function">(<span class="hljs-params">student, callback</span>) =&gt;</span> &#123;    <span class="hljs-comment">// 1. 读文件</span>    fs.<span class="hljs-title function_">readFile</span>(dbPath, <span class="hljs-string">&#x27;utf8&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (err) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-title function_">callback</span>(err)        &#125;       <span class="hljs-comment">// 2. 转成对象</span>        <span class="hljs-keyword">let</span> students = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(data).<span class="hljs-property">students</span>        <span class="hljs-comment">// 2.1处理id 唯一  不重复</span>        student.<span class="hljs-property">id</span> = students[students.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>].<span class="hljs-property">id</span> + <span class="hljs-number">1</span>        <span class="hljs-comment">// 3.把用户传递的对象push到数组中</span>        students.<span class="hljs-title function_">push</span>(student)        <span class="hljs-comment">// 4.把对象转成字符串</span>        <span class="hljs-keyword">let</span> fileData = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(&#123;            <span class="hljs-attr">students</span>: students        &#125;)        <span class="hljs-comment">// 5.把字符串保存在 文件中</span>        fs.<span class="hljs-title function_">writeFile</span>(dbPath, fileData, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;            <span class="hljs-keyword">if</span> (err) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-title function_">callback</span>(err)            &#125;            <span class="hljs-title function_">callback</span>(<span class="hljs-literal">null</span>)        &#125;)    &#125;)&#125;</code></pre><h3 id="3-3-修改学生信息"><a href="#3-3-修改学生信息" class="headerlink" title="3.3  修改学生信息"></a>3.3  修改学生信息</h3><h4 id="3-3-1-获得修改该学生个人ID"><a href="#3-3-1-获得修改该学生个人ID" class="headerlink" title="3.3.1 获得修改该学生个人ID"></a>3.3.1 获得修改该学生个人ID</h4><pre><code class="hljs JavaScript"><span class="hljs-comment">// 1.1  通过ID 来获取 该学生的信息</span><span class="hljs-built_in">exports</span>.<span class="hljs-property">findById</span> = <span class="hljs-function">(<span class="hljs-params">id, callback</span>) =&gt;</span> &#123;    fs.<span class="hljs-title function_">readFile</span>(dbPath, <span class="hljs-string">&#x27;utf8&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (err) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-title function_">callback</span>(err)        &#125;        <span class="hljs-keyword">let</span> students = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(data).<span class="hljs-property">students</span>        <span class="hljs-keyword">let</span> ret = students.<span class="hljs-title function_">find</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;            <span class="hljs-keyword">return</span> item.<span class="hljs-property">id</span> === <span class="hljs-built_in">parseInt</span>(id)        &#125;)        <span class="hljs-title function_">callback</span>(<span class="hljs-literal">null</span>, ret)    &#125;)&#125;</code></pre><h4 id="3-3-2-修改学生信息"><a href="#3-3-2-修改学生信息" class="headerlink" title="3.3.2  修改学生信息"></a>3.3.2  修改学生信息</h4><pre><code class="hljs JavaScript"><span class="hljs-comment">// 3. 更新学生信息</span><span class="hljs-built_in">exports</span>.<span class="hljs-property">updateById</span> = <span class="hljs-function">(<span class="hljs-params">student, callback</span>) =&gt;</span> &#123;    <span class="hljs-comment">// 1. 读文件</span>    fs.<span class="hljs-title function_">readFile</span>(dbPath, <span class="hljs-string">&#x27;utf8&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (err) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-title function_">callback</span>(err)        &#125;        <span class="hljs-comment">// 2. 转成对象</span>        <span class="hljs-keyword">let</span> students = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(data).<span class="hljs-property">students</span>        <span class="hljs-comment">// 注意要把 id 改成数字型  因为 更改信息的时候 id会变成字符串</span>        <span class="hljs-keyword">let</span> studentsId = <span class="hljs-built_in">parseInt</span>(student.<span class="hljs-property">id</span>)        <span class="hljs-comment">// 3.需要修改谁， 就把谁的ID找出来     （找出修改的 对象 ）</span>        <span class="hljs-comment">// 使用 ES6 中 find 方法来 遍历符合 item.id === studnent.id 条件的时候， find会终止遍历并返回</span>        <span class="hljs-keyword">let</span> stu = students.<span class="hljs-title function_">find</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;            <span class="hljs-keyword">return</span> item.<span class="hljs-property">id</span> === studentsId        &#125;)        <span class="hljs-comment">// console.log(stu);  // &#123; id: 1, name: &#x27;朱元璋111&#x27;, gender: 0, age: 22, hobbies: &#x27;写代码&#x27; &#125;</span>        <span class="hljs-comment">// 4. 拿到 需要修改的  让它遍历拷贝对象  （ 修改这个被找出来的 对象）</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> student) &#123;            stu[key] = student[key]        &#125;        <span class="hljs-comment">// console.log(students);  // 是jsonw文件中的 students 内的 所有对象</span>        <span class="hljs-comment">// 5.把对象转成字符串</span>        <span class="hljs-keyword">let</span> fileData = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(&#123;            <span class="hljs-attr">students</span>: students        &#125;)        <span class="hljs-comment">// 6.把字符串保存在 文件中</span>        fs.<span class="hljs-title function_">writeFile</span>(dbPath, fileData, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;            <span class="hljs-keyword">if</span> (err) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-title function_">callback</span>(err)            &#125;            <span class="hljs-title function_">callback</span>(<span class="hljs-literal">null</span>)        &#125;)    &#125;)&#125;</code></pre><h3 id="3-4-删除学生信息"><a href="#3-4-删除学生信息" class="headerlink" title="3.4  删除学生信息"></a>3.4  删除学生信息</h3><pre><code class="hljs JavaScript"><span class="hljs-comment">// 4. 删除学生信息</span><span class="hljs-built_in">exports</span>.<span class="hljs-property">deleteById</span> = <span class="hljs-function">(<span class="hljs-params">id, callback</span>) =&gt;</span> &#123;    <span class="hljs-comment">// 1. 读文件</span>    fs.<span class="hljs-title function_">readFile</span>(dbPath, <span class="hljs-string">&#x27;utf8&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (err) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-title function_">callback</span>(err)        &#125;        <span class="hljs-comment">// 2. 转成对象</span>        <span class="hljs-keyword">let</span> students = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(data).<span class="hljs-property">students</span>        <span class="hljs-keyword">let</span> deleteID = students.<span class="hljs-title function_">findIndex</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;            <span class="hljs-keyword">return</span> item.<span class="hljs-property">id</span> === <span class="hljs-built_in">parseInt</span>(id)        &#125;)        students.<span class="hljs-title function_">splice</span>(deleteID, <span class="hljs-number">1</span>)        <span class="hljs-comment">// 4.把对象转成字符串</span>        <span class="hljs-keyword">let</span> fileData = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(&#123;            <span class="hljs-attr">students</span>: students        &#125;)        <span class="hljs-comment">// 5.把字符串保存在 文件中</span>        fs.<span class="hljs-title function_">writeFile</span>(dbPath, fileData, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;            <span class="hljs-keyword">if</span> (err) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-title function_">callback</span>(err)            &#125;            <span class="hljs-title function_">callback</span>(<span class="hljs-literal">null</span>)        &#125;)    &#125;)&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Nodejs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Node</tag>
      
      <tag>Express</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Node介绍</title>
    <link href="/2020/08/04/01.Nodejs%E4%BB%8B%E7%BB%8D/"/>
    <url>/2020/08/04/01.Nodejs%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="Node-js-准备"><a href="#Node-js-准备" class="headerlink" title="Node.js 准备"></a>Node.js 准备</h1><h2 id="学前准备"><a href="#学前准备" class="headerlink" title="学前准备"></a>学前准备</h2><ul><li>Node.js 是什么<ul><li>JavaScript 运行时</li><li>既不是语言，也不是框架，它是一个平台</li></ul></li><li>Node.js 中的 JavaScript<ul><li>没有 BOM、DOM</li><li>EcmaScript 基本的 JavaScript 语言部分</li><li>在 Node 中为 JavaScript 提供了一些服务器级别的 API<ul><li>文件操作的能力</li><li>http 服务的能力</li></ul></li></ul></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>Node 中的 JavaScript</p><ul><li>EcmaScript<ul><li>变量</li><li>方法</li><li>数据类型</li><li>内置对象</li><li>Array</li><li>Object</li><li>Date</li><li>Math</li></ul></li><li>模块系统<ul><li>在 Node 中没有全局作用域的概念</li><li>在 Node 中，只能通过 require 方法来加载执行多个 JavaScript 脚本文件</li><li>require 加载只能是执行其中的代码，文件与文件之间由于是模块作用域，所以不会有污染的问题<ul><li>模块完全是封闭的</li><li>外部无法访问内部</li><li>内部也无法访问外部</li></ul></li><li>模块作用域固然带来了一些好处，可以加载执行多个文件，可以完全避免变量命名冲突污染的问题</li><li>但是某些情况下，模块与模块是需要进行通信的</li><li>在每个模块中，都提供了一个对象：<code>exports</code></li><li>该对象默认是一个空对象</li><li>你要做的就是把需要被外部访问使用的成员手动的挂载到 <code>exports</code> 接口对象中</li><li>然后谁来 <code>require</code> 这个模块，谁就可以得到模块内部的 <code>exports</code> 接口对象</li><li>还有其它的一些规则，具体后面讲，以及如何在项目中去使用这种编程方式，会通过后面的案例来处理</li></ul></li><li>核心模块<ul><li>核心模块是由 Node 提供的一个个的具名的模块，它们都有自己特殊的名称标识，例如<ul><li>fs 文件操作模块</li><li>http 网络服务构建模块</li><li>os 操作系统信息模块</li><li>path 路径处理模块</li><li>。。。。</li></ul></li><li>所有核心模块在使用的时候都必须手动的先使用 <code>require</code> 方法来加载，然后才可以使用，例如：<ul><li><code>var fs = require(&#39;fs&#39;)</code></li></ul></li></ul></li></ul></li><li><p>http</p><ul><li>require</li><li>端口号<ul><li>ip 地址定位计算机</li><li>端口号定位具体的应用程序</li></ul></li><li>Content-Type<ul><li>服务器最好把每次响应的数据是什么内容类型都告诉客户端，而且要正确的告诉</li><li>不同的资源对应的 Content-Type 是不一样，具体参照：<a href="http://tool.oschina.net/commons">http://tool.oschina.net/commons</a></li><li>对于文本类型的数据，最好都加上编码，目的是为了防止中文解析乱码问题</li></ul></li><li>通过网络发送文件<ul><li>发送的并不是文件，本质上来讲发送是文件的内容</li><li>当浏览器收到服务器响应内容之后，就会根据你的 Content-Type 进行对应的解析处理<pre><code class="hljs reasonml">res.set<span class="hljs-constructor">Header(&#x27;Content-Type&#x27;, &#x27;<span class="hljs-params">text</span><span class="hljs-operator">/</span><span class="hljs-params">plain</span>;<span class="hljs-params">charset</span>=<span class="hljs-params">utf</span>-8&#x27;)</span>;</code></pre></li></ul></li></ul></li><li><p>模块系统</p></li><li><p>Node 中的其它的核心模块</p></li><li><p>做一个小管理系统：</p><ul><li>CRUD</li></ul></li><li><p>Express Web 开发框架</p><ul><li><code>npm install express</code></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Nodejs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Node</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
